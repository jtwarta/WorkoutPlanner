<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0a">
<title>LiftScript</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0a;
  --surface: #131315;
  --surface2: #1a1a1e;
  --surface3: #222226;
  --border: #2a2a2e;
  --border-light: #333338;
  --text: #f4f4f6;
  --text-mid: #bcbcc4;
  --text-dim: #8e8e98;
  --accent: #4ade80;
  --accent-dim: rgba(74, 222, 128, 0.12);
  --warn: #fb923c;
  --warn-dim: rgba(251, 146, 60, 0.12);
  --danger: #f87171;
  --danger-dim: rgba(248, 113, 113, 0.12);
  --blue: #60a5fa;
  --blue-dim: rgba(96, 165, 250, 0.12);
  --purple: #c084fc;
  --purple-dim: rgba(192, 132, 252, 0.12);
  --strength: #818cf8;
  --strength-dim: rgba(129, 140, 248, 0.12);
  color-scheme: dark;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  background: #0a0a0a;
  background-color: #0a0a0a;
  color-scheme: dark;
}

body {
  font-family: 'Figtree', -apple-system, sans-serif;
  color: var(--text);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  line-height: 1.5;
}

.mono { font-family: 'Space Grotesk', sans-serif; }

/* Layout */
.app {
  max-width: 480px;
  margin: 0 auto;
  padding: 20px 18px;
  padding-bottom: 120px;
  background: #0a0a0a;
}

/* Header */
.header {
  padding: 8px 0 12px;
  margin-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.header h1 {
  font-size: 26px;
  font-weight: 700;
  letter-spacing: -0.5px;
  color: var(--text);
}
.header .subtitle {
  font-size: 13px;
  color: var(--text-dim);
  font-family: 'Space Grotesk', sans-serif;
}

/* Cards */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 18px;
  margin-bottom: 14px;
}
.card-title {
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
}

/* Tabs */
.tabs {
  display: flex;
  gap: 4px;
  margin-bottom: 18px;
  background: var(--surface);
  border-radius: 12px;
  padding: 4px;
  border: 1px solid var(--border);
}
.tab {
  flex: 1;
  padding: 9px 6px;
  text-align: center;
  font-size: 16px;
  font-weight: 600;
  border-radius: 9px;
  cursor: pointer;
  color: var(--text-dim);
  transition: all 0.25s ease;
  border: none;
  background: none;
  font-family: 'Figtree', sans-serif;
  -webkit-tap-highlight-color: transparent;
}
.tab.active {
  background: var(--surface3);
  color: var(--text);
}

/* ===================== */
/* RECOMMENDATIONS       */
/* ===================== */
.rec-item {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: background 0.15s ease;
}
.rec-item:last-child { border-bottom: none; }
.rec-item:active { background: var(--surface2); }

.rec-row {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 14px 2px;
}
.rec-rank {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 16px;
  font-weight: 600;
  color: var(--accent);
  width: 24px;
  text-align: center;
  flex-shrink: 0;
}
.rec-info { flex: 1; min-width: 0; }
.rec-name {
  font-size: 17px;
  font-weight: 600;
  line-height: 1.3;
  color: var(--text);
}
.rec-detail {
  font-size: 14px;
  color: var(--text-mid);
  margin-top: 3px;
  font-family: 'Space Grotesk', sans-serif;
}
.rec-urgency {
  font-size: 11px;
  font-weight: 600;
  padding: 5px 10px;
  border-radius: 6px;
  font-family: 'Space Grotesk', sans-serif;
  flex-shrink: 0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.urgency-high { background: var(--danger-dim); color: var(--danger); }
.urgency-med { background: var(--warn-dim); color: var(--warn); }
.urgency-low { background: var(--accent-dim); color: var(--accent); }

/* Expandable explainer */
.rec-expand {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
}
.rec-expand.open {
  opacity: 1;
}
.rec-explainer {
  padding: 0 2px 14px 40px;
  font-size: 14px;
  color: var(--text-mid);
  line-height: 1.55;
}
.rec-explainer strong {
  color: var(--text);
  font-weight: 600;
}

/* ===================== */
/* EXERCISE PRESCRIPTIONS */
/* ===================== */
.session-summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--border);
}
.session-time {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 15px;
  font-weight: 600;
  color: var(--accent);
}
.session-count {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 13px;
  color: var(--text-dim);
}

.ex-group {
  margin-bottom: 18px;
}
.ex-group:last-child { margin-bottom: 0; }
.ex-group-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border);
}
.ex-row {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  padding: 8px 0;
}
.ex-name {
  font-size: 15px;
  font-weight: 500;
  flex: 1;
  min-width: 0;
  padding-right: 12px;
  color: var(--text);
}
.ex-prescription {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 13px;
  color: var(--accent);
  white-space: nowrap;
  flex-shrink: 0;
}
.ex-time {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 11px;
  color: var(--text-dim);
  white-space: nowrap;
  flex-shrink: 0;
  margin-left: 8px;
  min-width: 38px;
  text-align: right;
}

/* ===================== */
/* MUSCLE GRID (v1.2: tappable with explainers) */
/* ===================== */
.muscle-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.muscle-cell {
  border-radius: 10px;
  padding: 12px;
  transition: all 0.3s ease;
  border: 1px solid var(--border);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.muscle-cell:active { opacity: 0.85; }
.muscle-cell-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.muscle-name {
  font-size: 16px;
  font-weight: 600;
}
.muscle-urgency {
  font-size: 9px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Space Grotesk', sans-serif;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.muscle-stat {
  font-size: 12px;
  color: var(--text-mid);
  font-family: 'Space Grotesk', sans-serif;
  margin-top: 5px;
}
.muscle-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
  grid-column: 1 / -1;
}
.muscle-detail.open {
  opacity: 1;
}
.muscle-detail-inner {
  padding: 14px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 14px;
  color: var(--text-mid);
  line-height: 1.55;
}
.muscle-detail-inner strong {
  color: var(--text);
  font-weight: 600;
}

/* ===================== */
/* WEIGHT TAB            */
/* ===================== */
.weight-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-bottom: 18px;
}
.weight-left {
  display: flex;
  align-items: baseline;
  gap: 8px;
}
.weight-chart {
  width: 100%;
  height: 150px;
  position: relative;
}
.weight-chart canvas { width: 100%; height: 100%; }
.weight-current {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 32px;
  font-weight: 700;
  letter-spacing: -1px;
  color: var(--text);
}
.weight-delta {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 14px;
}
.weight-unit {
  font-size: 14px;
  color: var(--text-dim);
}

/* Constraints chips */
.constraints-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 14px;
}
.constraint-chip {
  padding: 5px 10px;
  font-size: 13px;
  font-weight: 500;
  font-family: 'Space Grotesk', sans-serif;
  background: var(--surface2);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: 6px;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.15s ease;
  user-select: none;
}
.constraint-chip:active {
  transform: scale(0.96);
}
.constraint-chip.active {
  color: var(--accent);
  border-color: rgba(74, 222, 128, 0.3);
  background: var(--accent-dim);
}
.chart-legend {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 12px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-mid);
}
.legend-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 5px;
  vertical-align: middle;
}

/* Weight input form */
.btn-log-weight {
  padding: 5px 12px;
  font-size: 13px;
  font-weight: 600;
  background: var(--accent-dim);
  color: var(--accent);
  border: 1px solid rgba(74, 222, 128, 0.25);
  border-radius: 7px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.2s ease;
}
.btn-log-weight:active {
  transform: scale(0.96);
}
.weight-input-form {
  display: none;
  align-items: center;
  gap: 8px;
  margin-bottom: 14px;
  padding: 12px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
  flex-wrap: wrap;
}
.weight-input-form.open {
  display: flex;
}
.weight-input-form input {
  width: 90px;
  padding: 7px 10px;
  font-size: 15px;
  font-family: 'Space Grotesk', sans-serif;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 7px;
  outline: none;
  -webkit-appearance: none;
}
.weight-input-form input:focus {
  border-color: var(--accent);
}
.weight-input-form .btn-save {
  padding: 7px 14px;
  font-size: 13px;
  font-weight: 600;
  background: var(--accent);
  color: #0a0a0a;
  border: none;
  border-radius: 7px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
}
.weight-input-form .btn-cancel {
  padding: 7px 10px;
  font-size: 13px;
  background: none;
  color: var(--text-dim);
  border: none;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
}

/* ===================== */
/* HISTORY - HEATMAP (v1.1: no scroll) */
/* ===================== */
.heatmap-container {
  margin: 0 -4px;
  padding: 0 4px;
}
.heatmap-grid {
  display: grid;
  gap: 3px;
}
.heatmap-label {
  font-size: 12px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-mid);
  display: flex;
  align-items: center;
  padding-right: 6px;
  white-space: nowrap;
  position: sticky;
  left: 0;
  background: var(--surface);
  z-index: 2;
}
.heatmap-cell {
  width: 18px;
  height: 18px;
  border-radius: 3px;
  background: var(--surface2);
  cursor: pointer;
  transition: opacity 0.15s ease;
}
.heatmap-cell:active {
  opacity: 0.7;
}
.heatmap-day-labels {
  font-size: 10px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-dim);
  display: flex;
  align-items: flex-end;
  padding-bottom: 4px;
  text-align: center;
  justify-content: center;
}
.heatmap-day-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
  margin-top: 0;
}
.heatmap-day-detail.open {
  opacity: 1;
  margin-top: 12px;
}
.heatmap-day-detail-inner {
  padding: 14px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 14px;
  line-height: 1.6;
}
.heatmap-day-detail-inner .detail-date {
  font-weight: 600;
  margin-bottom: 8px;
  font-size: 13px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-mid);
}
.heatmap-day-detail-inner .detail-exercise {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  padding: 4px 0;
}
.heatmap-day-detail-inner .detail-name {
  font-weight: 500;
  font-size: 14px;
  color: var(--text);
}
.heatmap-day-detail-inner .detail-sets {
  font-size: 12px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--accent);
  flex-shrink: 0;
}

/* ===================== */
/* HISTORY (legacy)      */
/* ===================== */
.workout-item {
  padding: 10px 0;
  border-bottom: 1px solid var(--border);
}
.workout-item:last-child { border-bottom: none; }
.workout-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
}
.workout-meta {
  font-size: 13px;
  color: var(--text-mid);
  font-family: 'Space Grotesk', sans-serif;
  margin-top: 3px;
  line-height: 1.4;
}

/* ===================== */
/* LOADING & ERROR       */
/* ===================== */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  gap: 18px;
}
.spinner {
  width: 28px; height: 28px;
  border: 2.5px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.75s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-text {
  font-size: 14px;
  color: var(--text-dim);
  font-family: 'Space Grotesk', sans-serif;
}
.error-msg {
  background: var(--danger-dim);
  border: 1px solid rgba(248,113,113,0.2);
  border-radius: 10px;
  padding: 14px;
  font-size: 14px;
  color: var(--danger);
  margin-bottom: 14px;
  line-height: 1.4;
}

/* Health Vitals */
.vitals-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 14px;
}
.vital-cell {
  padding: 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--surface2);
}
.vital-label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
  margin-bottom: 6px;
}
.vital-value {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 22px;
  font-weight: 700;
  color: var(--text);
  line-height: 1.2;
}
.vital-unit {
  font-size: 12px;
  font-weight: 400;
  color: var(--text-dim);
  margin-left: 2px;
}
.vital-context {
  font-size: 11px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-dim);
  margin-top: 4px;
}

/* Cardio Fitness Score */
.cardio-score-row {
  margin-bottom: 14px;
  padding-bottom: 14px;
  border-bottom: 1px solid var(--border);
}
.cardio-score-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-bottom: 10px;
}
.cardio-score-left {
  display: flex;
  align-items: baseline;
  gap: 6px;
}
.cardio-score-value {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 28px;
  font-weight: 700;
  color: var(--text);
}
.cardio-score-unit {
  font-size: 12px;
  color: var(--text-dim);
}
.cardio-score-label {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 14px;
  font-weight: 600;
}
.cardio-score-bar-wrap {
  height: 6px;
  border-radius: 3px;
  background: var(--surface3);
  overflow: hidden;
  position: relative;
}
.cardio-score-bar {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s ease;
}
.cardio-score-scale {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  font-size: 10px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-dim);
}

/* ===================== */
/* CARDIO PLAN           */
/* ===================== */
.cardio-week-bar {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 14px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.cardio-week-done {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 14px;
  color: var(--text-mid);
}
.cardio-week-bar-track {
  flex: 1;
  height: 5px;
  border-radius: 3px;
  background: var(--surface3);
  overflow: hidden;
}
.cardio-week-bar-fill {
  height: 100%;
  border-radius: 3px;
  background: var(--blue);
  transition: width 0.4s ease;
}
.cardio-week-target {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 12px;
  color: var(--text-dim);
  white-space: nowrap;
}
.cardio-rx {
  padding: 12px 0;
  border-bottom: 1px solid var(--border);
}
.cardio-rx:last-child { border-bottom: none; }
.cardio-rx-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}
.cardio-rx-zone {
  font-size: 11px;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 5px;
  font-family: 'Space Grotesk', sans-serif;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.zone-2 { background: var(--blue-dim); color: var(--blue); }
.zone-4 { background: var(--warn-dim); color: var(--warn); }
.zone-5 { background: var(--danger-dim); color: var(--danger); }
.cardio-rx-time {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 13px;
  color: var(--text-dim);
}
.cardio-rx-name {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
}
.cardio-rx-detail {
  font-size: 13px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--text-mid);
  line-height: 1.5;
}
.cardio-rx-hr {
  display: inline-block;
  margin-top: 4px;
  font-size: 12px;
  font-family: 'Space Grotesk', sans-serif;
  color: var(--blue);
}
.cardio-done-msg {
  font-size: 14px;
  color: var(--accent);
  font-family: 'Space Grotesk', sans-serif;
  padding: 8px 0;
}

.hidden { display: none; }
</style>
</head>
<body>
<div class="app" id="app">

  <!-- Loading Screen -->
  <div id="loading-screen" class="loading">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">Connecting to Hevy...</div>
  </div>

  <!-- Main Dashboard -->
  <div id="dashboard" class="hidden">
    <div class="header">
      <div style="display:flex;align-items:baseline;gap:10px;">
        <h1>LiftScript</h1>
        <div class="subtitle" id="last-updated">v1.8</div>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="today" onclick="switchTab('today')">Today</button>
      <button class="tab" data-tab="muscles" onclick="switchTab('muscles')">Muscles</button>
      <button class="tab" data-tab="history" onclick="switchTab('history')">History</button>
      <button class="tab" data-tab="weight" onclick="switchTab('weight')">Body</button>
    </div>

    <!-- Today Tab -->
    <div id="tab-today">
      <div class="card" style="border:1px solid #2a2a2e;">
        <div class="card-title">Today's Session</div>
        <div id="constraints-row" class="constraints-row"></div>
        <div id="session-summary"></div>
        <div id="suggested-exercises"></div>
      </div>
      <div class="card" id="cardio-card" style="border:1px solid #2a2a2e;">
        <div class="card-title">Cardio Plan</div>
        <div id="cardio-summary"></div>
        <div id="cardio-prescriptions"></div>
      </div>
    </div>

    <!-- Muscles Tab -->
    <div id="tab-muscles" class="hidden">
      <div class="card">
        <div class="card-title">Muscle Group Status</div>
        <div id="muscle-grid" class="muscle-grid"></div>
        <div class="muscle-detail" id="muscle-detail">
          <div class="muscle-detail-inner" id="muscle-detail-inner"></div>
        </div>
      </div>
    </div>

    <!-- History Tab -->
    <div id="tab-history" class="hidden">
      <div class="card">
        <div class="card-title">Training Heatmap</div>
        <div class="heatmap-container" id="heatmap-container"></div>
        <div class="heatmap-day-detail" id="heatmap-day-detail">
          <div class="heatmap-day-detail-inner" id="heatmap-day-detail-inner"></div>
        </div>
      </div>
    </div>

    <!-- Weight Tab -->
    <div id="tab-weight" class="hidden">
      <div class="card">
        <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;">
          <span>Body Weight & Strength</span>
          <button class="btn-log-weight" onclick="toggleWeightForm()">+ Log</button>
        </div>
        <div class="weight-input-form" id="weight-input-form">
          <input type="date" id="weight-date-input" style="width:120px;padding:7px 6px;font-size:13px;font-family:'Space Grotesk',sans-serif;background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:7px;outline:none;-webkit-appearance:none;">
          <input type="number" id="weight-input" placeholder="lbs" step="0.1" inputmode="decimal">
          <button class="btn-save" onclick="saveWeight()">Save</button>
          <button class="btn-cancel" onclick="toggleWeightForm()">Cancel</button>
        </div>
        <div class="weight-header">
          <div class="weight-left">
            <span class="weight-current" id="weight-current">--</span>
            <span class="weight-delta" id="weight-delta"></span>
            <span class="weight-unit">lbs</span>
          </div>
        </div>
        <!-- v1.7: Compact strength detail (Option A) -->
        <div id="strength-detail" style="margin-bottom:14px;"></div>
        <div class="weight-chart">
          <canvas id="weight-canvas"></canvas>
        </div>
        <div class="chart-legend">
          <span><span class="legend-dot" style="background:#4ade80"></span>Weight</span>
          <span><span class="legend-dot" style="background:#818cf8"></span>Strength Score</span>
        </div>
      </div>

      <!-- Health Vitals Card -->
      <div class="card" id="health-vitals-card" style="display:none;">
        <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;">
          <span>Health Vitals</span>
          <span class="health-sync-time" id="health-sync-time" style="font-size:11px;font-family:'Space Grotesk',sans-serif;color:var(--text-dim);text-transform:none;letter-spacing:0;"></span>
        </div>
        <!-- Cardio Fitness Score -->
        <div class="cardio-score-row" id="cardio-score-row">
          <div class="cardio-score-header">
            <div class="cardio-score-left">
              <span class="cardio-score-value" id="cardio-score-value">--</span>
              <span class="cardio-score-unit">mL/kg/min</span>
            </div>
            <div class="cardio-score-label" id="cardio-score-label">--</div>
          </div>
          <div class="cardio-score-bar-wrap">
            <div class="cardio-score-bar" id="cardio-score-bar"></div>
          </div>
          <div class="cardio-score-scale">
            <span>Low</span><span>Fair</span><span>Good</span><span>High</span><span>Elite</span>
          </div>
        </div>
        <!-- Vitals Grid -->
        <div class="vitals-grid" id="vitals-grid"></div>
      </div>

      <!-- Body Measurements Card (v1.7) -->
      <div class="card" id="measurements-card">
        <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;">
          <span>Body Measurements</span>
          <button class="btn-log-weight" onclick="toggleMeasureForm()">+ Measure</button>
        </div>
        <div id="measure-input-form" style="display:none;padding:12px;background:#1a1a1e;border-radius:10px;border:1px solid #2a2a2e;margin-bottom:14px;"></div>
        <div id="measurements-display"></div>
        <div id="proportions-display" style="margin-top:14px;"></div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// LIFTSCRIPT v1.8
// ============================================================
// SCIENTIFIC FOUNDATION
// PILLAR 1: Volume-Hypertrophy Targets
// Source: Schoenfeld et al. (2017) "Dose-response relationship between weekly resistance
// training volume and increases in muscle mass"
// PILLAR 2: Strength Standards / Percentile Benchmarks
// Big Three: van den Hoek et al. (2024) "Normative data for the squat, bench press and
// deadlift" - 809,986 drug-tested competition entries from OpenPowerlifting
// PILLAR 3: 1RM Estimation - Brzycki (1993), Epley (1985)
// PILLAR 4: Progressive Overload - NSCA guideline: +2-10% when target reps achieved

// ============================================================
// USER PROFILE (silent - never displayed)
// ============================================================
const PROFILE = {
  dob: new Date('1989-07-21'),
  sex: 'male',
  ethnicity: 'caucasian',
  bodyweightLbs: 166,
  heightIn: 70, // 5'10" — used for proportion rules (waist:height ratio)
  get age() {
    const today = new Date();
    let age = today.getFullYear() - this.dob.getFullYear();
    const m = today.getMonth() - this.dob.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < this.dob.getDate())) age--;
    return age;
  },
  get bodyweightKg() { return this.bodyweightLbs * 0.453592; }
};

// ============================================================
// STRENGTH STANDARDS (Pillar 2)
// BW multipliers for 1RM - male, ~75kg class, age 26-35
// Percentile: [10th, 25th, 50th, 75th, 90th]
// ============================================================
const STRENGTH_STANDARDS = {
  'bench_press':     { multipliers: [0.70, 0.95, 1.20, 1.50, 1.95], keyMuscle: 'chest' },
  'squat':           { multipliers: [0.85, 1.20, 1.60, 2.10, 2.83], keyMuscle: 'quads' },
  'deadlift':        { multipliers: [1.05, 1.45, 1.85, 2.50, 3.25], keyMuscle: 'back' },
  'overhead_press':  { multipliers: [0.40, 0.55, 0.72, 0.90, 1.15], keyMuscle: 'shoulders' },
  'barbell_row':     { multipliers: [0.50, 0.70, 0.90, 1.15, 1.45], keyMuscle: 'back' },
  'barbell_curl':    { multipliers: [0.25, 0.35, 0.50, 0.65, 0.85], keyMuscle: 'biceps' },
  'skull_crusher':   { multipliers: [0.20, 0.30, 0.40, 0.55, 0.70], keyMuscle: 'triceps' },
  'leg_curl':        { multipliers: [0.25, 0.35, 0.50, 0.65, 0.80], keyMuscle: 'hamstrings' },
  'hip_thrust':      { multipliers: [0.65, 0.95, 1.30, 1.75, 2.25], keyMuscle: 'glutes' },
  'calf_raise':      { multipliers: [0.50, 0.75, 1.00, 1.40, 1.85], keyMuscle: 'calves' },
  'plank_equivalent': { multipliers: null, keyMuscle: 'core' },
};

const MUSCLE_KEY_LIFTS = {
  chest:      { standard: 'bench_press',    patterns: [/bench press/i] },
  back:       { standard: 'deadlift',       patterns: [/deadlift/i, /barbell row/i, /bent over row/i] },
  shoulders:  { standard: 'overhead_press', patterns: [/overhead press/i, /shoulder press/i, /military press/i] },
  quads:      { standard: 'squat',          patterns: [/squat/i] },
  hamstrings: { standard: 'leg_curl',       patterns: [/leg curl/i, /romanian deadlift/i] },
  glutes:     { standard: 'hip_thrust',     patterns: [/hip thrust/i] },
  biceps:     { standard: 'barbell_curl',   patterns: [/barbell curl/i, /bicep curl/i] },
  triceps:    { standard: 'skull_crusher',  patterns: [/skullcrusher/i, /skull crusher/i, /tricep extension/i, /triceps extension/i, /triceps pushdown/i, /tricep pushdown/i] },
  calves:     { standard: 'calf_raise',     patterns: [/calf raise/i, /calf extension/i] },
  core:       { standard: 'plank_equivalent', patterns: [] },
  neck:       { standard: null, patterns: [] },
  forearms:   { standard: null, patterns: [] },
};

// ============================================================
// 1RM ESTIMATION (Pillar 3)
// ============================================================
function estimate1RM_Brzycki(weightLbs, reps) {
  if (reps <= 0) return 0;
  if (reps === 1) return weightLbs;
  if (reps >= 37) return weightLbs;
  return weightLbs * (36 / (37 - reps));
}

function estimate1RM_Epley(weightLbs, reps) {
  if (reps <= 0) return 0;
  if (reps === 1) return weightLbs;
  return weightLbs * (1 + reps / 30);
}

function estimate1RM(weightLbs, reps) {
  if (reps <= 10) return estimate1RM_Brzycki(weightLbs, reps);
  return estimate1RM_Epley(weightLbs, reps);
}

// ============================================================
// PERCENTILE ESTIMATION
// ============================================================
function estimatePercentile(standardKey, bwMultiplier) {
  const std = STRENGTH_STANDARDS[standardKey];
  if (!std || !std.multipliers) return null;
  const m = std.multipliers;
  const pctiles = [10, 25, 50, 75, 90];

  if (bwMultiplier <= m[0]) return Math.round((bwMultiplier / m[0]) * 10);
  if (bwMultiplier >= m[4]) return Math.min(99, 90 + Math.round(((bwMultiplier - m[4]) / (m[4] * 0.2)) * 9));

  for (let i = 0; i < m.length - 1; i++) {
    if (bwMultiplier >= m[i] && bwMultiplier <= m[i + 1]) {
      const frac = (bwMultiplier - m[i]) / (m[i + 1] - m[i]);
      return Math.round(pctiles[i] + frac * (pctiles[i + 1] - pctiles[i]));
    }
  }
  return 50;
}

// ============================================================
// TIME ESTIMATION
// ============================================================
const TIME_CONSTANTS = {
  compoundSetSec: 45,
  isolationSetSec: 35,
  restBetweenSets: 120,
  transitionSec: 90,
  sessionCapMin: 60,
};

function calculateExerciseTime(exerciseName, sets) {
  const db = EXERCISE_DB[exerciseName];
  const isCompound = db && db.type === 'compound';
  const setTime = isCompound ? TIME_CONSTANTS.compoundSetSec : TIME_CONSTANTS.isolationSetSec;
  return (sets * setTime) + ((sets - 1) * TIME_CONSTANTS.restBetweenSets) + TIME_CONSTANTS.transitionSec;
}

// ============================================================
// SHARED HELPERS (v1.1 - Task 4)
// ============================================================

// Consistent working-set extraction used everywhere
function getWorkingSets(exercise) {
  return (exercise.sets || []).filter(s =>
    s.set_type === 'normal' || !s.set_type
  );
}

// Normalize exercise name for caching/matching
function normalizeExerciseName(name) {
  return (name || '').trim().toLowerCase().replace(/\s+/g, ' ').replace(/[\u2018\u2019\u2032]/g, "'");
}

// Format set counts: show decimals only when fractional
function formatSets(n) {
  return Number.isInteger(n) ? String(n) : n.toFixed(1);
}

// Classification cache keyed by template_id or normalized name
const _classifyCache = new Map();

function classifyExerciseCached(exercise) {
  const key = exercise.exercise_template_id || normalizeExerciseName(exercise.title || '');
  if (_classifyCache.has(key)) return _classifyCache.get(key);
  const result = classifyExercise(exercise.title || '');
  _classifyCache.set(key, result);
  return result;
}

// ============================================================
// EXERCISE -> MUSCLE GROUP MAPPING
// v1.1 Task 5: Specific patterns FIRST to beat generic matches
// ============================================================
const EXERCISE_MUSCLE_MAP = [
  // --- SPECIFIC patterns first (Task 5: priority fix) ---
  // These must come before generic patterns like /row/i, /squat/i, /deadlift/i

  // Specific row variants -> shoulders/back (before generic /row/i)
  { pattern: /upright row/i, primary: 'shoulders', secondary: ['back'] },
  { pattern: /face pull/i, primary: 'back', secondary: ['shoulders'] },

  // Specific squat variants (before generic /squat/i)
  { pattern: /goblet squat/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /front squat/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /hack squat/i, primary: 'quads', secondary: ['glutes'] },

  // Specific deadlift variants (before generic /deadlift/i)
  { pattern: /romanian deadlift/i, primary: 'hamstrings', secondary: ['glutes', 'back'] },
  { pattern: /stiff.?leg/i, primary: 'hamstrings', secondary: ['glutes', 'back'] },

  // Specific bench variants (before generic)
  { pattern: /close.?grip.*bench/i, primary: 'triceps', secondary: ['chest'] },

  // Specific dip (chest vs tricep) — "Tricep Dip" must match before generic /dip/i
  { pattern: /tricep[s]?\s*dip/i, primary: 'triceps', secondary: ['chest', 'shoulders'] },
  { pattern: /chest dip/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },

  // Chest
  { pattern: /bench press/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /chest press/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /chest fly/i, primary: 'chest', secondary: [] },
  { pattern: /cable fly/i, primary: 'chest', secondary: [] },
  { pattern: /push.?up/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /pec.?deck/i, primary: 'chest', secondary: [] },
  { pattern: /dip/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },

  // Back
  { pattern: /deadlift/i, primary: 'back', secondary: ['hamstrings', 'glutes'] },
  { pattern: /pull.?up/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /chin.?up/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /lat.?pull/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /rack pull/i, primary: 'back', secondary: ['hamstrings'] },
  { pattern: /back extension/i, primary: 'back', secondary: ['glutes'] },
  { pattern: /good morning/i, primary: 'back', secondary: ['hamstrings', 'glutes'] },
  { pattern: /shrug/i, primary: 'back', secondary: ['neck'] },
  { pattern: /row/i, primary: 'back', secondary: ['biceps'] },

  // Shoulders
  { pattern: /overhead press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /shoulder press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /military press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /arnold press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /lateral raise/i, primary: 'shoulders', secondary: [] },
  { pattern: /front raise/i, primary: 'shoulders', secondary: [] },
  { pattern: /rear delt/i, primary: 'shoulders', secondary: [] },
  { pattern: /pike push/i, primary: 'shoulders', secondary: ['triceps'] },

  // Biceps
  { pattern: /bicep curl/i, primary: 'biceps', secondary: [] },
  { pattern: /hammer curl/i, primary: 'biceps', secondary: [] },
  { pattern: /concentration curl/i, primary: 'biceps', secondary: [] },
  { pattern: /preacher curl/i, primary: 'biceps', secondary: [] },
  { pattern: /barbell curl/i, primary: 'biceps', secondary: [] },
  { pattern: /kettlebell curl/i, primary: 'biceps', secondary: [] },

  // Triceps
  { pattern: /tricep/i, primary: 'triceps', secondary: [] },
  { pattern: /skull.?crush/i, primary: 'triceps', secondary: [] },

  // Quads
  { pattern: /squat/i, primary: 'quads', secondary: ['glutes', 'hamstrings'] },
  { pattern: /leg press/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /leg extension/i, primary: 'quads', secondary: [] },
  { pattern: /lunge/i, primary: 'quads', secondary: ['glutes', 'hamstrings'] },
  { pattern: /step.?up/i, primary: 'quads', secondary: ['glutes'] },

  // Hamstrings
  { pattern: /leg curl/i, primary: 'hamstrings', secondary: [] },
  { pattern: /nordic curl/i, primary: 'hamstrings', secondary: [] },

  // Glutes
  { pattern: /hip thrust/i, primary: 'glutes', secondary: ['hamstrings'] },
  { pattern: /glute/i, primary: 'glutes', secondary: [] },
  { pattern: /hip abduction/i, primary: 'glutes', secondary: [] },
  { pattern: /hip adduction/i, primary: 'glutes', secondary: [] },

  // Calves
  { pattern: /calf/i, primary: 'calves', secondary: [] },

  // Core
  { pattern: /crunch/i, primary: 'core', secondary: [] },
  { pattern: /sit.?up/i, primary: 'core', secondary: [] },
  { pattern: /plank/i, primary: 'core', secondary: [] },
  { pattern: /leg raise/i, primary: 'core', secondary: [] },
  { pattern: /knee raise/i, primary: 'core', secondary: [] },
  { pattern: /hanging/i, primary: 'core', secondary: [] },
  { pattern: /\bab\b/i, primary: 'core', secondary: [] },
  { pattern: /russian twist/i, primary: 'core', secondary: [] },
  { pattern: /woodchop/i, primary: 'core', secondary: [] },

  // Neck
  { pattern: /neck curl/i, primary: 'neck', secondary: [] },
  { pattern: /neck extension/i, primary: 'neck', secondary: [] },
  { pattern: /neck flexion/i, primary: 'neck', secondary: [] },
  { pattern: /neck lateral/i, primary: 'neck', secondary: [] },
  { pattern: /neck harness/i, primary: 'neck', secondary: [] },
  { pattern: /iron neck/i, primary: 'neck', secondary: [] },

  // Forearms
  { pattern: /wrist curl/i, primary: 'forearms', secondary: [] },
  { pattern: /reverse curl/i, primary: 'forearms', secondary: ['biceps'] },
  { pattern: /wrist extension/i, primary: 'forearms', secondary: [] },
  { pattern: /wrist roller/i, primary: 'forearms', secondary: [] },
  { pattern: /farmer.?carry/i, primary: 'forearms', secondary: ['back'] },
  { pattern: /farmer.?walk/i, primary: 'forearms', secondary: ['back'] },
  { pattern: /grip.?train/i, primary: 'forearms', secondary: [] },
  { pattern: /dead hang/i, primary: 'forearms', secondary: ['back'] },
  { pattern: /plate pinch/i, primary: 'forearms', secondary: [] },
];

const CARDIO_PATTERNS = [
  /treadmill/i, /elliptical/i, /\bbike\b/i, /cycling/i, /rowing machine/i,
  /jump rope/i, /jumping jack/i, /burpee/i, /stair/i, /running/i, /walking/i,
];

function classifyExercise(name) {
  for (const c of CARDIO_PATTERNS) {
    if (c.test(name)) return { primary: 'cardio', secondary: [] };
  }
  for (const m of EXERCISE_MUSCLE_MAP) {
    if (m.pattern.test(name)) return { primary: m.primary, secondary: m.secondary };
  }
  return { primary: 'other', secondary: [] };
}

// ============================================================
// MUSCLE GROUP METADATA (Pillar 1)
// ============================================================
const MUSCLE_GROUPS = {
  chest:      { name: 'Chest',      idealFreqDays: 4, color: '#f87171', idealSetsPerWeek: 14 },
  back:       { name: 'Back',       idealFreqDays: 4, color: '#60a5fa', idealSetsPerWeek: 16 },
  shoulders:  { name: 'Shoulders',  idealFreqDays: 4, color: '#c084fc', idealSetsPerWeek: 14 },
  biceps:     { name: 'Biceps',     idealFreqDays: 5, color: '#34d399', idealSetsPerWeek: 10 },
  triceps:    { name: 'Triceps',    idealFreqDays: 5, color: '#fbbf24', idealSetsPerWeek: 10 },
  quads:      { name: 'Quads',      idealFreqDays: 4, color: '#fb923c', idealSetsPerWeek: 14 },
  hamstrings: { name: 'Hamstrings', idealFreqDays: 5, color: '#f472b6', idealSetsPerWeek: 12 },
  glutes:     { name: 'Glutes',     idealFreqDays: 5, color: '#a78bfa', idealSetsPerWeek: 12 },
  calves:     { name: 'Calves',     idealFreqDays: 5, color: '#2dd4bf', idealSetsPerWeek: 10 },
  core:       { name: 'Core',       idealFreqDays: 3, color: '#e879f9', idealSetsPerWeek: 10 },
  neck:       { name: 'Neck',       idealFreqDays: 3, color: '#f59e0b', idealSetsPerWeek: 8 },
  forearms:   { name: 'Forearms',   idealFreqDays: 3, color: '#06b6d4', idealSetsPerWeek: 8 },
};

// ============================================================
// EXERCISE DATABASE
// ============================================================
const EXERCISE_DB = {
  'Bench Press (Barbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 185, sets: 4, reps: '6-8' },
  'Incline Bench Press (Dumbbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 60, sets: 3, reps: '8-10', note: 'per hand' },
  'Incline Bench Press (Barbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 155, sets: 4, reps: '6-8' },
  'Chest Fly (Machine)': { muscle: 'chest', type: 'isolation', benchmarkLbs: 140, sets: 3, reps: '10-12' },
  'Chest Fly (Dumbbell)': { muscle: 'chest', type: 'isolation', benchmarkLbs: 40, sets: 3, reps: '10-12', note: 'per hand' },
  'Chest Dip': { muscle: 'chest', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '8-12', note: 'bodyweight' },
  'Cable Fly Crossovers': { muscle: 'chest', type: 'isolation', benchmarkLbs: 30, sets: 3, reps: '12-15', note: 'per side' },
  'Chest Press (Machine)': { muscle: 'chest', type: 'compound', benchmarkLbs: 160, sets: 3, reps: '8-10' },
  'Decline Bench Press (Barbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 195, sets: 3, reps: '6-8' },

  'Bent Over Row (Barbell)': { muscle: 'back', type: 'compound', benchmarkLbs: 165, sets: 4, reps: '6-8' },
  'Pull Up': { muscle: 'back', type: 'compound', benchmarkLbs: 0, sets: 4, reps: '6-10', note: 'bodyweight' },
  'Chin Up': { muscle: 'back', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '6-10', note: 'bodyweight' },
  'Lat Pulldown (Cable)': { muscle: 'back', type: 'compound', benchmarkLbs: 140, sets: 3, reps: '8-10' },
  'Lat Pulldown (Machine)': { muscle: 'back', type: 'compound', benchmarkLbs: 140, sets: 3, reps: '8-10' },
  'Seated Row (Machine)': { muscle: 'back', type: 'compound', benchmarkLbs: 140, sets: 3, reps: '8-10' },
  'Dumbbell Row': { muscle: 'back', type: 'compound', benchmarkLbs: 65, sets: 3, reps: '8-10', note: 'per hand' },
  'Deadlift (Barbell)': { muscle: 'back', type: 'compound', benchmarkLbs: 275, sets: 3, reps: '5-6' },
  'Pendlay Row (Barbell)': { muscle: 'back', type: 'compound', benchmarkLbs: 155, sets: 4, reps: '5-8' },

  'Overhead Press (Barbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 115, sets: 4, reps: '6-8' },
  'Overhead Press (Dumbbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 45, sets: 3, reps: '8-10', note: 'per hand' },
  'Lateral Raise (Dumbbell)': { muscle: 'shoulders', type: 'isolation', benchmarkLbs: 20, sets: 4, reps: '12-15', note: 'per hand' },
  'Lateral Raise (Machine)': { muscle: 'shoulders', type: 'isolation', benchmarkLbs: 80, sets: 3, reps: '12-15' },
  'Arnold Press (Dumbbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 40, sets: 3, reps: '8-10', note: 'per hand' },
  'Seated Shoulder Press (Machine)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 120, sets: 3, reps: '8-10' },
  'Shoulder Press (Dumbbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 45, sets: 3, reps: '8-10', note: 'per hand' },
  'Standing Military Press (Barbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 115, sets: 4, reps: '6-8' },

  'Bicep Curl (Barbell)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 75, sets: 3, reps: '8-10' },
  'Bicep Curl (Dumbbell)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 30, sets: 3, reps: '10-12', note: 'per hand' },
  'Hammer Curl (Dumbbell)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '10-12', note: 'per hand' },
  'Hammer Curl (Cable)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '10-12', note: 'per side' },
  'Concentration Curl': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '10-12', note: 'per hand' },

  'Triceps Pushdown': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 60, sets: 3, reps: '10-12' },
  'Triceps Rope Pushdown': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 55, sets: 3, reps: '10-12' },
  'Triceps Extension (Cable)': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 50, sets: 3, reps: '10-12' },
  'Triceps Extension (Dumbbell)': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 30, sets: 3, reps: '10-12' },
  'Skullcrusher (Dumbbell)': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '10-12', note: 'per hand' },
  'Triceps Dip': { muscle: 'triceps', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '8-12', note: 'bodyweight' },

  'Squat (Barbell)': { muscle: 'quads', type: 'compound', benchmarkLbs: 225, sets: 4, reps: '5-8' },
  'Squat (Bodyweight)': { muscle: 'quads', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight' },
  'Leg Press (Machine)': { muscle: 'quads', type: 'compound', benchmarkLbs: 360, sets: 4, reps: '8-10' },
  'Front Squat': { muscle: 'quads', type: 'compound', benchmarkLbs: 175, sets: 3, reps: '6-8' },
  'Goblet Squat': { muscle: 'quads', type: 'compound', benchmarkLbs: 60, sets: 3, reps: '10-12' },
  'Lunge (Dumbbell)': { muscle: 'quads', type: 'compound', benchmarkLbs: 40, sets: 3, reps: '10-12', note: 'per hand' },
  'Lunge': { muscle: 'quads', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },

  'Romanian Deadlift (Barbell)': { muscle: 'hamstrings', type: 'compound', benchmarkLbs: 205, sets: 4, reps: '8-10' },
  'Romanian Deadlift (Dumbbell)': { muscle: 'hamstrings', type: 'compound', benchmarkLbs: 55, sets: 3, reps: '8-10', note: 'per hand' },
  'Seated Leg Curl (Machine)': { muscle: 'hamstrings', type: 'isolation', benchmarkLbs: 110, sets: 3, reps: '10-12' },

  'Hip Thrust (Barbell)': { muscle: 'glutes', type: 'compound', benchmarkLbs: 225, sets: 4, reps: '8-10' },
  'Hip Thrust (Machine)': { muscle: 'glutes', type: 'compound', benchmarkLbs: 225, sets: 3, reps: '8-10' },
  'Hip Thrust': { muscle: 'glutes', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
  'Glute Kickback (Machine)': { muscle: 'glutes', type: 'isolation', benchmarkLbs: 80, sets: 3, reps: '12-15' },
  'Hip Abduction (Machine)': { muscle: 'glutes', type: 'isolation', benchmarkLbs: 120, sets: 3, reps: '12-15' },
  'Hip Adduction (Machine)': { muscle: 'glutes', type: 'isolation', benchmarkLbs: 120, sets: 3, reps: '12-15' },

  'Standing Calf Raise': { muscle: 'calves', type: 'isolation', benchmarkLbs: 180, sets: 4, reps: '12-15' },
  'Seated Calf Raise': { muscle: 'calves', type: 'isolation', benchmarkLbs: 90, sets: 3, reps: '12-15' },
  'Calf Extension (Machine)': { muscle: 'calves', type: 'isolation', benchmarkLbs: 140, sets: 3, reps: '12-15' },

  'Hanging Leg Raise': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '10-15', note: 'bodyweight' },
  'Hanging Knee Raise': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
  'Crunch': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight' },
  'Crunch (Machine)': { muscle: 'core', type: 'isolation', benchmarkLbs: 80, sets: 3, reps: '12-15' },
  'Decline Crunch': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
  'Plank': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '45-60s', note: 'hold' },
  'Sit Up': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight' },
  'Leg Raise Parallel Bars': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '10-15', note: 'bodyweight' },
  'Knee Raise Parallel Bars': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },

  // Neck
  'Neck Curl (Plate)': { muscle: 'neck', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '15-20' },
  'Neck Extension (Plate)': { muscle: 'neck', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '15-20' },
  'Neck Curl (Harness)': { muscle: 'neck', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '12-15' },
  'Neck Extension (Harness)': { muscle: 'neck', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '12-15' },
  'Neck Lateral Flexion': { muscle: 'neck', type: 'isolation', benchmarkLbs: 15, sets: 2, reps: '12-15', note: 'per side' },

  // Forearms
  'Wrist Curl (Barbell)': { muscle: 'forearms', type: 'isolation', benchmarkLbs: 60, sets: 3, reps: '15-20' },
  'Wrist Curl (Dumbbell)': { muscle: 'forearms', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '15-20', note: 'per hand' },
  'Reverse Wrist Curl (Barbell)': { muscle: 'forearms', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '12-15' },
  'Reverse Curl (Barbell)': { muscle: 'forearms', type: 'isolation', benchmarkLbs: 50, sets: 3, reps: '10-12' },
  'Reverse Curl (Dumbbell)': { muscle: 'forearms', type: 'isolation', benchmarkLbs: 20, sets: 3, reps: '10-12', note: 'per hand' },
  'Farmer Carry (Dumbbell)': { muscle: 'forearms', type: 'compound', benchmarkLbs: 60, sets: 3, reps: '40-60s', note: 'per hand' },
  'Dead Hang': { muscle: 'forearms', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '30-60s', note: 'bodyweight' },
};

const MUSCLE_EXERCISE_PICKS = {
  chest:      ['Bench Press (Barbell)', 'Incline Bench Press (Dumbbell)', 'Chest Fly (Machine)', 'Cable Fly Crossovers'],
  back:       ['Bent Over Row (Barbell)', 'Pull Up', 'Lat Pulldown (Cable)', 'Seated Row (Machine)'],
  shoulders:  ['Overhead Press (Barbell)', 'Lateral Raise (Dumbbell)', 'Arnold Press (Dumbbell)', 'Lateral Raise (Machine)'],
  biceps:     ['Bicep Curl (Barbell)', 'Hammer Curl (Dumbbell)', 'Concentration Curl'],
  triceps:    ['Triceps Pushdown', 'Triceps Extension (Cable)', 'Skullcrusher (Dumbbell)'],
  quads:      ['Squat (Barbell)', 'Leg Press (Machine)', 'Front Squat', 'Lunge (Dumbbell)'],
  hamstrings: ['Romanian Deadlift (Barbell)', 'Seated Leg Curl (Machine)'],
  glutes:     ['Hip Thrust (Barbell)', 'Glute Kickback (Machine)', 'Hip Abduction (Machine)'],
  calves:     ['Standing Calf Raise', 'Seated Calf Raise'],
  core:       ['Hanging Leg Raise', 'Crunch (Machine)', 'Plank'],
  neck:       ['Neck Curl (Plate)', 'Neck Extension (Plate)', 'Neck Lateral Flexion'],
  forearms:   ['Wrist Curl (Barbell)', 'Reverse Curl (Barbell)', 'Farmer Carry (Dumbbell)'],
};

// ============================================================
// BODY WEIGHT DATA - Baseline from Strong CSV export
// ============================================================
const WEIGHT_DATA_BASELINE = [
  { date: '2026-01-18', value: 166.0 },
  { date: '2026-01-17', value: 164.4 },
  { date: '2025-11-30', value: 168.0 },
  { date: '2025-11-04', value: 167.1 },
  { date: '2025-11-01', value: 168.2 },
  { date: '2025-10-01', value: 169.0 },
  { date: '2025-09-12', value: 169.0 },
  { date: '2025-09-07', value: 168.0 },
  { date: '2025-07-15', value: 172.0 },
  { date: '2025-05-23', value: 174.2 },
  { date: '2025-05-15', value: 172.0 },
  { date: '2025-04-30', value: 173.0 },
];

// ============================================================
// WEIGHT localStorage FUNCTIONS
// ============================================================
function getStoredWeightEntries() {
  try {
    const raw = localStorage.getItem('weightHistory');
    if (!raw) return [];
    return JSON.parse(raw);
  } catch (e) {
    return [];
  }
}

function saveWeightEntry(date, value) {
  const entries = getStoredWeightEntries();
  entries.push({ date, value });
  localStorage.setItem('weightHistory', JSON.stringify(entries));
}

function getMergedWeightData() {
  const stored = getStoredWeightEntries();
  const all = [...WEIGHT_DATA_BASELINE, ...stored];
  const byDate = {};
  for (const entry of all) {
    byDate[entry.date] = entry.value;
  }
  return Object.entries(byDate)
    .map(([date, value]) => ({ date, value }))
    .sort((a, b) => b.date.localeCompare(a.date));
}

// ============================================================
// BODY MEASUREMENTS SYSTEM (v1.7 â€” Phases 2-4)
// ============================================================
// SCIENTIFIC FOUNDATION
// Pillar 6: Anthropometric Proportions
// Source: McRobert (2005) "Build Muscle, Lose Fat, Look Great" â€” ideal
//   proportional targets for natural lifters based on wrist/ankle bone structure
// Source: Butt (2010) "Your Muscular Potential" â€” circumference-based
//   proportions correlated with lean mass development
// Source: Katch & McArdle (1983) â€” limb girth norms for athletic males
//
// Target ratio philosophy:
// - Neck â‰ˆ Calf circumference (classic proportion)
// - Forearm â‰ˆ 0.80Ã— Bicep circumference (flexed)
// - Waist < 0.45Ã— Height (health marker â€” WHO guideline)
// - Chest circumference tracked for development trend

const MEASUREMENTS_KEY = 'bodyMeasurements_v1';

// All supported measurement fields
const MEASUREMENT_FIELDS = [
  { key: 'neck_in',    label: 'Neck',     unit: 'in', placeholder: '15.5' },
  { key: 'forearm_in', label: 'Forearm',  unit: 'in', placeholder: '12.0' },
  { key: 'bicep_in',   label: 'Bicep',    unit: 'in', placeholder: '14.5' },
  { key: 'chest_in',   label: 'Chest',    unit: 'in', placeholder: '40.0' },
  { key: 'waist_in',   label: 'Waist',    unit: 'in', placeholder: '32.0' },
  { key: 'calf_in',    label: 'Calf',     unit: 'in', placeholder: '15.0' },
];

// ---- Phase 3+4: Proportion targets mapping measurements â†’ muscle priority ----
// Each rule: if measurement ratio deviates from target, boost that muscle's score
// deficit > 0 means the muscle needs MORE work
const PROPORTION_RULES = [
  {
    // Neck should â‰ˆ calf circumference
    muscle: 'neck',
    requires: ['neck_in', 'calf_in'],
    targetRatio: 1.0, // neck / calf
    compute: (m) => m.neck_in / m.calf_in,
    label: 'Neck Ã· Calf',
  },
  {
    // Forearm should be â‰ˆ 80% of bicep
    muscle: 'forearms',
    requires: ['forearm_in', 'bicep_in'],
    targetRatio: 0.80,
    compute: (m) => m.forearm_in / m.bicep_in,
    label: 'Forearm Ã· Bicep',
  },
  {
    // Bicep growth tracking â€” compare to wrist-based genetic potential
    // Simplified: bicep should be â‰ˆ 2.5Ã— wrist, but we don't have wrist.
    // Instead use bicep Ã· forearm â€” target 1.25 (inverse of forearm rule)
    muscle: 'biceps',
    requires: ['bicep_in', 'forearm_in'],
    targetRatio: 1.25,
    compute: (m) => m.bicep_in / m.forearm_in,
    label: 'Bicep Ã· Forearm',
  },
  {
    // Waist health â€” smaller is better; deficit if waist is too large
    // WHO: waist < 0.45 Ã— height. For 5'10 (70"), target < 31.5"
    // We use a fixed target since we have height in profile
    muscle: 'core',
    requires: ['waist_in'],
    targetRatio: null, // absolute target, not a ratio
    compute: (m) => {
      const heightIn = PROFILE.heightIn || 70; // fallback if missing
      const targetMax = heightIn * 0.45;
      // Return a "score" where < 1.0 means good, > 1.0 means over target
      return m.waist_in / targetMax;
    },
    label: 'Waist Ã· Target',
  },
  {
    // Calf should â‰ˆ neck circumference
    muscle: 'calves',
    requires: ['calf_in', 'neck_in'],
    targetRatio: 1.0,
    compute: (m) => m.calf_in / m.neck_in,
    label: 'Calf Ã· Neck',
  },
  {
    // Chest development â€” tracked as trend; compare to waist for V-taper
    // Target chest:waist ratio â‰ˆ 1.3 for aesthetic V-taper
    muscle: 'chest',
    requires: ['chest_in', 'waist_in'],
    targetRatio: 1.30,
    compute: (m) => m.chest_in / m.waist_in,
    label: 'Chest Ã· Waist',
  },
];

function getStoredMeasurements() {
  try {
    const raw = localStorage.getItem(MEASUREMENTS_KEY);
    if (!raw) return [];
    return JSON.parse(raw);
  } catch (e) { return []; }
}

function saveMeasurementEntry(entry) {
  const entries = getStoredMeasurements();
  entries.push(entry);
  localStorage.setItem(MEASUREMENTS_KEY, JSON.stringify(entries));
}

function getLatestMeasurements() {
  const entries = getStoredMeasurements();
  if (entries.length === 0) return null;
  // Merge all entries â€” latest value per field wins
  const latest = {};
  const dates = {};
  // Sort chronologically so later entries overwrite
  const sorted = [...entries].sort((a, b) => (a.date || '').localeCompare(b.date || ''));
  for (const entry of sorted) {
    for (const field of MEASUREMENT_FIELDS) {
      if (entry[field.key] != null && entry[field.key] !== '' && !isNaN(entry[field.key])) {
        latest[field.key] = parseFloat(entry[field.key]);
        dates[field.key] = entry.date;
      }
    }
  }
  if (Object.keys(latest).length === 0) return null;
  latest._dates = dates;
  return latest;
}

// ---- Phase 3: Compute proportion deficit scores ----
function computeProportionDeficits(measurements) {
  if (!measurements) return {};
  const deficits = {};

  for (const rule of PROPORTION_RULES) {
    const hasDeps = rule.requires.every(k => measurements[k] != null && measurements[k] > 0);
    if (!hasDeps) continue;

    const actual = rule.compute(measurements);
    const target = rule.targetRatio || 1.0;

    // deficit: how far below target. 0 = on target, positive = needs work
    // For waist/core, logic is inverted: higher actual = worse
    if (rule.muscle === 'core') {
      // Over target = deficit for core (waist too big)
      deficits[rule.muscle] = Math.max(0, actual - 1.0);
    } else {
      // Under target = deficit
      deficits[rule.muscle] = Math.max(0, 1 - (actual / target));
    }
  }
  return deficits;
}

// Global state for proportion data
let latestMeasurements = null;
let proportionDeficits = {};

// ============================================================
// STATE
// ============================================================
const apiKey = 'e38cf123-61c4-4b8c-ae25-7442d6d9c874';
let workoutCache = null;
let muscleAnalysis = null;
let exerciseHistory = {};
let muscle1RMs = {};
let strengthIndexData = [];
let WEIGHT_DATA = [];
let LAST_RECS = null;
let healthData = null;
let healthStatus = 'pending'; // 'ok' | 'stale' | 'missing' | 'pending'
let hevyStatus = 'pending'; // 'ok' | 'error'

// ============================================================
// SESSION PREFS (Constraints Knob)
// ============================================================
const PREFS_KEY = 'wa_prefs_v1_1';
const PREFS_DEFAULTS = {
  sessionCapMin: 60,
  equipment: 'gym',
  avoidOHP: false,
  strictness: 'balanced',
};

function loadPrefs() {
  try {
    const raw = localStorage.getItem(PREFS_KEY);
    if (!raw) return { ...PREFS_DEFAULTS };
    return { ...PREFS_DEFAULTS, ...JSON.parse(raw) };
  } catch (e) { return { ...PREFS_DEFAULTS }; }
}

function savePrefs(prefs) {
  localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
}

let sessionPrefs = loadPrefs();

const GYM_ONLY_REGEX = /(Machine|Cable|Smith|Leg Press|Hack Squat|Pec Deck)/i;

// Chip definitions
const CHIP_DEFS = [
  { key: 'sessionCapMin', label: v => `${v}m`, values: [30, 45, 60] },
  { key: 'equipment', label: v => v === 'gym' ? 'Gym' : 'Home', values: ['gym', 'home'] },
  { key: 'avoidOHP', label: v => v ? 'No OHP' : 'OHP OK', values: [false, true] },
  { key: 'strictness', label: v => v.charAt(0).toUpperCase() + v.slice(1), values: ['loose', 'balanced', 'strict'] },
];

function renderConstraintChips() {
  const row = document.getElementById('constraints-row');
  if (!row) return;
  row.innerHTML = CHIP_DEFS.map(def => {
    const current = sessionPrefs[def.key];
    const isNonDefault = current !== PREFS_DEFAULTS[def.key];
    const chipStyle = isNonDefault
      ? 'background:rgba(74,222,128,0.12);color:#4ade80;border:1px solid rgba(74,222,128,0.3);padding:5px 10px;font-size:12px;font-weight:500;font-family:Space Grotesk,sans-serif;border-radius:6px;cursor:pointer;user-select:none;'
      : 'background:#1a1a1e;color:#8e8e98;border:1px solid #2a2a2e;padding:5px 10px;font-size:12px;font-weight:500;font-family:Space Grotesk,sans-serif;border-radius:6px;cursor:pointer;user-select:none;';
    return `<div class="constraint-chip${isNonDefault ? ' active' : ''}" style="${chipStyle}" data-key="${def.key}" onclick="cycleChip('${def.key}')">${def.label(current)}</div>`;
  }).join('');
}

function cycleChip(key) {
  const def = CHIP_DEFS.find(d => d.key === key);
  if (!def) return;
  const current = sessionPrefs[key];
  const idx = def.values.indexOf(current);
  const next = def.values[(idx + 1) % def.values.length];
  sessionPrefs[key] = next;
  savePrefs(sessionPrefs);
  renderConstraintChips();
  if (LAST_RECS) renderTimedSession(LAST_RECS);
}

// ============================================================
// API + CACHING (v1.1 Task 7)
// ============================================================
const API_BASE = 'https://api.hevyapp.com/v1';
const CACHE_KEY = 'workoutCache_v1';
const CACHE_STALE_MS = 8 * 60 * 60 * 1000; // 8 hours

function getCachedWorkouts() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed.ts || !parsed.data) return null;
    return parsed;
  } catch (e) { return null; }
}

function setCachedWorkouts(workouts) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), data: workouts }));
  } catch (e) { /* storage full - ignore */ }
}

function isCacheStale(cached) {
  return !cached || (Date.now() - cached.ts) > CACHE_STALE_MS;
}

async function fetchWorkouts(pageSize = 10, maxPages = 10) {
  const allWorkouts = [];
  let page = 1;
  let totalPages = 1;

  while (page <= totalPages && page <= maxPages) {
    updateLoading(`Loading workouts (${allWorkouts.length})...`);
    const resp = await fetch(`${API_BASE}/workouts?page=${page}&pageSize=${pageSize}`, {
      headers: { 'api-key': apiKey }
    });
    if (!resp.ok) throw new Error(`API error ${resp.status}: ${resp.statusText}`);
    const data = await resp.json();
    totalPages = data.page_count || 1;
    if (data.workouts) allWorkouts.push(...data.workouts);
    page++;
  }
  return allWorkouts;
}

// ============================================================
// UNIFIED PREPROCESS PIPELINE (v1.1 Task 6)
// Single pass over workouts producing all downstream data
// ============================================================
function preprocessWorkouts(workouts, bodyweightLbs) {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  // Sort oldest -> newest for history building
  const sorted = [...workouts].sort((a, b) =>
    new Date(a.start_time || a.created_at) - new Date(b.start_time || b.created_at)
  );

  // ---- Output structures ----
  const exHistory = {};
  const muscleStats = {};
  const muscle1RMInputs = {}; // { muscleKey: { best1RM, exercise } }
  const siRolling1RMs = { bench: 0, squat: 0, deadlift: 0, ohp: 0, row: 0 };
  const siTimeline = [];
  const heatmapDayMuscle = {};
  const heatmapDayWorkouts = {};

  // Init muscle stats
  for (const [key, meta] of Object.entries(MUSCLE_GROUPS)) {
    muscleStats[key] = {
      key, name: meta.name, color: meta.color,
      idealFreqDays: meta.idealFreqDays, idealSetsPerWeek: meta.idealSetsPerWeek,
      lastTrainedPrimary: null, daysSincePrimary: Infinity,
      lastTrainedAny: null, daysSinceAny: Infinity,
      totalSets30d: 0, totalVolume30d: 0, sessionCount30d: 0, exercises: new Set(),
    };
    muscle1RMInputs[key] = { best1RM: 0, exercise: '' };
  }

  // Weight data sorted for SI interpolation
  const weightSorted = [...WEIGHT_DATA].sort((a, b) => a.date.localeCompare(b.date));
  function getBodyweightAt(dateStr) {
    let bw = bodyweightLbs;
    for (const w of weightSorted) {
      if (w.date <= dateStr) bw = w.value;
      else break;
    }
    return bw;
  }

  // ---- Single pass ----
  for (const w of sorted) {
    const wDate = new Date(w.start_time || w.created_at);
    const dateStr = wDate.toISOString().split('T')[0];
    const isRecent = wDate >= thirtyDaysAgo;
    const musclesThisWorkout = new Set();
    let siUpdated = false;

    if (!heatmapDayMuscle[dateStr]) heatmapDayMuscle[dateStr] = {};
    if (!heatmapDayWorkouts[dateStr]) heatmapDayWorkouts[dateStr] = [];

    for (const ex of (w.exercises || [])) {
      const name = ex.title || '';
      if (!name) continue;

      const classification = classifyExerciseCached(ex);
      const workingSets = getWorkingSets(ex);

      // --- Exercise history ---
      if (workingSets.length > 0) {
        let bestWeight = 0, bestReps = 0;
        for (const s of workingSets) {
          const wLbs = Math.round((s.weight_kg || 0) * 2.20462);
          if (wLbs > bestWeight) { bestWeight = wLbs; bestReps = s.reps || 0; }
        }
        if (!exHistory[name]) exHistory[name] = { weights: [], dates: [] };
        exHistory[name].lastWeightLbs = bestWeight;
        exHistory[name].lastReps = bestReps;
        exHistory[name].lastDate = wDate;
        exHistory[name].lastSets = workingSets.length;
        exHistory[name].weights.push(bestWeight);
        exHistory[name].dates.push(wDate);
      }

      if (classification.primary === 'cardio' || classification.primary === 'other') continue;

      const setCount = workingSets.length;
      const allMuscles = [classification.primary, ...classification.secondary];

      // --- Muscle stats (30d) ---
      for (const muscle of allMuscles) {
        if (!muscleStats[muscle]) continue;
        const stat = muscleStats[muscle];
        const isPrimary = muscle === classification.primary;

        // Track recency: primary vs any (secondary) separately
        // This prevents secondary stimulus (e.g. RDLs for back) from
        // resetting the "last trained" clock on back, which would
        // incorrectly suppress back recommendations.
        if (!stat.lastTrainedAny || wDate > stat.lastTrainedAny) {
          stat.lastTrainedAny = wDate;
          stat.daysSinceAny = Math.floor((now - wDate) / (1000 * 60 * 60 * 24));
        }
        if (isPrimary && (!stat.lastTrainedPrimary || wDate > stat.lastTrainedPrimary)) {
          stat.lastTrainedPrimary = wDate;
          stat.daysSincePrimary = Math.floor((now - wDate) / (1000 * 60 * 60 * 24));
        }

        if (isRecent) {
          const weight = isPrimary ? 1.0 : 0.5;
          stat.totalSets30d += setCount * weight;
          for (const s of workingSets) {
            stat.totalVolume30d += (s.reps || 0) * (s.weight_kg || 0) * weight;
          }
          stat.exercises.add(name);
          musclesThisWorkout.add(muscle);
        }
      }

      // --- Heatmap data ---
      for (const muscle of allMuscles) {
        if (!MUSCLE_GROUPS[muscle]) continue;
        const isPrimary = muscle === classification.primary;
        const weight = isPrimary ? 1.0 : 0.5;
        heatmapDayMuscle[dateStr][muscle] = (heatmapDayMuscle[dateStr][muscle] || 0) + setCount * weight;
      }

      // Heatmap detail
      const bestSet = workingSets.reduce((best, s) => {
        const wLbs = Math.round((s.weight_kg || 0) * 2.20462);
        return wLbs > (best.w || 0) ? { w: wLbs, r: s.reps || 0 } : best;
      }, {});
      heatmapDayWorkouts[dateStr].push({
        name, sets: setCount,
        bestWeight: bestSet.w || 0, bestReps: bestSet.r || 0,
      });

      // --- Muscle 1RM (last 30d) ---
      if (isRecent) {
        for (const [muscleKey, keyLift] of Object.entries(MUSCLE_KEY_LIFTS)) {
          const matched = keyLift.patterns.some(p => p.test(name));
          if (!matched) continue;
          for (const s of workingSets) {
            const wLbs = (s.weight_kg || 0) * 2.20462;
            const reps = s.reps || 0;
            if (wLbs <= 0 || reps <= 0) continue;
            const est = estimate1RM(wLbs, reps);
            if (est > muscle1RMInputs[muscleKey].best1RM) {
              muscle1RMInputs[muscleKey].best1RM = est;
              muscle1RMInputs[muscleKey].exercise = name;
            }
          }
        }
      }

      // --- Strength index timeline ---
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        const matched = liftDef.patterns.some(p => p.test(name));
        if (!matched) continue;
        for (const s of workingSets) {
          const wLbs = (s.weight_kg || 0) * 2.20462;
          const reps = s.reps || 0;
          if (wLbs <= 0 || reps <= 0) continue;
          const est = estimate1RM(wLbs, reps);
          if (est > siRolling1RMs[liftKey]) {
            siRolling1RMs[liftKey] = est;
            siUpdated = true;
          }
        }
      }
    }

    // Session count
    if (isRecent) {
      for (const m of musclesThisWorkout) {
        if (muscleStats[m]) muscleStats[m].sessionCount30d++;
      }
    }

    // Strength Score data point (normalized: 1.0 = 50th percentile for 36yo male)
    const hasData = Object.values(siRolling1RMs).some(v => v > 0);
    if (hasData) {
      const bw = getBodyweightAt(dateStr);
      const lifts = {};
      let totalWeight = 0;

      // First pass: identify which lifts have data and sum their weights
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        if (siRolling1RMs[liftKey] > 0) totalWeight += liftDef.weight;
      }

      // Second pass: compute normalized score with re-weighted lifts
      let index = 0;
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        const mult = bw > 0 ? siRolling1RMs[liftKey] / bw : 0;
        const normalized = liftDef.p50 > 0 ? mult / liftDef.p50 : 0;
        const adjustedWeight = totalWeight > 0 ? liftDef.weight / totalWeight : 0;
        if (siRolling1RMs[liftKey] > 0) {
          index += normalized * adjustedWeight;
        }
        lifts[liftKey] = { rm: Math.round(siRolling1RMs[liftKey]), mult: Math.round(mult * 100) / 100 };
      }
      siTimeline.push({ date: dateStr, index: Math.round(index * 100) / 100, lifts: { ...lifts } });
    }
  }

  // Finalize muscle 1RMs with percentiles
  const muscle1RMResults = {};
  for (const [key, data] of Object.entries(muscle1RMInputs)) {
    const keyLift = MUSCLE_KEY_LIFTS[key];
    const bwMult = bodyweightLbs > 0 ? data.best1RM / bodyweightLbs : 0;
    const percentile = estimatePercentile(keyLift.standard, bwMult);
    muscle1RMResults[key] = {
      best1RM: Math.round(data.best1RM),
      bwMult: Math.round(bwMult * 100) / 100,
      percentile, exercise: data.exercise,
    };
  }

  return {
    exerciseHistory: exHistory,
    muscleStats,
    muscle1RMs: muscle1RMResults,
    strengthIndexTimeline: siTimeline,
    heatmapDayMuscle,
    heatmapDayWorkouts,
  };
}

// ============================================================
// STRENGTH INDEX LIFT DEFINITIONS
// ============================================================
// p50 = 50th percentile BW multiplier, age-adjusted for 36yo male (~75kg class)
// Base values from van den Hoek et al. 2024 (26-35 bracket), reduced ~4% for 36-39 bracket
// Row p50 derived from approximate StrengthLevel data (same age adjustment applied)
const STRENGTH_INDEX_LIFTS = {
  bench:    { weight: 0.20, p50: 1.15, patterns: [/bench press.*barbell/i, /^bench press$/i] },
  squat:    { weight: 0.25, p50: 1.54, patterns: [/squat.*barbell/i, /^squat$/i, /barbell.*squat/i] },
  deadlift: { weight: 0.30, p50: 1.78, patterns: [/^deadlift/i, /deadlift.*barbell/i] },
  ohp:      { weight: 0.10, p50: 0.69, patterns: [/overhead press/i, /shoulder press/i, /military press/i] },
  row:      { weight: 0.15, p50: 0.86, patterns: [/barbell row/i, /bent over row/i, /pendlay row/i, /seated row/i, /cable row/i, /dumbbell row/i] },
};

// ============================================================
// CARDIOVASCULAR TRAINING ENGINE (Pillar 5)
// ============================================================
// SCIENTIFIC FOUNDATION
// Source 1: ACSM (2018) "Guidelines for Exercise Testing & Prescription" (11th ed)
//   - 150 min/week moderate OR 75 min/week vigorous, or equivalent combination
// Source 2: Seiler (2010) "What is Best Practice for Training Intensity and Duration
//   Distribution in Endurance Athletes?" - polarized 80/20 model
// Source 3: Tanaka et al. (2001) "Age-predicted maximal heart rate revisited"
//   - HRmax = 208 - 0.7 Ãƒâ€” age (more accurate than 220-age)
// Source 4: Karvonen (1957) "Heart Rate Reserve" method for HR zones
//   - Target HR = ((HRmax - HRrest) Ãƒâ€” %intensity) + HRrest
// Source 5: StÃƒÂ¶ggl & Sperlich (2014) "Polarized training has greater impact on key
//   endurance variables than threshold, high-intensity, or high-volume training"

// HR Zone calculations
function calculateHRZones(age, restingHR) {
  // Tanaka formula (Source 3)
  const hrMax = Math.round(208 - 0.7 * age);

  if (restingHR && restingHR > 0) {
    // Karvonen method (Source 4) - more personalized
    const hrr = hrMax - restingHR;
    return {
      hrMax,
      method: 'karvonen',
      zone1: { low: Math.round(restingHR + hrr * 0.50), high: Math.round(restingHR + hrr * 0.60), label: 'Recovery' },
      zone2: { low: Math.round(restingHR + hrr * 0.60), high: Math.round(restingHR + hrr * 0.70), label: 'Aerobic Base' },
      zone3: { low: Math.round(restingHR + hrr * 0.70), high: Math.round(restingHR + hrr * 0.80), label: 'Tempo' },
      zone4: { low: Math.round(restingHR + hrr * 0.80), high: Math.round(restingHR + hrr * 0.90), label: 'Threshold' },
      zone5: { low: Math.round(restingHR + hrr * 0.90), high: hrMax, label: 'VO2max' },
    };
  }

  // Fallback: straight %HRmax
  return {
    hrMax,
    method: 'hrmax',
    zone1: { low: Math.round(hrMax * 0.50), high: Math.round(hrMax * 0.60), label: 'Recovery' },
    zone2: { low: Math.round(hrMax * 0.60), high: Math.round(hrMax * 0.70), label: 'Aerobic Base' },
    zone3: { low: Math.round(hrMax * 0.70), high: Math.round(hrMax * 0.80), label: 'Tempo' },
    zone4: { low: Math.round(hrMax * 0.80), high: Math.round(hrMax * 0.90), label: 'Threshold' },
    zone5: { low: Math.round(hrMax * 0.90), high: hrMax, label: 'VO2max' },
  };
}

// Weekly targets (Source 1: ACSM + Source 2: Seiler polarized model)
const CARDIO_WEEKLY_TARGETS = {
  totalMinModerate: 150,  // ACSM: 150 min/week moderate
  zone2Pct: 0.80,         // Polarized: 80% easy
  hiitPct: 0.20,          // Polarized: 20% hard
  zone2MinPerWeek: 120,   // 80% of 150 = 120 min
  hiitMinPerWeek: 30,     // 20% of 150 = 30 min (at vigorous = 60 min moderate-equivalent)
  sessionsPerWeek: 3,     // 2 easy + 1 hard
};

// Cardio protocol database
// Each protocol has: modality, zone, duration (min), structure description
const CARDIO_PROTOCOLS = {
  zone2: [
    {
      name: 'Incline Walk',
      detail: '3.5 mph, 8-12% grade',
      durationMin: 35,
      notes: 'Nose-breathing pace \u2014 you should be able to hold a conversation',
      modality: 'treadmill',
    },
    {
      name: 'Steady-State Cycling',
      detail: '70-80 RPM, moderate resistance',
      durationMin: 30,
      notes: 'Maintain cadence, keep effort conversational',
      modality: 'bike',
    },
    {
      name: 'Elliptical Steady State',
      detail: 'Moderate resistance, 130+ strides/min',
      durationMin: 30,
      notes: 'Full range of motion, upright posture',
      modality: 'elliptical',
    },
    {
      name: 'Stair Climber Steady',
      detail: 'Level 5-7, steady pace',
      durationMin: 25,
      notes: 'Hands off rails, upright posture',
      modality: 'stairclimber',
    },
    {
      name: 'Rowing Steady State',
      detail: '22-26 strokes/min, focus on form',
      durationMin: 25,
      notes: 'Drive with legs first, steady breathing',
      modality: 'rower',
    },
  ],
  hiit: [
    {
      name: 'Rowing Intervals',
      detail: '5\u00d72 min hard / 2 min easy',
      durationMin: 22,
      notes: '500m pace target: push hard on work sets',
      modality: 'rower',
      zone: 4,
    },
    {
      name: 'Cycling Intervals',
      detail: '6\u00d71 min sprint / 2 min recovery',
      durationMin: 20,
      notes: 'High resistance on sprints, spin easy on rest',
      modality: 'bike',
      zone: 5,
    },
    {
      name: 'Stair Climber Intervals',
      detail: '5\u00d72 min level 10-12 / 2 min level 4-5',
      durationMin: 22,
      notes: 'Hands off rails during work intervals',
      modality: 'stairclimber',
      zone: 4,
    },
    {
      name: 'Treadmill Intervals',
      detail: '6\u00d71 min run @ 8-9 mph / 2 min walk',
      durationMin: 20,
      notes: 'Flat or 1% incline, max effort on sprints',
      modality: 'treadmill',
      zone: 5,
    },
  ],
};

// Analyze cardio from workout history (last 7 days)
function analyzeCardioHistory(workouts) {
  const now = new Date();
  const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

  let cardioSessions7d = 0;
  let estimatedMinutes7d = 0;
  const recentModalities = [];

  for (const w of workouts) {
    const wDate = new Date(w.start_time || w.created_at);
    if (wDate < sevenDaysAgo) continue;

    let workoutHasCardio = false;

    for (const ex of (w.exercises || [])) {
      const name = ex.title || '';
      const isCardio = CARDIO_PATTERNS.some(p => p.test(name));
      if (!isCardio) continue;

      workoutHasCardio = true;
      // Estimate duration from sets: Hevy duration-based exercises store duration_seconds
      let sessionMin = 0;
      for (const s of (ex.sets || [])) {
        if (s.duration_seconds && s.duration_seconds > 0) {
          sessionMin += s.duration_seconds / 60;
        } else {
          // Fallback: assume ~20 min per cardio exercise if no duration data
          sessionMin = 20;
          break;
        }
      }
      estimatedMinutes7d += sessionMin;

      // Track modality for variety
      const modality = name.toLowerCase();
      if (/treadmill|walk|run/i.test(modality)) recentModalities.push('treadmill');
      else if (/bike|cycl/i.test(modality)) recentModalities.push('bike');
      else if (/elliptical/i.test(modality)) recentModalities.push('elliptical');
      else if (/stair/i.test(modality)) recentModalities.push('stairclimber');
      else if (/row/i.test(modality)) recentModalities.push('rower');
    }

    // Count distinct workouts with at least one cardio exercise (not per-exercise)
    if (workoutHasCardio) cardioSessions7d++;
  }

  return { cardioSessions7d, estimatedMinutes7d, recentModalities };
}

// Generate cardio recommendations for today
function generateCardioRecommendations(workouts) {
  const rhr = healthData ? healthData.resting_heart_rate : null;
  const zones = calculateHRZones(PROFILE.age, rhr);
  const history = analyzeCardioHistory(workouts);

  const targetMin = CARDIO_WEEKLY_TARGETS.totalMinModerate;
  const remainingMin = Math.max(0, targetMin - history.estimatedMinutes7d);
  const targetSessions = CARDIO_WEEKLY_TARGETS.sessionsPerWeek;
  const remainingSessions = Math.max(0, targetSessions - history.cardioSessions7d);

  // If target met for the week
  if (remainingSessions <= 0 && remainingMin <= 0) {
    return { zones, history, prescriptions: [], weekComplete: true, remainingMin: 0, targetMin };
  }

  const prescriptions = [];

  // Decide session split: if 3+ sessions remain, prescribe 1 HIIT + 1 Zone 2
  // If 2 remain: 1 Zone 2 + 1 HIIT. If 1 remains: Zone 2 (safer default)
  const needHIIT = remainingSessions >= 2 && history.cardioSessions7d < 1;
  const zone2Count = needHIIT ? 1 : Math.min(remainingSessions, 2);
  const hiitCount = needHIIT ? 1 : (remainingSessions >= 2 ? 1 : 0);

  // Pick zone 2 protocols (avoid recently used modalities for variety)
  const z2Pool = CARDIO_PROTOCOLS.zone2.filter(p => !history.recentModalities.includes(p.modality));
  const z2Picks = z2Pool.length > 0 ? z2Pool : CARDIO_PROTOCOLS.zone2;

  for (let i = 0; i < zone2Count && i < z2Picks.length; i++) {
    const protocol = z2Picks[i % z2Picks.length];
    prescriptions.push({
      ...protocol,
      zone: 2,
      hrRange: `${zones.zone2.low}-${zones.zone2.high}`,
    });
  }

  // Pick HIIT protocol
  if (hiitCount > 0) {
    const hiitPool = CARDIO_PROTOCOLS.hiit.filter(p => !history.recentModalities.includes(p.modality));
    const hiitPicks = hiitPool.length > 0 ? hiitPool : CARDIO_PROTOCOLS.hiit;
    const protocol = hiitPicks[0];
    const hiitZone = protocol.zone || 4;
    const zoneData = hiitZone === 5 ? zones.zone5 : zones.zone4;
    prescriptions.push({
      ...protocol,
      zone: hiitZone,
      hrRange: `${zoneData.low}-${zoneData.high}`,
    });
  }

  return { zones, history, prescriptions, weekComplete: false, remainingMin, targetMin };
}

// ============================================================
// RENDER CARDIO PLAN
// ============================================================
function renderCardioPlan(workouts) {
  const result = generateCardioRecommendations(workouts);
  const summaryEl = document.getElementById('cardio-summary');
  const rxEl = document.getElementById('cardio-prescriptions');

  // Week progress bar
  const donePct = Math.min(100, Math.round(((result.targetMin - result.remainingMin) / result.targetMin) * 100));
  const doneMin = result.targetMin - result.remainingMin;
  const barColor = donePct >= 100 ? '#4ade80' : donePct >= 50 ? '#60a5fa' : '#fb923c';

  summaryEl.innerHTML = `
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:14px;padding-bottom:12px;border-bottom:1px solid #2a2a2e;">
      <div style="font-family:'Space Grotesk',sans-serif;font-size:14px;color:#4ade80;font-weight:600;white-space:nowrap;">${Math.round(doneMin)}/${result.targetMin}m</div>
      <div style="flex:1;height:5px;border-radius:3px;background:#222226;overflow:hidden;">
        <div style="height:100%;border-radius:3px;background:${barColor};width:${donePct}%;transition:width 0.4s ease;"></div>
      </div>
      <div style="font-family:'Space Grotesk',sans-serif;font-size:12px;color:#8e8e98;white-space:nowrap;">this week</div>
    </div>`;

  if (result.weekComplete) {
    rxEl.innerHTML = `<div style="font-size:14px;color:#4ade80;font-family:'Space Grotesk',sans-serif;padding:8px 0;">\u2713 Weekly cardio target met. Active recovery or rest recommended.</div>`;
    return;
  }

  // Zone colors matching urgency badge style
  const zoneStyles = {
    2: { bg: 'rgba(96,165,250,0.12)', color: '#60a5fa', label: 'Zone 2' },
    4: { bg: 'rgba(251,146,60,0.12)', color: '#fb923c', label: 'Zone 4' },
    5: { bg: 'rgba(248,113,113,0.12)', color: '#f87171', label: 'Zone 5' },
  };

  let html = '';
  for (const rx of result.prescriptions) {
    const zs = zoneStyles[rx.zone] || zoneStyles[2];

    html += `<div style="padding:12px 0;border-bottom:1px solid #1a1a1e;">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
        <span style="font-size:11px;font-weight:600;padding:3px 8px;border-radius:5px;font-family:'Space Grotesk',sans-serif;text-transform:uppercase;letter-spacing:0.5px;background:${zs.bg};color:${zs.color};">${zs.label}</span>
        <span style="font-family:'Space Grotesk',sans-serif;font-size:13px;color:#4ade80;font-weight:600;">${rx.durationMin} min</span>
      </div>
      <div style="font-size:15px;font-weight:600;color:#f4f4f6;margin-bottom:4px;">${rx.name}</div>
      <div style="font-size:13px;font-family:'Space Grotesk',sans-serif;color:#bcbcc4;line-height:1.5;">${rx.detail}</div>
      <div style="font-size:12px;font-family:'Space Grotesk',sans-serif;color:#8e8e98;margin-top:2px;">${rx.notes}</div>
      <div style="display:inline-block;margin-top:6px;font-size:12px;font-family:'Space Grotesk',sans-serif;color:${zs.color};padding:2px 8px;border-radius:4px;background:${zs.bg};">\u2661 ${rx.hrRange} bpm</div>
    </div>`;
  }

  rxEl.innerHTML = html;
}

// ============================================================
// SMART WEIGHT PRESCRIPTION (Pillar 4)
// ============================================================
function prescribeExercise(name) {
  const db = EXERCISE_DB[name];
  const hist = exerciseHistory[name];

  let sets = db ? db.sets : 3;
  let reps = db ? db.reps : '8-10';
  let weightLbs = db ? db.benchmarkLbs : 0;
  let note = db ? (db.note || '') : '';

  if (hist && hist.lastWeightLbs > 0) {
    const lastW = hist.lastWeightLbs;
    const trend = hist.weights.length >= 3
      ? hist.weights.slice(-3).reduce((a, b) => a + b, 0) / 3
      : lastW;

    if (db && lastW < db.benchmarkLbs * 0.85) {
      weightLbs = Math.min(Math.round(trend * 1.05 / 5) * 5, db.benchmarkLbs);
    } else {
      weightLbs = Math.round(trend * 1.025 / 5) * 5;
    }
    if (hist.lastSets >= 2 && hist.lastSets <= 6) sets = hist.lastSets;
  } else if (!db) {
    return { sets: 3, reps: '8-10', weightLbs: 0, note: 'no data' };
  }

  if (note === 'bodyweight' || note === 'hold') weightLbs = 0;
  return { sets, reps, weightLbs, note };
}

function formatPrescription(p) {
  let str = `${p.sets}\u00d7${p.reps}`;
  if (p.weightLbs > 0) str += ` @ ${p.weightLbs}lbs`;
  if (p.note === 'per hand' || p.note === 'per side') str += '/ea';
  return str;
}

// ============================================================
// IMBALANCE DETECTION & RECOMMENDATIONS
// ============================================================
function generateRecommendations(muscleStats) {
  const recs = [];
  const weeklyVolumes = {};
  for (const [key, stat] of Object.entries(muscleStats)) {
    weeklyVolumes[key] = stat.totalSets30d / 4.3;
  }

  const volumeRatios = {};
  let maxRatio = 0;
  for (const [key, stat] of Object.entries(muscleStats)) {
    const ratio = weeklyVolumes[key] / stat.idealSetsPerWeek;
    volumeRatios[key] = ratio;
    if (ratio > maxRatio) maxRatio = ratio;
  }

  // Phase 3: proportion deficit scores (0 if no measurements)
  const hasProportions = Object.keys(proportionDeficits).length > 0;
  const proportionWeight = hasProportions ? 0.15 : 0;
  // Rebalance weights when proportions are available
  const recencyW   = hasProportions ? 0.35 : 0.40;
  const volumeW    = hasProportions ? 0.25 : 0.30;
  const imbalanceW = hasProportions ? 0.25 : 0.30;

  for (const [key, stat] of Object.entries(muscleStats)) {
    // Recency uses PRIMARY training date â€” secondary stimulus (e.g. RDLs for back)
    // doesn't reset the clock. This prevents back from being deprioritized when
    // only indirect work has been done recently.
    const recencyScore = Math.min(stat.daysSincePrimary / stat.idealFreqDays, 3);
    const idealSets30d = stat.idealSetsPerWeek * 4.3;
    const volumeDeficit = Math.max(0, 1 - (stat.totalSets30d / idealSets30d));
    const imbalanceScore = maxRatio > 0 ? Math.max(0, 1 - (volumeRatios[key] / maxRatio)) : 0;
    const propDeficit = proportionDeficits[key] || 0;

    const score = (recencyScore * recencyW)
               + (volumeDeficit * volumeW)
               + (imbalanceScore * imbalanceW)
               + (propDeficit * proportionWeight);

    let urgency = 'low';
    if (stat.daysSincePrimary >= stat.idealFreqDays * 2 || (volumeDeficit > 0.6 && imbalanceScore > 0.5)) {
      urgency = 'high';
    } else if (stat.daysSincePrimary >= stat.idealFreqDays || volumeDeficit > 0.3) {
      urgency = 'med';
    }

    const weeklyActual = weeklyVolumes[key].toFixed(1);
    const weeklyIdeal = stat.idealSetsPerWeek;
    let explainer = '';

    // Has secondary-only recent work? (primary is old but any is recent)
    const hasIndirectOnly = stat.daysSincePrimary > stat.daysSinceAny && stat.daysSinceAny < stat.idealFreqDays;

    if (stat.daysSincePrimary === Infinity && stat.daysSinceAny === Infinity) {
      explainer = `No ${stat.name.toLowerCase()} training found in your history. This muscle group needs attention to build a balanced physique.`;
    } else if (stat.daysSincePrimary === Infinity) {
      explainer = `No direct ${stat.name.toLowerCase()} work found â€” only indirect stimulus (${stat.daysSinceAny}d ago). Add dedicated exercises to develop this muscle group.`;
    } else {
      const parts = [];
      if (stat.daysSincePrimary >= stat.idealFreqDays * 2) {
        let msg = `Last direct work <strong>${stat.daysSincePrimary} days ago</strong> \u2014 ideally every ${stat.idealFreqDays} days for optimal growth`;
        if (hasIndirectOnly) msg += ` (indirect stimulus ${stat.daysSinceAny}d ago doesn\u2019t fully count)`;
        parts.push(msg);
      } else if (stat.daysSincePrimary >= stat.idealFreqDays) {
        let msg = `Directly trained ${stat.daysSincePrimary} days ago, slightly past the ${stat.idealFreqDays}-day window`;
        if (hasIndirectOnly) msg += ` (secondary-only work ${stat.daysSinceAny}d ago)`;
        parts.push(msg);
      }
      if (volumeDeficit > 0.3) {
        parts.push(`Volume is <strong>${weeklyActual} sets/week</strong> vs the ${weeklyIdeal} recommended \u2014 ${Math.round(volumeDeficit * 100)}% below target`);
      }
      if (imbalanceScore > 0.4) {
        const topMuscle = Object.entries(volumeRatios).sort((a, b) => b[1] - a[1])[0];
        if (topMuscle[0] !== key) {
          parts.push(`Lagging behind your ${muscleStats[topMuscle[0]].name.toLowerCase()} proportionally \u2014 focus here to balance out`);
        }
      }
      if (propDeficit > 0.05) {
        const rule = PROPORTION_RULES.find(r => r.muscle === key);
        if (rule) {
          parts.push(`Measurement-based proportion (<strong>${rule.label}</strong>) is ${Math.round(propDeficit * 100)}% below target`);
        }
      }
      if (parts.length === 0) {
        parts.push(`On track. ${weeklyActual} sets/week is close to the ${weeklyIdeal} target. Last direct work ${stat.daysSincePrimary} days ago.`);
      }
      explainer = parts.join('. ') + '.';
    }

    recs.push({
      key, name: stat.name, score, urgency,
      daysSince: stat.daysSincePrimary,
      daysSinceAny: stat.daysSinceAny,
      sets30d: stat.totalSets30d,
      detail: stat.daysSincePrimary === Infinity
        ? (stat.daysSinceAny === Infinity ? 'no data' : `indirect ${stat.daysSinceAny}d ago`)
        : `${stat.daysSincePrimary}d ago \u00b7 ${formatSets(stat.totalSets30d)} sets/30d`,
      explainer,
      weeklyActual: parseFloat(weeklyActual),
      weeklyIdeal,
    });
  }

  recs.sort((a, b) => b.score - a.score);
  return recs;
}

// ============================================================
// SESSION PLANNING (v1.1 Task 8 - upgraded)
// Improved: fatigue-aware, ensures isolation for #1 priority,
// avoids stacking heavy compounds for same movement pattern
// ============================================================
const MUSCLE_EXERCISE_CAP = {
  caps: [3, 2, 2],
};

// Movement pattern groups to avoid stacking
const MOVEMENT_PATTERNS = {
  'horizontal_push': ['Bench Press (Barbell)', 'Incline Bench Press (Dumbbell)', 'Incline Bench Press (Barbell)', 'Chest Press (Machine)', 'Decline Bench Press (Barbell)'],
  'vertical_push': ['Overhead Press (Barbell)', 'Overhead Press (Dumbbell)', 'Arnold Press (Dumbbell)', 'Seated Shoulder Press (Machine)', 'Shoulder Press (Dumbbell)', 'Standing Military Press (Barbell)'],
  'horizontal_pull': ['Bent Over Row (Barbell)', 'Seated Row (Machine)', 'Dumbbell Row', 'Pendlay Row (Barbell)'],
  'vertical_pull': ['Pull Up', 'Chin Up', 'Lat Pulldown (Cable)', 'Lat Pulldown (Machine)'],
  'knee_dominant': ['Squat (Barbell)', 'Leg Press (Machine)', 'Front Squat', 'Goblet Squat'],
  'hip_dominant': ['Deadlift (Barbell)', 'Romanian Deadlift (Barbell)', 'Hip Thrust (Barbell)', 'Hip Thrust (Machine)'],
};

function getMovementPattern(exName) {
  for (const [pattern, exercises] of Object.entries(MOVEMENT_PATTERNS)) {
    if (exercises.includes(exName)) return pattern;
  }
  return null;
}

function buildTimedSession(recs, prefs) {
  prefs = prefs || sessionPrefs;
  const topKeys = recs.slice(0, 3).map(r => r.key);
  const recScores = {};
  recs.forEach(r => { recScores[r.key] = r.score; });

  const muscleCaps = {};
  topKeys.forEach((key, idx) => { muscleCaps[key] = MUSCLE_EXERCISE_CAP.caps[idx] || 2; });

  // Build candidates
  const candidates = [];
  for (const key of topKeys) {
    const picks = MUSCLE_EXERCISE_PICKS[key] || [];
    const cappedPicks = picks.slice(0, muscleCaps[key]);
    const groupPriority = recScores[key] || 0;

    for (let i = 0; i < cappedPicks.length; i++) {
      const exName = cappedPicks[i];

      // Equipment filter: exclude gym-only exercises in home mode
      if (prefs.equipment === 'home' && GYM_ONLY_REGEX.test(exName)) continue;

      const db = EXERCISE_DB[exName];
      const p = prescribeExercise(exName);
      const mp = getMovementPattern(exName);

      // No OHP filter: exclude compound vertical push
      if (prefs.avoidOHP && mp === 'vertical_push' && db && db.type === 'compound') continue;

      const typeBonus = (db && db.type === 'compound') ? 1.5 : 1.0;
      let deficitBonus = 1.0;
      if (db && db.benchmarkLbs > 0 && p.weightLbs > 0) {
        deficitBonus = (p.weightLbs / db.benchmarkLbs) < 0.85 ? 1.3 : 1.0;
      }
      const orderBonus = 1 - (i * 0.1);
      const importance = groupPriority * typeBonus * deficitBonus * orderBonus;
      const timeSec = calculateExerciseTime(exName, p.sets);

      candidates.push({
        name: exName, muscle: key, prescription: p,
        importance, timeSec,
        isCompound: db && db.type === 'compound',
        isIsolation: db && db.type === 'isolation',
        movementPattern: mp,
      });
    }
  }

  candidates.sort((a, b) => b.importance - a.importance);

  // Time cap from prefs
  const capSec = (prefs.sessionCapMin || TIME_CONSTANTS.sessionCapMin) * 60;
  const session = [];
  let totalSec = 0;
  const usedPatterns = new Set();
  const muscleCompoundCount = {};

  const topMuscle = topKeys[0];
  let topMuscleHasIsolation = false;

  // Strictness rules
  const enforcePatternRule = prefs.strictness !== 'loose';
  const strictCompoundRule = prefs.strictness === 'strict';

  for (const c of candidates) {
    if (totalSec + c.timeSec > capSec) continue;

    // Movement pattern uniqueness (strict + balanced)
    if (enforcePatternRule && c.isCompound && c.movementPattern) {
      if (usedPatterns.has(c.movementPattern)) continue;
    }

    // Max 1 compound per muscle
    if (c.isCompound) {
      if (strictCompoundRule && (muscleCompoundCount[c.muscle] || 0) >= 1) continue;
      // Balanced: relax if session is under-filled (<70% cap)
      if (prefs.strictness === 'balanced' && (muscleCompoundCount[c.muscle] || 0) >= 1) {
        if (totalSec >= capSec * 0.7) continue;
      }
    }

    session.push(c);
    totalSec += c.timeSec;
    if (c.isCompound && c.movementPattern) usedPatterns.add(c.movementPattern);
    if (c.isCompound) muscleCompoundCount[c.muscle] = (muscleCompoundCount[c.muscle] || 0) + 1;
    if (c.muscle === topMuscle && c.isIsolation) topMuscleHasIsolation = true;
  }

  // Ensure #1 priority has at least one isolation if possible
  if (!topMuscleHasIsolation && session.length > 0) {
    const isoCandidate = candidates.find(c =>
      c.muscle === topMuscle && c.isIsolation && !session.includes(c) &&
      totalSec + c.timeSec <= capSec
    );
    if (isoCandidate) {
      session.push(isoCandidate);
      totalSec += isoCandidate.timeSec;
    }
  }

  return { exercises: session, totalSec };
}

// ============================================================
// RENDERING
// ============================================================
// renderRecommendations removed in v1.7 â€” replaced by renderTimedSession

// B2: Sort mode state for Today tab — 'urgency' (default) or 'anatomy'
let todaySortMode = 'urgency';
const ANATOMY_ORDER = ['chest', 'back', 'shoulders', 'quads', 'hamstrings', 'glutes', 'biceps', 'triceps', 'calves', 'core', 'neck', 'forearms'];

function toggleTodaySort(mode) {
  todaySortMode = mode;
  if (LAST_RECS) renderTimedSession(LAST_RECS);
}

function renderTimedSession(recs) {
  const { exercises, totalSec } = buildTimedSession(recs);
  const totalMin = Math.round(totalSec / 60);

  // B2: Sort toggle UI
  const urgBtn = todaySortMode === 'urgency';
  const segStyle = `display:inline-flex;gap:2px;background:#131315;border-radius:6px;padding:2px;border:1px solid #2a2a2e;margin-bottom:12px;`;
  const btnOn = `padding:4px 10px;font-size:11px;font-weight:600;font-family:'Space Grotesk',sans-serif;border:none;border-radius:5px;cursor:pointer;`;
  const btnActive = `${btnOn}background:#222226;color:#f4f4f6;`;
  const btnInactive = `${btnOn}background:none;color:#8e8e98;`;

  document.getElementById('session-summary').innerHTML = `
    <div class="session-summary">
      <div class="session-time" style="color:#4ade80">~${totalMin} min</div>
      <div class="session-count" style="color:#8e8e98">${exercises.length} exercises</div>
    </div>
    <div style="${segStyle}">
      <button style="${urgBtn ? btnActive : btnInactive}" onclick="toggleTodaySort('urgency')">Urgency</button>
      <button style="${!urgBtn ? btnActive : btnInactive}" onclick="toggleTodaySort('anatomy')">Anatomy</button>
    </div>
  `;

  const exContainer = document.getElementById('suggested-exercises');
  const grouped = {};
  for (const ex of exercises) {
    if (!grouped[ex.muscle]) grouped[ex.muscle] = [];
    grouped[ex.muscle].push(ex);
  }

  // B2: Sort muscle groups by selected mode
  let groupKeys = Object.keys(grouped);
  if (todaySortMode === 'anatomy') {
    groupKeys.sort((a, b) => ANATOMY_ORDER.indexOf(a) - ANATOMY_ORDER.indexOf(b));
  } else {
    // urgency: sort by recommendation score (highest first)
    const recScores = {};
    recs.forEach(r => { recScores[r.key] = r.score; });
    groupKeys.sort((a, b) => (recScores[b] || 0) - (recScores[a] || 0));
  }

  // B1: Build rec lookup for explainers
  const recMap = {};
  recs.forEach(r => { recMap[r.key] = r; });

  let exHtml = '';
  for (const key of groupKeys) {
    const exes = grouped[key];
    const meta = MUSCLE_GROUPS[key];
    if (!meta) continue;
    const rec = recMap[key];

    exHtml += `<div class="ex-group">
      <div class="ex-group-title" style="color:${meta.color};cursor:pointer;display:flex;align-items:center;justify-content:space-between;" onclick="toggleSessionExplainer('exp-${key}')">
        <span>${meta.name}</span>
        <span style="font-size:10px;color:#8e8e98;font-weight:400;letter-spacing:0;">▾ why</span>
      </div>`;

    // B1: Collapsible "Why this?" explainer
    if (rec) {
      const daysSince = rec.daysSince === Infinity ? '∞' : rec.daysSince;
      const idealFreq = (muscleAnalysis && muscleAnalysis[key]) ? muscleAnalysis[key].idealFreqDays : '?';
      const volActual = rec.weeklyActual;
      const volIdeal = rec.weeklyIdeal;
      const propDef = proportionDeficits[key];

      let bullets = [];
      bullets.push(`<span style="color:#8e8e98;">Days since:</span> <strong>${daysSince}</strong> <span style="color:#6e6e78;">vs ideal ${idealFreq}d</span>`);
      const deficit = Math.max(0, volIdeal - volActual);
      if (deficit > 0) {
        bullets.push(`<span style="color:#8e8e98;">Volume gap:</span> <strong>${deficit.toFixed(1)} sets/wk</strong> <span style="color:#6e6e78;">below ${volIdeal}</span>`);
      } else {
        bullets.push(`<span style="color:#8e8e98;">Volume:</span> <strong>${volActual} / ${volIdeal}</strong> <span style="color:#4ade80;">✓</span>`);
      }
      if (propDef && propDef > 0.05) {
        const rule = PROPORTION_RULES.find(r => r.muscle === key);
        if (rule) bullets.push(`<span style="color:#8e8e98;">Proportion:</span> <strong>${rule.label}</strong> <span style="color:#fb923c;">${Math.round(propDef * 100)}% below target</span>`);
      }

      exHtml += `<div class="rec-expand" id="exp-${key}" style="max-height:0;overflow:hidden;opacity:0;transition:max-height 0.3s ease,opacity 0.25s ease;">
        <div class="rec-explainer" style="padding:6px 0 10px 0;font-size:12px;line-height:1.7;">
          ${bullets.map(b => `<div>${b}</div>`).join('')}
        </div>
      </div>`;
    }

    for (const ex of exes) {
      const rx = formatPrescription(ex.prescription);
      const timeMin = (ex.timeSec / 60).toFixed(0);
      exHtml += `
        <div class="ex-row">
          <div class="ex-name" style="color:#f4f4f6">${ex.name}</div>
          <div class="ex-prescription" style="color:#4ade80">${rx}</div>
          <div class="ex-time" style="color:#8e8e98">${timeMin}m</div>
        </div>`;
    }
    exHtml += `</div>`;
  }
  exContainer.innerHTML = exHtml;
}

// B1: Toggle explainer panel for a muscle group in Today tab
function toggleSessionExplainer(id) {
  const el = document.getElementById(id);
  if (!el) return;
  if (el.classList.contains('open')) {
    el.style.maxHeight = '0';
    el.style.opacity = '0';
    el.classList.remove('open');
  } else {
    // Close any other open explainers
    document.querySelectorAll('#suggested-exercises .rec-expand.open').forEach(other => {
      other.style.maxHeight = '0';
      other.style.opacity = '0';
      other.classList.remove('open');
    });
    el.classList.add('open');
    el.style.opacity = '1';
    el.style.maxHeight = el.scrollHeight + 'px';
  }
}

// ============================================================
// MUSCLE GRID (v1.1 Task 3: simplified - no percentile text, no bar)
// ============================================================
function getMuscleCardColor(muscleKey, daysSinceTrained, idealFreqDays) {
  const rmData = muscle1RMs[muscleKey];
  let percentile = rmData ? rmData.percentile : null;

  if (percentile === null) {
    const stat = muscleAnalysis ? muscleAnalysis[muscleKey] : null;
    if (stat) {
      const volRatio = stat.totalSets30d / (stat.idealSetsPerWeek * 4.3);
      percentile = Math.round(Math.min(volRatio, 1) * 75);
    } else {
      percentile = 25;
    }
  }

  let hue;
  if (percentile < 25) hue = Math.round((percentile / 25) * 30);
  else if (percentile < 50) hue = 30 + Math.round(((percentile - 25) / 25) * 40);
  else if (percentile < 75) hue = 70 + Math.round(((percentile - 50) / 25) * 40);
  else hue = 110 + Math.round(Math.min((percentile - 75) / 25, 1) * 30);

  const overdueDays = Math.max(0, daysSinceTrained - idealFreqDays);
  let sat, light;
  if (daysSinceTrained === Infinity) { sat = 60; light = 25; }
  else if (overdueDays <= 0) { sat = 20; light = 16; }
  else if (overdueDays <= 2) { sat = 35; light = 19; }
  else { sat = Math.min(55 + overdueDays * 3, 70); light = Math.min(22 + overdueDays, 30); }

  return {
    bg: `hsla(${hue}, ${sat}%, ${light}%, 0.35)`,
    border: `hsla(${hue}, ${sat}%, ${light + 15}%, 0.4)`,
    textColor: `hsl(${hue}, ${Math.min(sat + 20, 85)}%, ${Math.min(light + 40, 75)}%)`,
  };
}

function renderMuscleGrid(muscleStats, recs) {
  const grid = document.getElementById('muscle-grid');

  // Build a lookup from recs for urgency + explainer + score
  const recMap = {};
  if (recs) {
    recs.forEach(r => { recMap[r.key] = r; });
  }

  // Sort by priority score (highest first) so most urgent = top-left
  const entries = Object.entries(muscleStats).sort((a, b) => {
    const scoreA = recMap[a[0]] ? recMap[a[0]].score : 0;
    const scoreB = recMap[b[0]] ? recMap[b[0]].score : 0;
    return scoreB - scoreA;
  });

  grid.innerHTML = entries.map(([key, stat]) => {
    let daysText;
    if (stat.daysSincePrimary === Infinity && stat.daysSinceAny === Infinity) {
      daysText = 'no data';
    } else if (stat.daysSincePrimary === Infinity) {
      daysText = `indirect ${stat.daysSinceAny}d`;
    } else {
      daysText = `${stat.daysSincePrimary}d ago`;
    }
    const weeklyVol = (stat.totalSets30d / 4.3).toFixed(1);
    const colors = getMuscleCardColor(key, stat.daysSincePrimary, stat.idealFreqDays);
    const rec = recMap[key];
    const urgency = rec ? rec.urgency : 'low';
    const urgencyClass = `urgency-${urgency}`;

    return `
      <div class="muscle-cell" style="background:${colors.bg};border-color:${colors.border}" onclick="toggleMuscleDetail('${key}')">
        <div class="muscle-cell-header">
          <div class="muscle-name" style="color:${colors.textColor}">${stat.name}</div>
          <div class="muscle-urgency ${urgencyClass}">${urgency}</div>
        </div>
        <div class="muscle-stat">${daysText} \u00b7 ${weeklyVol}/${stat.idealSetsPerWeek}/wk</div>
      </div>`;
  }).join('');

  // Store recs for detail panel
  window._muscleRecMap = recMap;

  // Click outside any cell to deselect (attach once)
  if (!grid.dataset.clickOutside) {
    grid.dataset.clickOutside = '1';
    grid.addEventListener('click', function(e) {
      if (!e.target.closest('.muscle-cell')) {
        const detailEl = document.getElementById('muscle-detail');
        if (detailEl && detailEl.classList.contains('open')) {
          detailEl.style.maxHeight = '0';
          detailEl.classList.remove('open');
          selectedMuscleKey = null;
          document.querySelectorAll('.muscle-cell').forEach(c => c.style.outline = 'none');
        }
      }
    });
  }
}

let selectedMuscleKey = null;

function toggleMuscleDetail(key) {
  const detailEl = document.getElementById('muscle-detail');
  const innerEl = document.getElementById('muscle-detail-inner');

  if (selectedMuscleKey === key && detailEl.classList.contains('open')) {
    detailEl.style.maxHeight = '0';
    detailEl.classList.remove('open');
    selectedMuscleKey = null;
    document.querySelectorAll('.muscle-cell').forEach(c => c.style.outline = 'none');
    return;
  }

  selectedMuscleKey = key;
  const rec = window._muscleRecMap ? window._muscleRecMap[key] : null;

  if (rec) {
    innerEl.innerHTML = rec.explainer;
  } else {
    innerEl.innerHTML = 'No analysis available.';
  }

  detailEl.classList.add('open');
  detailEl.style.maxHeight = innerEl.scrollHeight + 24 + 'px';

  // Highlight selected cell
  document.querySelectorAll('.muscle-cell').forEach(c => c.style.outline = 'none');
  const cells = document.querySelectorAll('.muscle-cell');
  const entries = Object.entries(muscleAnalysis || {}).sort((a, b) => {
    const rm = window._muscleRecMap || {};
    return (rm[b[0]] ? rm[b[0]].score : 0) - (rm[a[0]] ? rm[a[0]].score : 0);
  });
  const idx = entries.findIndex(([k]) => k === key);
  if (idx >= 0 && cells[idx]) {
    cells[idx].style.outline = '1.5px solid #4ade80';
  }
}

// ============================================================
// HEATMAP (v1.7: 12 days, no scroll, no direction row)
// ============================================================
let heatmapDayWorkouts = {};
let selectedHeatmapDay = null;

function renderHeatmap(dayMuscleMap, dayWorkoutsMap) {
  heatmapDayWorkouts = dayWorkoutsMap;
  const container = document.getElementById('heatmap-container');
  const muscleKeys = ['chest', 'back', 'shoulders', 'quads', 'hamstrings', 'glutes', 'biceps', 'triceps', 'calves', 'core', 'neck', 'forearms'];
  const muscleLabels = ['Chest', 'Back', 'Shldr', 'Quads', 'Hams', 'Glts', 'Bis', 'Tris', 'Calves', 'Core', 'Neck', 'F.Arms'];

  // v1.7: 12 days lookback, no scroll
  const now = new Date();
  const days = [];
  const numDays = 12;
  for (let i = numDays - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(d.getDate() - i);
    days.push(d.toISOString().split('T')[0]);
  }

  let maxSets = 0;
  for (const [, muscles] of Object.entries(dayMuscleMap)) {
    for (const [, sets] of Object.entries(muscles)) {
      if (sets > maxSets) maxSets = sets;
    }
  }
  if (maxSets === 0) maxSets = 1;

  const labelWidth = 54;
  const cellSize = 18;
  let html = '';

  // Fixed cell sizing for stable layout on all widths
  html += `<div class="heatmap-grid" style="grid-template-columns: ${labelWidth}px repeat(${numDays}, ${cellSize}px); grid-template-rows: 22px repeat(${muscleKeys.length}, ${cellSize}px);">`;

  // Day labels row
  html += `<div></div>`;
  for (let i = 0; i < days.length; i++) {
    const d = new Date(days[i] + 'T12:00:00');
    const isFirst = i === 0;
    const isLast = i === days.length - 1;
    const isMid1 = i === 4;
    const isMid2 = i === 8;
    let label = '';
    if (isFirst || isMid1 || isMid2) {
      label = `${d.getMonth() + 1}/${d.getDate()}`;
    } else if (isLast) {
      label = 'Today';
    }
    html += `<div class="heatmap-day-labels">${label}</div>`;
  }

  // Muscle rows
  for (let m = 0; m < muscleKeys.length; m++) {
    const mKey = muscleKeys[m];
    html += `<div class="heatmap-label">${muscleLabels[m]}</div>`;
    for (const day of days) {
      const sets = (dayMuscleMap[day] && dayMuscleMap[day][mKey]) || 0;
      const opacity = sets > 0 ? Math.max(0.25, Math.min(sets / maxSets, 1)) : 0;
      const bgColor = sets > 0 ? `rgba(74, 222, 128, ${opacity})` : '#1a1a1e';
      html += `<div class="heatmap-cell" style="background:${bgColor}" data-day="${day}" onclick="selectHeatmapDay('${day}')" title="${day}: ${formatSets(sets)} sets"></div>`;
    }
  }

  html += '</div>';
  container.innerHTML = html;

  // Click outside any cell to deselect (attach once)
  if (!container.dataset.clickOutside) {
    container.dataset.clickOutside = '1';
    container.addEventListener('click', function(e) {
      if (!e.target.classList.contains('heatmap-cell')) {
        const detailEl = document.getElementById('heatmap-day-detail');
        if (detailEl.classList.contains('open')) {
          detailEl.style.maxHeight = '0';
          detailEl.classList.remove('open');
          selectedHeatmapDay = null;
          document.querySelectorAll('.heatmap-cell').forEach(c => { c.style.outline = 'none'; });
        }
      }
    });
  }
}

function selectHeatmapDay(day) {
  const detailEl = document.getElementById('heatmap-day-detail');
  const innerEl = document.getElementById('heatmap-day-detail-inner');

  if (selectedHeatmapDay === day && detailEl.classList.contains('open')) {
    detailEl.style.maxHeight = '0';
    detailEl.classList.remove('open');
    selectedHeatmapDay = null;
    return;
  }

  selectedHeatmapDay = day;
  const exercises = heatmapDayWorkouts[day] || [];
  const dateObj = new Date(day + 'T12:00:00');
  const dateStr = dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

  if (exercises.length === 0) {
    innerEl.innerHTML = `<div class="detail-date">${dateStr}</div><div style="color:#8e8e98;font-size:12px;">Rest day</div>`;
  } else {
    let html = `<div class="detail-date">${dateStr}</div>`;
    for (const ex of exercises) {
      const weightStr = ex.bestWeight > 0 ? ` @ ${ex.bestWeight}lbs` : '';
      html += `<div class="detail-exercise">
        <span class="detail-name">${ex.name}</span>
        <span class="detail-sets">${ex.sets}s${ex.bestReps > 0 ? ` \u00d7 ${ex.bestReps}r` : ''}${weightStr}</span>
      </div>`;
    }
    innerEl.innerHTML = html;
  }

  detailEl.classList.add('open');
  detailEl.style.maxHeight = innerEl.scrollHeight + 24 + 'px';

  document.querySelectorAll('.heatmap-cell').forEach(cell => {
    cell.style.outline = cell.dataset.day === day ? '1.5px solid #4ade80' : 'none';
  });
}

// ============================================================
// WEIGHT CHART + SI (v1.1 Task 2: always-visible SI panel)
// ============================================================
function renderWeightChart() {
  WEIGHT_DATA = getMergedWeightData();

  // Update bodyweight BEFORE populating strength detail so benchmarks use fresh weight
  if (WEIGHT_DATA.length > 0) PROFILE.bodyweightLbs = WEIGHT_DATA[0].value;

  // ALWAYS populate strength detail BEFORE any early returns
  populateStrengthDetail();

  if (WEIGHT_DATA.length === 0) return;

  const cutoff = new Date();
  cutoff.setFullYear(cutoff.getFullYear() - 1);
  const recent = WEIGHT_DATA.filter(d => new Date(d.date) >= cutoff).reverse();
  if (recent.length === 0) return;

  const current = WEIGHT_DATA[0].value;
  const prev = WEIGHT_DATA.length > 1 ? WEIGHT_DATA[1].value : current;
  const delta = current - prev;

  document.getElementById('weight-current').textContent = current.toFixed(1);
  const deltaEl = document.getElementById('weight-delta');
  deltaEl.textContent = `${delta >= 0 ? '+' : ''}${delta.toFixed(1)}`;
  deltaEl.style.color = delta <= 0 ? '#4ade80' : '#fb923c';

  // Canvas
  const canvas = document.getElementById('weight-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 150 * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = '150px';
  ctx.scale(dpr, dpr);

  const w = rect.width;
  const h = 150;
  const pad = { top: 12, bottom: 22, left: 0, right: 0 };
  const chartW = w - pad.left - pad.right;
  const chartH = h - pad.top - pad.bottom;

  const wValues = recent.map(d => d.value);
  const wMin = Math.min(...wValues) - 2;
  const wMax = Math.max(...wValues) + 2;
  const wXStep = chartW / Math.max(recent.length - 1, 1);

  // Weight line
  ctx.beginPath();
  ctx.strokeStyle = '#4ade80';
  ctx.lineWidth = 2.5;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  recent.forEach((d, i) => {
    const x = pad.left + i * wXStep;
    const y = pad.top + (1 - (d.value - wMin) / (wMax - wMin)) * chartH;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Gradient fill
  const lastX = pad.left + (recent.length - 1) * wXStep;
  ctx.lineTo(lastX, h - pad.bottom);
  ctx.lineTo(pad.left, h - pad.bottom);
  ctx.closePath();
  const gradient = ctx.createLinearGradient(0, 0, 0, h);
  gradient.addColorStop(0, 'rgba(74, 222, 128, 0.10)');
  gradient.addColorStop(1, 'rgba(74, 222, 128, 0)');
  ctx.fillStyle = gradient;
  ctx.fill();

  // Endpoint dots
  [0, recent.length - 1].forEach(i => {
    const x = pad.left + i * wXStep;
    const y = pad.top + (1 - (recent[i].value - wMin) / (wMax - wMin)) * chartH;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#4ade80';
    ctx.fill();
  });

  // Strength Index line
  if (strengthIndexData.length >= 2) {
    const wDates = recent.map(d => d.date);
    const firstDate = wDates[0];
    const lastDate = wDates[wDates.length - 1];
    const totalDays = (new Date(lastDate) - new Date(firstDate)) / (1000 * 60 * 60 * 24);

    const siFiltered = strengthIndexData.filter(d => d.date >= firstDate && d.date <= lastDate);
    if (siFiltered.length >= 2) {
      const siValues = siFiltered.map(d => d.index);
      const siMin = Math.min(...siValues) - 0.1;
      const siMax = Math.max(...siValues) + 0.1;

      ctx.beginPath();
      ctx.strokeStyle = '#818cf8';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);

      siFiltered.forEach((d, i) => {
        const dayOffset = (new Date(d.date) - new Date(firstDate)) / (1000 * 60 * 60 * 24);
        const x = pad.left + (totalDays > 0 ? (dayOffset / totalDays) : 0) * chartW;
        const y = pad.top + (1 - (d.index - siMin) / (siMax - siMin)) * chartH;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.setLineDash([]);

      [0, siFiltered.length - 1].forEach(i => {
        const d = siFiltered[i];
        const dayOffset = (new Date(d.date) - new Date(firstDate)) / (1000 * 60 * 60 * 24);
        const x = pad.left + (totalDays > 0 ? (dayOffset / totalDays) : 0) * chartW;
        const y = pad.top + (1 - (d.index - siMin) / (siMax - siMin)) * chartH;
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fillStyle = '#818cf8';
        ctx.fill();
      });
    }
  }

  // Date labels
  ctx.fillStyle = '#909098';
  ctx.font = '12px Space Grotesk, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(recent[0].date.substring(5), pad.left, h - 4);
  ctx.textAlign = 'right';
  ctx.fillText(recent[recent.length - 1].date.substring(5), w - pad.right, h - 4);
}

// v1.1: Populate SI detail content (always called, even if weight data is empty)
let activeStrengthTooltip = null;

function showStrengthPctile(el) {
  dismissStrengthTooltip();
  const tip = el.querySelector('[data-pctile-tip]');
  if (tip) {
    tip.style.opacity = '1';
    tip.style.transform = 'translate(-50%,-50%) scale(1)';
    activeStrengthTooltip = tip;
  }
}

function dismissStrengthTooltip() {
  if (activeStrengthTooltip) {
    activeStrengthTooltip.style.opacity = '0';
    activeStrengthTooltip.style.transform = 'translate(-50%,-50%) scale(0.7)';
    activeStrengthTooltip = null;
  }
}

// Click-outside listener for strength tooltips
document.addEventListener('click', function(e) {
  if (activeStrengthTooltip && !e.target.closest('[data-str-bar]')) {
    dismissStrengthTooltip();
  }
});

function populateStrengthDetail() {
  const container = document.getElementById('strength-detail');

  const liftBenchmarks = {
    bench:    { label: 'Bench',    std: 'bench_press' },
    squat:    { label: 'Squat',    std: 'squat' },
    deadlift: { label: 'Deadlift', std: 'deadlift' },
    ohp:      { label: 'OHP',      std: 'overhead_press' },
    row:      { label: 'Row',      std: 'barbell_row' },
  };

  const bw = PROFILE.bodyweightLbs;
  let latestSI = null;

  if (strengthIndexData.length > 0) {
    latestSI = strengthIndexData[strengthIndexData.length - 1];
  }

  // Header
  let html = `<div style="display:flex;align-items:baseline;justify-content:space-between;margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid #2a2a2e;">
    <div style="font-family:'Space Grotesk',sans-serif;font-size:32px;font-weight:700;color:#818cf8;">${latestSI ? latestSI.index.toFixed(2) : '--'}</div>
    <div style="font-family:'Space Grotesk',sans-serif;font-size:13px;color:#8e8e98;">Strength Score</div>
  </div>`;

  // Column labels (no %ile column)
  html += `<div style="display:flex;align-items:center;gap:10px;padding:0 0 6px 0;">
    <div style="width:58px;font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:#8e8e98;font-family:'Space Grotesk',sans-serif;flex-shrink:0;">Lift</div>
    <div style="flex:1;font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:#8e8e98;font-family:'Space Grotesk',sans-serif;text-align:center;">Percentile</div>
    <div style="width:56px;font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:#8e8e98;font-family:'Space Grotesk',sans-serif;text-align:right;flex-shrink:0;">Est 1RM</div>
  </div>`;

  // Lift rows
  for (const [key, info] of Object.entries(liftBenchmarks)) {
    const lift = latestSI ? latestSI.lifts[key] : null;
    const hasData = lift && lift.rm > 0;
    let pctile = 0;
    let pctColor = '#8e8e98';
    let markerColor = '#8e8e98';
    let weightStr = '--';

    if (hasData) {
      pctile = estimatePercentile(info.std, lift.mult);
      pctColor = pctile >= 50 ? '#4ade80' : pctile >= 25 ? '#fb923c' : '#f87171';
      markerColor = pctColor;
      weightStr = `${lift.rm}`;
    }

    const markerLeft = hasData ? Math.max(2, Math.min(98, pctile)) : 0;

    html += `<div style="display:flex;align-items:center;gap:10px;padding:9px 0;border-bottom:1px solid #1a1a1e;">
      <div style="width:58px;font-size:16px;font-weight:600;color:#f4f4f6;flex-shrink:0;">${info.label}</div>
      <div data-str-bar style="flex:1;height:14px;border-radius:3px;background:#222226;position:relative;overflow:visible;cursor:pointer;-webkit-tap-highlight-color:transparent;" onclick="showStrengthPctile(this)">
        <div style="position:absolute;top:4px;left:0;right:0;height:6px;border-radius:3px;background:linear-gradient(90deg,#f87171 0%,#fb923c 40%,#4ade80 100%);opacity:0.3;"></div>
        ${hasData ? `<div style="position:absolute;top:50%;left:${markerLeft}%;width:10px;height:10px;border-radius:50%;background:${markerColor};transform:translate(-50%,-50%);border:1.5px solid #131315;pointer-events:none;"></div>` : ''}
        ${hasData ? `<div data-pctile-tip style="position:absolute;top:50%;left:${markerLeft}%;background:${pctColor};color:#0a0a0a;font-family:'Space Grotesk',sans-serif;font-size:11px;font-weight:700;padding:2px 6px;border-radius:4px;pointer-events:none;white-space:nowrap;opacity:0;transform:translate(-50%,-50%) scale(0.7);transition:opacity 0.2s ease,transform 0.2s ease;z-index:5;">${pctile}th</div>` : ''}
      </div>
      <div style="width:56px;font-family:'Space Grotesk',sans-serif;font-size:12px;color:#8e8e98;text-align:right;flex-shrink:0;">${weightStr}<span style="font-size:10px;color:#6e6e78;"> lbs</span></div>
    </div>`;
  }

  container.innerHTML = html;
}

// ============================================================
// WEIGHT INPUT
// ============================================================
function toggleWeightForm() {
  const form = document.getElementById('weight-input-form');
  form.classList.toggle('open');
  if (form.classList.contains('open')) {
    const input = document.getElementById('weight-input');
    const dateInput = document.getElementById('weight-date-input');
    input.value = '';
    dateInput.value = new Date().toISOString().split('T')[0];
    input.focus();
  }
}

function saveWeight() {
  const input = document.getElementById('weight-input');
  const dateInput = document.getElementById('weight-date-input');
  const val = parseFloat(input.value);
  if (isNaN(val) || val < 50 || val > 500) {
    input.style.borderColor = '#f87171';
    setTimeout(() => { input.style.borderColor = '#2a2a2e'; }, 1500);
    return;
  }
  const entryDate = dateInput.value || new Date().toISOString().split('T')[0];
  saveWeightEntry(entryDate, val);
  toggleWeightForm();
  renderWeightChart();
}

// ============================================================
// BODY MEASUREMENTS UI (v1.7 Phase 2)
// ============================================================

function toggleMeasureForm() {
  const formEl = document.getElementById('measure-input-form');
  const isOpen = formEl.style.display === 'block';
  if (isOpen) {
    formEl.style.display = 'none';
    return;
  }

  const latest = getLatestMeasurements();
  let html = `<div style="margin-bottom:10px;">
    <label style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:1px;color:#8e8e98;font-family:'Space Grotesk',sans-serif;display:block;margin-bottom:4px;">Date</label>
    <input type="date" id="meas-date" value="${new Date().toISOString().split('T')[0]}" style="width:100%;padding:7px 10px;font-size:15px;font-family:'Space Grotesk',sans-serif;background:#131315;color:#f4f4f6;border:1px solid #2a2a2e;border-radius:7px;outline:none;-webkit-appearance:none;">
  </div>`;
  html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">`;

  for (const field of MEASUREMENT_FIELDS) {
    const prev = latest ? latest[field.key] : null;
    const prefill = prev ? prev.toFixed(1) : '';
    html += `<div>
      <label style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:1px;color:#8e8e98;font-family:'Space Grotesk',sans-serif;display:block;margin-bottom:4px;">${field.label}</label>
      <input type="number" id="meas-${field.key}" value="${prefill}" placeholder="${field.placeholder}" step="0.1" inputmode="decimal"
        style="width:100%;padding:7px 10px;font-size:15px;font-family:'Space Grotesk',sans-serif;background:#131315;color:#f4f4f6;border:1px solid #2a2a2e;border-radius:7px;outline:none;-webkit-appearance:none;">
    </div>`;
  }

  html += `</div>`;
  html += `<div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
    <button onclick="toggleMeasureForm()" style="padding:7px 10px;font-size:13px;background:none;color:#8e8e98;border:none;cursor:pointer;font-family:'Figtree',sans-serif;">Cancel</button>
    <button onclick="saveMeasurements()" style="padding:7px 14px;font-size:13px;font-weight:600;background:#4ade80;color:#0a0a0a;border:none;border-radius:7px;cursor:pointer;font-family:'Figtree',sans-serif;">Save</button>
  </div>`;

  formEl.innerHTML = html;
  formEl.style.display = 'block';
}

function saveMeasurements() {
  const dateInput = document.getElementById('meas-date');
  const entryDate = (dateInput && dateInput.value) ? dateInput.value : new Date().toISOString().split('T')[0];
  const entry = { date: entryDate };
  let hasValue = false;

  for (const field of MEASUREMENT_FIELDS) {
    const input = document.getElementById(`meas-${field.key}`);
    if (!input) continue;
    const val = parseFloat(input.value);
    if (!isNaN(val) && val > 0 && val < 100) {
      entry[field.key] = val;
      hasValue = true;
    }
  }

  if (!hasValue) return;

  saveMeasurementEntry(entry);
  toggleMeasureForm();

  // Refresh proportion data and re-render
  latestMeasurements = getLatestMeasurements();
  proportionDeficits = computeProportionDeficits(latestMeasurements);
  renderMeasurementsDisplay();
  renderProportionsDisplay();

  // Re-run recommendations since proportion data changed
  if (workoutCache && muscleAnalysis) {
    const recs = generateRecommendations(muscleAnalysis);
    LAST_RECS = recs;
    renderTimedSession(recs);
    renderMuscleGrid(muscleAnalysis, recs);
  }
}

function renderMeasurementsDisplay() {
  const container = document.getElementById('measurements-display');
  if (!container) return;
  const latest = latestMeasurements;

  if (!latest) {
    container.innerHTML = `<div style="font-size:13px;color:#8e8e98;font-family:'Space Grotesk',sans-serif;padding:4px 0;">No measurements logged yet. Tap "+ Measure" to start tracking.</div>`;
    return;
  }

  let html = `<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;">`;
  let hasAny = false;
  for (const field of MEASUREMENT_FIELDS) {
    const val = latest[field.key];
    if (!val) continue;
    hasAny = true;
    const dateStr = latest._dates ? latest._dates[field.key] : '';
    const daysAgo = dateStr ? Math.floor((Date.now() - new Date(dateStr + 'T12:00:00').getTime()) / (1000 * 60 * 60 * 24)) : null;
    const stale = daysAgo !== null && daysAgo > 90;
    const ageLabel = daysAgo === 0 ? 'today' : daysAgo !== null ? `${daysAgo}d ago` : '';
    const ageColor = stale ? '#fb923c' : '#6e6e78';

    html += `<div style="padding:10px;border-radius:8px;border:1px solid #2a2a2e;background:#1a1a1e;">
      <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:1px;color:#8e8e98;font-family:'Space Grotesk',sans-serif;margin-bottom:4px;">${field.label}</div>
      <div style="font-family:'Space Grotesk',sans-serif;font-size:20px;font-weight:700;color:#f4f4f6;line-height:1.2;">${val.toFixed(1)}<span style="font-size:11px;font-weight:400;color:#8e8e98;margin-left:2px;">${field.unit}</span></div>
      <div style="font-size:10px;font-family:'Space Grotesk',sans-serif;color:${ageColor};margin-top:2px;">${ageLabel}</div>
    </div>`;
  }
  html += `</div>`;

  if (!hasAny) {
    container.innerHTML = `<div style="font-size:13px;color:#8e8e98;font-family:'Space Grotesk',sans-serif;padding:4px 0;">No measurements logged yet. Tap "+ Measure" to start tracking.</div>`;
    return;
  }
  container.innerHTML = html;
}

function renderProportionsDisplay() {
  const container = document.getElementById('proportions-display');
  if (!container) return;
  const latest = latestMeasurements;
  const deficits = proportionDeficits;

  if (!latest || Object.keys(deficits).length === 0) {
    container.innerHTML = '';
    return;
  }

  let html = `<div style="padding-top:12px;border-top:1px solid #2a2a2e;">
    <div style="font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:1.5px;color:#8e8e98;margin-bottom:10px;font-family:'Space Grotesk',sans-serif;">Proportion Analysis</div>`;

  for (const rule of PROPORTION_RULES) {
    const hasDeps = rule.requires.every(k => latest[k] != null && latest[k] > 0);
    if (!hasDeps) continue;

    const actual = rule.compute(latest);
    const target = rule.targetRatio || 1.0;
    const deficit = deficits[rule.muscle] || 0;

    let statusColor, statusLabel;
    if (deficit <= 0.05) { statusColor = '#4ade80'; statusLabel = 'Balanced'; }
    else if (deficit <= 0.15) { statusColor = '#fb923c'; statusLabel = 'Slight gap'; }
    else { statusColor = '#f87171'; statusLabel = 'Lagging'; }

    const muscleName = MUSCLE_GROUPS[rule.muscle] ? MUSCLE_GROUPS[rule.muscle].name : rule.muscle;
    const barPct = Math.max(3, Math.min(100, Math.round((1 - deficit) * 100)));

    // Show actual values for context
    const vals = rule.requires.map(k => {
      const f = MEASUREMENT_FIELDS.find(mf => mf.key === k);
      return `${f ? f.label : k}: ${latest[k].toFixed(1)}"`;
    }).join(' Â· ');

    html += `<div style="padding:8px 0;border-bottom:1px solid #1a1a1e;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
        <span style="font-size:13px;font-weight:600;color:#f4f4f6;">${muscleName}</span>
        <span style="font-size:11px;font-weight:600;font-family:'Space Grotesk',sans-serif;color:${statusColor};">${statusLabel}</span>
      </div>
      <div style="height:4px;border-radius:2px;background:#222226;overflow:hidden;">
        <div style="height:100%;width:${barPct}%;border-radius:2px;background:${statusColor};transition:width 0.4s ease;"></div>
      </div>
      <div style="font-size:11px;font-family:'Space Grotesk',sans-serif;color:#6e6e78;margin-top:3px;">${rule.label}: ${actual.toFixed(2)} (target ${target.toFixed(2)}) Â· ${vals}</div>
    </div>`;
  }

  html += `</div>`;
  container.innerHTML = html;
}

function renderMeasurementsCard() {
  renderMeasurementsDisplay();
  renderProportionsDisplay();
}

// ============================================================
// APPLE HEALTH DATA (fetched from repo via iOS Shortcut push)
// ============================================================
const HEALTH_DATA_URL = 'https://jtwarta.github.io/WorkoutPlanner/health-data.json';
const HEALTH_STALE_HOURS = 48; // consider data stale after 48h

async function fetchHealthData() {
  try {
    const resp = await fetch(HEALTH_DATA_URL + '?t=' + Date.now(), { cache: 'no-store' });
    if (!resp.ok) {
      healthStatus = 'missing';
      healthData = null;
      return;
    }
    // Shortcuts inserts literal newlines in JSON - strip them before parsing
    const rawText = await resp.text();
    const cleanText = rawText.replace(/\n/g, '').replace(/\r/g, '');
    const data = JSON.parse(cleanText);
    healthData = data;

    // Check freshness
    if (data.updated) {
      const updatedAt = new Date(data.updated);
      const ageHours = (Date.now() - updatedAt.getTime()) / (1000 * 60 * 60);
      healthStatus = ageHours <= HEALTH_STALE_HOURS ? 'ok' : 'stale';
    } else {
      healthStatus = 'stale';
    }
  } catch (e) {
    console.warn('Health data fetch failed:', e.message);
    healthStatus = 'missing';
    healthData = null;
  }
}

function getHealthStatusTitle() {
  if (healthStatus === 'ok') {
    const ago = healthData && healthData.updated
      ? Math.round((Date.now() - new Date(healthData.updated).getTime()) / (1000 * 60 * 60)) + 'h ago'
      : '';
    return `Apple Health: synced ${ago}`;
  }
  if (healthStatus === 'stale') return 'Apple Health: data is stale (>48h)';
  if (healthStatus === 'missing') return 'Apple Health: no data found';
  return 'Apple Health: loading...';
}

// ============================================================
// VO2 MAX / CARDIO FITNESS PERCENTILES
// ACSM norms for males, interpolated for age
// Percentile: [10th, 25th, 50th, 75th, 90th]
// ============================================================
const VO2_NORMS_MALE = {
  '20-29': [33.0, 36.5, 42.5, 46.8, 52.4],
  '30-39': [30.2, 34.0, 38.5, 43.0, 48.0],
  '40-49': [27.0, 31.0, 35.5, 39.5, 44.0],
  '50-59': [24.0, 28.0, 32.5, 36.5, 41.0],
};

function getVO2AgeGroup(age) {
  if (age < 30) return '20-29';
  if (age < 40) return '30-39';
  if (age < 50) return '40-49';
  return '50-59';
}

function estimateVO2Percentile(vo2, age) {
  const group = getVO2AgeGroup(age);
  const norms = VO2_NORMS_MALE[group];
  if (!norms) return null;

  const pctiles = [10, 25, 50, 75, 90];
  if (vo2 <= norms[0]) return Math.max(1, Math.round((vo2 / norms[0]) * 10));
  if (vo2 >= norms[4]) return Math.min(99, 90 + Math.round(((vo2 - norms[4]) / (norms[4] * 0.15)) * 9));

  for (let i = 0; i < norms.length - 1; i++) {
    if (vo2 >= norms[i] && vo2 <= norms[i + 1]) {
      const frac = (vo2 - norms[i]) / (norms[i + 1] - norms[i]);
      return Math.round(pctiles[i] + frac * (pctiles[i + 1] - pctiles[i]));
    }
  }
  return 50;
}

function getVO2Category(percentile) {
  if (percentile >= 80) return { label: 'Excellent', color: '#4ade80' };
  if (percentile >= 60) return { label: 'Good', color: '#60a5fa' };
  if (percentile >= 40) return { label: 'Fair', color: '#fb923c' };
  if (percentile >= 20) return { label: 'Below Avg', color: '#f87171' };
  return { label: 'Low', color: '#f87171' };
}

function getRHRCategory(rhr) {
  if (rhr < 60) return { label: 'Athletic', color: '#4ade80' };
  if (rhr <= 70) return { label: 'Good', color: '#60a5fa' };
  if (rhr <= 80) return { label: 'Normal', color: '#bcbcc4' };
  return { label: 'Elevated', color: '#f87171' };
}

function getRecoveryCategory(recovery) {
  if (recovery >= 30) return { label: 'Excellent', color: '#4ade80' };
  if (recovery >= 20) return { label: 'Good', color: '#60a5fa' };
  if (recovery >= 12) return { label: 'Normal', color: '#bcbcc4' };
  return { label: 'Low', color: '#f87171' };
}

// ============================================================
// RENDER HEALTH VITALS
// ============================================================
function renderHealthVitals() {
  const card = document.getElementById('health-vitals-card');
  if (!healthData || healthStatus === 'missing') {
    card.style.display = 'none';
    return;
  }
  card.style.display = 'block';

  // Sync time
  const syncEl = document.getElementById('health-sync-time');
  if (healthData.updated) {
    const hrs = Math.round((Date.now() - new Date(healthData.updated).getTime()) / (1000 * 60 * 60));
    syncEl.textContent = hrs <= 1 ? 'just now' : `${hrs}h ago`;
    syncEl.style.color = healthStatus === 'ok' ? '#4ade80' : '#fb923c';
  }

  // Cardio Fitness Score (VO2 Max)
  const vo2 = healthData.cardio_fitness;
  if (vo2 && vo2 > 0) {
    const pctile = estimateVO2Percentile(vo2, PROFILE.age);
    const cat = getVO2Category(pctile);
    const barPct = Math.min(Math.max(pctile, 3), 97);

    document.getElementById('cardio-score-value').textContent = vo2.toFixed(1);
    const labelEl = document.getElementById('cardio-score-label');
    labelEl.textContent = `${pctile}th %ile \u00b7 ${cat.label}`;
    labelEl.style.color = cat.color;

    const bar = document.getElementById('cardio-score-bar');
    bar.style.width = barPct + '%';
    bar.style.background = cat.color;

    document.getElementById('cardio-score-row').style.display = 'block';
  } else {
    document.getElementById('cardio-score-row').style.display = 'none';
  }

  // Vitals Grid
  const grid = document.getElementById('vitals-grid');
  let html = '';

  // RHR
  const rhr = healthData.resting_heart_rate;
  if (rhr && rhr > 0) {
    const rhrCat = getRHRCategory(rhr);
    html += `<div class="vital-cell">
      <div class="vital-label">Resting HR</div>
      <div class="vital-value">${Math.round(rhr)}<span class="vital-unit">bpm</span></div>
      <div class="vital-context" style="color:${rhrCat.color}">${rhrCat.label}</div>
    </div>`;
  }

  // Cardio Recovery
  const recovery = healthData.cardio_recovery;
  if (recovery && recovery > 0) {
    const recCat = getRecoveryCategory(recovery);
    html += `<div class="vital-cell">
      <div class="vital-label">HR Recovery</div>
      <div class="vital-value">${Math.round(recovery)}<span class="vital-unit">bpm</span></div>
      <div class="vital-context" style="color:${recCat.color}">${recCat.label}</div>
    </div>`;
  }

  // Steps (7-day avg)
  const steps = healthData.steps;
  if (steps && steps > 0) {
    const stepsK = steps >= 1000 ? (steps / 1000).toFixed(1) + 'k' : Math.round(steps);
    const stepsColor = steps >= 10000 ? '#4ade80' : steps >= 7000 ? '#60a5fa' : '#bcbcc4';
    html += `<div class="vital-cell">
      <div class="vital-label">Steps/Day</div>
      <div class="vital-value">${stepsK}</div>
      <div class="vital-context" style="color:${stepsColor}">${steps >= 10000 ? 'Active' : steps >= 7000 ? 'Moderate' : 'Low'}</div>
    </div>`;
  }

  // Active Calories
  const cal = healthData.active_energy_kcal;
  if (cal && cal > 0) {
    html += `<div class="vital-cell">
      <div class="vital-label">Active Cal</div>
      <div class="vital-value">${Math.round(cal)}<span class="vital-unit">kcal</span></div>
      <div class="vital-context">7-day avg</div>
    </div>`;
  }

  // Walking HR
  const whr = healthData.walking_heart_rate_avg;
  if (whr && whr > 0) {
    const whrColor = whr < 100 ? '#4ade80' : whr <= 110 ? '#bcbcc4' : '#fb923c';
    html += `<div class="vital-cell">
      <div class="vital-label">Walking HR</div>
      <div class="vital-value">${Math.round(whr)}<span class="vital-unit">bpm</span></div>
      <div class="vital-context" style="color:${whrColor}">${whr < 100 ? 'Good' : whr <= 110 ? 'Normal' : 'Elevated'}</div>
    </div>`;
  }

  grid.innerHTML = html;
}

// ============================================================
// TAB SWITCHING
// ============================================================
function switchTab(tab) {
  document.querySelectorAll('[id^="tab-"]').forEach(el => el.classList.add('hidden'));
  document.getElementById(`tab-${tab}`).classList.remove('hidden');
  document.querySelectorAll('.tab').forEach(el => {
    el.classList.toggle('active', el.dataset.tab === tab);
  });
  if (tab === 'weight') {
    setTimeout(renderWeightChart, 50);
    setTimeout(renderHealthVitals, 50);
    setTimeout(renderMeasurementsCard, 50);
  }
}

// ============================================================
// APP LIFECYCLE
// ============================================================
function showScreen(screen) {
  ['loading-screen', 'dashboard'].forEach(id => {
    document.getElementById(id).classList.toggle('hidden', id !== screen);
  });
}

function updateLoading(text) {
  document.getElementById('loading-text').textContent = text;
}

function showError(msg) {
  const tabs = document.querySelector('.tabs');
  // Remove any existing error
  const existing = document.getElementById('inline-error');
  if (existing) existing.remove();
  // Insert error after tabs
  const errDiv = document.createElement('div');
  errDiv.id = 'inline-error';
  errDiv.className = 'error-msg';
  errDiv.innerHTML = msg;
  errDiv.style.margin = '0 0 14px 0';
  tabs.insertAdjacentElement('afterend', errDiv);
}

// Render dashboard from workouts data (shared by cache + fresh load)
function renderDashboard(workouts) {
  WEIGHT_DATA = getMergedWeightData();
  if (WEIGHT_DATA.length > 0) PROFILE.bodyweightLbs = WEIGHT_DATA[0].value;

  // v1.7: Load measurements and compute proportion deficits before recommendations
  latestMeasurements = getLatestMeasurements();
  proportionDeficits = computeProportionDeficits(latestMeasurements);

  // v1.1 Task 6: unified preprocess pipeline
  const pp = preprocessWorkouts(workouts, PROFILE.bodyweightLbs);

  exerciseHistory = pp.exerciseHistory;
  muscleAnalysis = pp.muscleStats;
  muscle1RMs = pp.muscle1RMs;
  strengthIndexData = pp.strengthIndexTimeline;

  const recs = generateRecommendations(pp.muscleStats);
  LAST_RECS = recs;

  showScreen('dashboard');

  const now = new Date();
  const syncColor = (hevyStatus === 'ok' && healthStatus === 'ok') ? '#4ade80'
    : (hevyStatus === 'error' || healthStatus === 'missing') ? '#8e8e98' : '#fb923c';
  document.getElementById('last-updated').innerHTML =
    `v1.8 \u00b7 ${now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })} <span style="display:inline-block;width:7px;height:7px;border-radius:50%;background:${syncColor};margin-left:5px;vertical-align:middle;position:relative;top:-1px;"></span>`;

  renderConstraintChips();
  renderTimedSession(recs);
  renderMuscleGrid(pp.muscleStats, recs);
  renderHeatmap(pp.heatmapDayMuscle, pp.heatmapDayWorkouts);
  renderWeightChart();
  renderHealthVitals();
  renderMeasurementsCard();
  renderCardioPlan(workouts);
}

async function refreshData() {
  showScreen('loading-screen');
  try {
    updateLoading('Refreshing...');
    const [workouts] = await Promise.all([fetchWorkouts(10, 10), fetchHealthData()]);
    workoutCache = workouts;
    setCachedWorkouts(workouts);
    hevyStatus = 'ok';
    renderDashboard(workouts);
  } catch (err) {
    console.error(err);
    hevyStatus = 'error';
    showScreen('dashboard');
    showError(`Refresh failed: ${err.message}`);
  }
}

async function loadDashboard() {
  showScreen('loading-screen');

  // Start health data fetch in parallel (non-blocking)
  const healthPromise = fetchHealthData();

  try {
    // v1.1 Task 7: Try cache first for instant load
    const cached = getCachedWorkouts();
    if (cached && cached.data && cached.data.length > 0) {
      updateLoading('Loading from cache...');
      workoutCache = cached.data;
      hevyStatus = 'ok';
      await healthPromise; // ensure health status is ready
      renderDashboard(cached.data);

      // If stale, refresh in background
      if (isCacheStale(cached)) {
        fetchWorkouts(10, 10).then(fresh => {
          workoutCache = fresh;
          setCachedWorkouts(fresh);
          hevyStatus = 'ok';
          renderDashboard(fresh);
        }).catch(err => {
          console.warn('Background refresh failed:', err.message);
          hevyStatus = 'error';
        });
      }
      return;
    }

    // No cache - fresh load
    updateLoading('Loading workouts...');
    const workouts = await fetchWorkouts(10, 10);
    workoutCache = workouts;
    setCachedWorkouts(workouts);
    hevyStatus = 'ok';
    await healthPromise;
    renderDashboard(workouts);
  } catch (err) {
    console.error(err);
    hevyStatus = 'error';
    showScreen('dashboard');
    showError(`Failed to load: ${err.message}`);
  }
}

// ============================================================
// DEV TEST HARNESS (guarded behind flag — never runs in production)
// ============================================================
const DEV_TEST_MODE = false;

function runDevTests() {
  if (!DEV_TEST_MODE) return;
  const results = [];

  // Test A1: Tricep Dip classification
  const tricepDip = classifyExercise('Tricep Dip');
  results.push({ test: 'A1: Tricep Dip → triceps', pass: tricepDip.primary === 'triceps', got: tricepDip.primary });

  const chestDip = classifyExercise('Chest Dip');
  results.push({ test: 'A1: Chest Dip → chest', pass: chestDip.primary === 'chest', got: chestDip.primary });

  const genericDip = classifyExercise('Dips');
  results.push({ test: 'A1: Dips → chest (generic)', pass: genericDip.primary === 'chest', got: genericDip.primary });

  // Test A2: Curly apostrophe normalization
  const curly1 = normalizeExerciseName('Farmer\u2019s Carry');
  results.push({ test: 'A2: Right curly → ASCII', pass: curly1 === "farmer's carry", got: curly1 });
  const curly2 = normalizeExerciseName('Farmer\u2018s Carry');
  results.push({ test: 'A2: Left curly → ASCII', pass: curly2 === "farmer's carry", got: curly2 });

  // Test A3: Cardio session counting (mock workout with 2 cardio exercises)
  const mockWorkouts = [{
    start_time: new Date().toISOString(),
    exercises: [
      { title: 'Treadmill', sets: [{ duration_seconds: 1200 }] },
      { title: 'Elliptical', sets: [{ duration_seconds: 900 }] },
    ]
  }];
  const cardioResult = analyzeCardioHistory(mockWorkouts);
  results.push({ test: 'A3: 2 cardio exercises = 1 session', pass: cardioResult.cardioSessions7d === 1, got: cardioResult.cardioSessions7d });

  // Report
  console.group('🧪 LiftScript Dev Tests');
  for (const r of results) {
    console.log(`${r.pass ? '✅' : '❌'} ${r.test}${r.pass ? '' : ' (got: ' + r.got + ')'}`);
  }
  console.groupEnd();
}

runDevTests();

// Boot
loadDashboard();
</script>
</body>
</html>
