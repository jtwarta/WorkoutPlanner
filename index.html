<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0a">
<title>Workout Advisor</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0a;
  --surface: #131315;
  --surface2: #1a1a1e;
  --surface3: #222226;
  --border: #2a2a2e;
  --border-light: #333338;
  --text: #f4f4f6;
  --text-mid: #bcbcc4;
  --text-dim: #8e8e98;
  --accent: #4ade80;
  --accent-dim: rgba(74, 222, 128, 0.12);
  --warn: #fb923c;
  --warn-dim: rgba(251, 146, 60, 0.12);
  --danger: #f87171;
  --danger-dim: rgba(248, 113, 113, 0.12);
  --blue: #60a5fa;
  --blue-dim: rgba(96, 165, 250, 0.12);
  --purple: #c084fc;
  --purple-dim: rgba(192, 132, 252, 0.12);
  --strength: #818cf8;
  --strength-dim: rgba(129, 140, 248, 0.12);
  color-scheme: dark;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  background: #0a0a0a;
  background-color: #0a0a0a;
  color-scheme: dark;
}

body {
  font-family: 'Figtree', -apple-system, sans-serif;
  color: var(--text);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  line-height: 1.5;
}

.mono { font-family: 'JetBrains Mono', monospace; }

/* Layout */
.app {
  max-width: 480px;
  margin: 0 auto;
  padding: 20px 18px;
  padding-bottom: 120px;
  background: #0a0a0a;
}

/* Header */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0 16px;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--border);
}
.header h1 {
  font-size: 22px;
  font-weight: 700;
  letter-spacing: -0.5px;
  color: var(--text);
}
.header .subtitle {
  font-size: 12px;
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
  margin-top: 2px;
}
.btn-refresh {
  padding: 7px 14px;
  font-size: 13px;
  font-weight: 500;
  background: var(--surface2);
  color: var(--text-mid);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
  transition: all 0.2s ease;
  -webkit-tap-highlight-color: transparent;
}
.btn-refresh:active {
  background: var(--surface3);
  transform: scale(0.97);
}

/* Cards */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 18px;
  margin-bottom: 14px;
}
.card-title {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
}

/* Tabs */
.tabs {
  display: flex;
  gap: 4px;
  margin-bottom: 18px;
  background: var(--surface);
  border-radius: 12px;
  padding: 4px;
  border: 1px solid var(--border);
}
.tab {
  flex: 1;
  padding: 9px 6px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  border-radius: 9px;
  cursor: pointer;
  color: var(--text-dim);
  transition: all 0.25s ease;
  border: none;
  background: none;
  font-family: 'Figtree', sans-serif;
  -webkit-tap-highlight-color: transparent;
}
.tab.active {
  background: var(--surface3);
  color: var(--text);
}

/* ===================== */
/* RECOMMENDATIONS       */
/* ===================== */
.rec-item {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: background 0.15s ease;
}
.rec-item:last-child { border-bottom: none; }
.rec-item:active { background: var(--surface2); }

.rec-row {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 14px 2px;
}
.rec-rank {
  font-family: 'JetBrains Mono', monospace;
  font-size: 16px;
  font-weight: 600;
  color: var(--accent);
  width: 24px;
  text-align: center;
  flex-shrink: 0;
}
.rec-info { flex: 1; min-width: 0; }
.rec-name {
  font-size: 17px;
  font-weight: 600;
  line-height: 1.3;
  color: var(--text);
}
.rec-detail {
  font-size: 14px;
  color: var(--text-mid);
  margin-top: 3px;
  font-family: 'JetBrains Mono', monospace;
}
.rec-urgency {
  font-size: 11px;
  font-weight: 600;
  padding: 5px 10px;
  border-radius: 6px;
  font-family: 'JetBrains Mono', monospace;
  flex-shrink: 0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.urgency-high { background: var(--danger-dim); color: var(--danger); }
.urgency-med { background: var(--warn-dim); color: var(--warn); }
.urgency-low { background: var(--accent-dim); color: var(--accent); }

/* Expandable explainer */
.rec-expand {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
}
.rec-expand.open {
  opacity: 1;
}
.rec-explainer {
  padding: 0 2px 14px 40px;
  font-size: 14px;
  color: var(--text-mid);
  line-height: 1.55;
}
.rec-explainer strong {
  color: var(--text);
  font-weight: 600;
}

/* ===================== */
/* EXERCISE PRESCRIPTIONS */
/* ===================== */
.session-summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--border);
}
.session-time {
  font-family: 'JetBrains Mono', monospace;
  font-size: 15px;
  font-weight: 600;
  color: var(--accent);
}
.session-count {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--text-dim);
}

.ex-group {
  margin-bottom: 18px;
}
.ex-group:last-child { margin-bottom: 0; }
.ex-group-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border);
}
.ex-row {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  padding: 8px 0;
}
.ex-name {
  font-size: 15px;
  font-weight: 500;
  flex: 1;
  min-width: 0;
  padding-right: 12px;
  color: var(--text);
}
.ex-prescription {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--accent);
  white-space: nowrap;
  flex-shrink: 0;
}
.ex-time {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--text-dim);
  white-space: nowrap;
  flex-shrink: 0;
  margin-left: 8px;
  min-width: 38px;
  text-align: right;
}

/* ===================== */
/* MUSCLE GRID           */
/* ===================== */
.muscle-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.muscle-cell {
  border-radius: 10px;
  padding: 12px;
  transition: all 0.3s ease;
  border: 1px solid var(--border);
}
.muscle-name {
  font-size: 14px;
  font-weight: 600;
}
.muscle-stat {
  font-size: 12px;
  color: var(--text-mid);
  font-family: 'JetBrains Mono', monospace;
  margin-top: 5px;
}
.muscle-percentile {
  font-size: 11px;
  font-weight: 600;
  font-family: 'JetBrains Mono', monospace;
  margin-top: 4px;
  opacity: 0.9;
}
.muscle-bar {
  height: 4px;
  background: rgba(255,255,255,0.08);
  border-radius: 3px;
  margin-top: 8px;
  overflow: hidden;
}
.muscle-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s ease;
}

/* ===================== */
/* WEIGHT TAB            */
/* ===================== */
.weight-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-bottom: 18px;
}
.weight-left {
  display: flex;
  align-items: baseline;
  gap: 8px;
}
.weight-chart {
  width: 100%;
  height: 150px;
  position: relative;
}
.weight-chart canvas { width: 100%; height: 100%; }
.weight-current {
  font-family: 'JetBrains Mono', monospace;
  font-size: 32px;
  font-weight: 700;
  letter-spacing: -1px;
  color: var(--text);
}
.weight-delta {
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
}
.weight-unit {
  font-size: 14px;
  color: var(--text-dim);
}
.strength-index-display {
  font-family: 'JetBrains Mono', monospace;
  font-size: 15px;
  font-weight: 600;
  color: var(--strength);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  padding: 6px 12px;
  background: var(--strength-dim);
  border: 1px solid rgba(129, 140, 248, 0.25);
  border-radius: 8px;
}
.strength-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
}
.strength-detail.open {
  opacity: 1;
}
.strength-detail-inner {
  padding: 12px 0 4px;
  font-size: 13px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
  line-height: 1.7;
}
.chart-legend {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
}
.legend-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 5px;
  vertical-align: middle;
}

/* Weight input form */
.btn-log-weight {
  padding: 5px 12px;
  font-size: 13px;
  font-weight: 600;
  background: var(--accent-dim);
  color: var(--accent);
  border: 1px solid rgba(74, 222, 128, 0.25);
  border-radius: 7px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.2s ease;
}
.btn-log-weight:active {
  transform: scale(0.96);
}
.weight-input-form {
  display: none;
  align-items: center;
  gap: 8px;
  margin-bottom: 14px;
  padding: 12px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
}
.weight-input-form.open {
  display: flex;
}
.weight-input-form input {
  width: 90px;
  padding: 7px 10px;
  font-size: 15px;
  font-family: 'JetBrains Mono', monospace;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 7px;
  outline: none;
  -webkit-appearance: none;
}
.weight-input-form input:focus {
  border-color: var(--accent);
}
.weight-input-form .btn-save {
  padding: 7px 14px;
  font-size: 13px;
  font-weight: 600;
  background: var(--accent);
  color: #0a0a0a;
  border: none;
  border-radius: 7px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
}
.weight-input-form .btn-cancel {
  padding: 7px 10px;
  font-size: 13px;
  background: none;
  color: var(--text-dim);
  border: none;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
}

/* ===================== */
/* HISTORY - HEATMAP     */
/* ===================== */
.heatmap-container {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  margin: 0 -4px;
  padding: 0 4px;
}
.heatmap-grid {
  display: grid;
  gap: 3px;
  min-width: max-content;
}
.heatmap-label {
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
  display: flex;
  align-items: center;
  padding-right: 6px;
  white-space: nowrap;
  position: sticky;
  left: 0;
  background: var(--surface);
  z-index: 2;
}
.heatmap-cell {
  width: 18px;
  height: 18px;
  border-radius: 3px;
  background: var(--surface2);
  cursor: pointer;
  transition: opacity 0.15s ease;
}
.heatmap-cell:active {
  opacity: 0.7;
}
.heatmap-day-labels {
  font-size: 10px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-dim);
  display: flex;
  align-items: flex-end;
  padding-bottom: 4px;
  text-align: center;
}
.heatmap-day-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
  margin-top: 0;
}
.heatmap-day-detail.open {
  opacity: 1;
  margin-top: 12px;
}
.heatmap-day-detail-inner {
  padding: 14px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 14px;
  line-height: 1.6;
}
.heatmap-day-detail-inner .detail-date {
  font-weight: 600;
  margin-bottom: 8px;
  font-size: 13px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
}
.heatmap-day-detail-inner .detail-exercise {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  padding: 4px 0;
}
.heatmap-day-detail-inner .detail-name {
  font-weight: 500;
  font-size: 14px;
  color: var(--text);
}
.heatmap-day-detail-inner .detail-sets {
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--accent);
  flex-shrink: 0;
}

/* ===================== */
/* HISTORY (legacy)      */
/* ===================== */
.workout-item {
  padding: 10px 0;
  border-bottom: 1px solid var(--border);
}
.workout-item:last-child { border-bottom: none; }
.workout-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
}
.workout-meta {
  font-size: 13px;
  color: var(--text-mid);
  font-family: 'JetBrains Mono', monospace;
  margin-top: 3px;
  line-height: 1.4;
}

/* ===================== */
/* LOADING & ERROR       */
/* ===================== */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  gap: 18px;
}
.spinner {
  width: 28px; height: 28px;
  border: 2.5px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.75s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-text {
  font-size: 14px;
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
}
.error-msg {
  background: var(--danger-dim);
  border: 1px solid rgba(248,113,113,0.2);
  border-radius: 10px;
  padding: 14px;
  font-size: 14px;
  color: var(--danger);
  margin-bottom: 14px;
  line-height: 1.4;
}

.hidden { display: none; }
</style>
</head>
<body>
<div class="app" id="app">

  <!-- Loading Screen -->
  <div id="loading-screen" class="loading">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">Connecting to Hevy...</div>
  </div>

  <!-- Main Dashboard -->
  <div id="dashboard" class="hidden">
    <div class="header">
      <div>
        <h1>Workout Advisor</h1>
        <div class="subtitle" id="last-updated"></div>
      </div>
      <button class="btn-refresh" onclick="refreshData()">Refresh</button>
    </div>

    <div id="error-area"></div>

    <div class="tabs">
      <button class="tab active" data-tab="today" onclick="switchTab('today')">Today</button>
      <button class="tab" data-tab="muscles" onclick="switchTab('muscles')">Muscles</button>
      <button class="tab" data-tab="history" onclick="switchTab('history')">History</button>
      <button class="tab" data-tab="weight" onclick="switchTab('weight')">Weight</button>
    </div>

    <!-- Today Tab -->
    <div id="tab-today">
      <div class="card">
        <div class="card-title">Recommended Training</div>
        <div id="recommendations"></div>
      </div>
      <div class="card">
        <div class="card-title">Today's Session</div>
        <div id="session-summary"></div>
        <div id="suggested-exercises"></div>
      </div>
    </div>

    <!-- Muscles Tab -->
    <div id="tab-muscles" class="hidden">
      <div class="card">
        <div class="card-title">Muscle Group Status</div>
        <div id="muscle-grid" class="muscle-grid"></div>
      </div>
    </div>

    <!-- History Tab -->
    <div id="tab-history" class="hidden">
      <div class="card">
        <div class="card-title">Training Heatmap</div>
        <div class="heatmap-container" id="heatmap-container"></div>
        <div class="heatmap-day-detail" id="heatmap-day-detail">
          <div class="heatmap-day-detail-inner" id="heatmap-day-detail-inner"></div>
        </div>
      </div>
    </div>

    <!-- Weight Tab -->
    <div id="tab-weight" class="hidden">
      <div class="card">
        <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;">
          <span>Body Weight & Strength</span>
          <button class="btn-log-weight" onclick="toggleWeightForm()">+ Log</button>
        </div>
        <div class="weight-input-form" id="weight-input-form">
          <input type="number" id="weight-input" placeholder="lbs" step="0.1" inputmode="decimal">
          <button class="btn-save" onclick="saveWeight()">Save</button>
          <button class="btn-cancel" onclick="toggleWeightForm()">Cancel</button>
        </div>
        <div class="weight-header">
          <div class="weight-left">
            <span class="weight-current" id="weight-current">--</span>
            <span class="weight-delta" id="weight-delta"></span>
            <span class="weight-unit">lbs</span>
          </div>
          <div class="strength-index-display" id="strength-index-display" onclick="toggleStrengthDetail()">--</div>
        </div>
        <div class="strength-detail" id="strength-detail">
          <div class="strength-detail-inner" id="strength-detail-inner"></div>
        </div>
        <div class="weight-chart">
          <canvas id="weight-canvas"></canvas>
        </div>
        <div class="chart-legend">
          <span><span class="legend-dot" style="background:var(--accent)"></span>Weight</span>
          <span><span class="legend-dot" style="background:var(--strength)"></span>Strength Index</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// SCIENTIFIC FOUNDATION (Feature 3)
// ============================================================
// PILLAR 1: Volume-Hypertrophy Targets
// Source: Schoenfeld et al. (2017) "Dose-response relationship between weekly resistance
// training volume and increases in muscle mass: A systematic review and meta-analysis"
// - 10+ sets/week per muscle group produces significantly greater hypertrophy than <5 sets
// Source: Schoenfeld (2016) frequency meta-analysis
// - Training each muscle 2x/week is superior to 1x/week for hypertrophy
// Ideal volumes below reflect intermediate programming (~10-16 sets/week per muscle group)

// PILLAR 2: Strength Standards / Percentile Benchmarks
// Big Three (bench, squat, deadlift): van den Hoek et al. (2024) "Normative data for the
// squat, bench press and deadlift" — 809,986 drug-tested competition entries from OpenPowerlifting
// Accessory lifts (OHP, curl, row, etc.): Approximate estimates from StrengthLevel.com data
// and general intermediate standards (Rippetoe, Henriques). Marked as approximate.

// PILLAR 3: 1RM Estimation
// Brzycki formula: 1RM = weight x (36 / (37 - reps)) — valid for 1-10 rep sets
// Epley formula: 1RM = weight x (1 + reps / 30) — used for sets >10 reps
// Source: Brzycki (1993), Epley (1985)

// PILLAR 4: Progressive Overload
// Current logic: +5% if below 85% of benchmark, +2.5% if at/above benchmark
// NSCA guideline: "Increase load 2-10% when target reps are achieved for 2 consecutive sessions"
// Round to nearest 5 lbs for practical plate loading

// ============================================================
// USER PROFILE (silent — never displayed)
// ============================================================
const PROFILE = {
  dob: new Date('1989-07-21'),
  sex: 'male',
  ethnicity: 'caucasian',
  bodyweightLbs: 166,
  get age() {
    const today = new Date();
    let age = today.getFullYear() - this.dob.getFullYear();
    const m = today.getMonth() - this.dob.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < this.dob.getDate())) age--;
    return age;
  },
  get bodyweightKg() { return this.bodyweightLbs * 0.453592; }
};

// ============================================================
// STRENGTH STANDARDS (Pillar 2)
// BW multipliers for 1RM — male, ~75kg class, age 26-35
// Percentile: [10th, 25th, 50th, 75th, 90th]
// Big three from van den Hoek et al. 2024 (OpenPowerlifting data)
// Accessory lifts: approximate, from StrengthLevel.com / general standards
// ============================================================
const STRENGTH_STANDARDS = {
  'bench_press':     { multipliers: [0.70, 0.95, 1.20, 1.50, 1.95], keyMuscle: 'chest' },
  'squat':           { multipliers: [0.85, 1.20, 1.60, 2.10, 2.83], keyMuscle: 'quads' },
  'deadlift':        { multipliers: [1.05, 1.45, 1.85, 2.50, 3.25], keyMuscle: 'back' },
  'overhead_press':  { multipliers: [0.40, 0.55, 0.72, 0.90, 1.15], keyMuscle: 'shoulders' },
  'barbell_row':     { multipliers: [0.50, 0.70, 0.90, 1.15, 1.45], keyMuscle: 'back' },       // approximate
  'barbell_curl':    { multipliers: [0.25, 0.35, 0.50, 0.65, 0.85], keyMuscle: 'biceps' },     // approximate
  'skull_crusher':   { multipliers: [0.20, 0.30, 0.40, 0.55, 0.70], keyMuscle: 'triceps' },    // approximate
  'leg_curl':        { multipliers: [0.25, 0.35, 0.50, 0.65, 0.80], keyMuscle: 'hamstrings' }, // approximate
  'hip_thrust':      { multipliers: [0.65, 0.95, 1.30, 1.75, 2.25], keyMuscle: 'glutes' },     // approximate
  'calf_raise':      { multipliers: [0.50, 0.75, 1.00, 1.40, 1.85], keyMuscle: 'calves' },     // approximate
  'plank_equivalent': { multipliers: null, keyMuscle: 'core' }, // Core uses volume compliance only
};

// Map muscle groups to their key lift standard and exercise match patterns
const MUSCLE_KEY_LIFTS = {
  chest:      { standard: 'bench_press',    patterns: [/bench press/i] },
  back:       { standard: 'deadlift',       patterns: [/deadlift/i, /barbell row/i, /bent over row/i] },
  shoulders:  { standard: 'overhead_press', patterns: [/overhead press/i, /shoulder press/i, /military press/i] },
  quads:      { standard: 'squat',          patterns: [/squat/i] },
  hamstrings: { standard: 'leg_curl',       patterns: [/leg curl/i, /romanian deadlift/i] },
  glutes:     { standard: 'hip_thrust',     patterns: [/hip thrust/i] },
  biceps:     { standard: 'barbell_curl',   patterns: [/barbell curl/i, /bicep curl/i] },
  triceps:    { standard: 'skull_crusher',  patterns: [/skullcrusher/i, /skull crusher/i, /tricep extension/i, /triceps extension/i, /triceps pushdown/i, /tricep pushdown/i] },
  calves:     { standard: 'calf_raise',     patterns: [/calf raise/i, /calf extension/i] },
  core:       { standard: 'plank_equivalent', patterns: [] },
};

// ============================================================
// 1RM ESTIMATION FUNCTIONS (Pillar 3)
// ============================================================
// Brzycki (1993): valid for 1-10 reps
function estimate1RM_Brzycki(weightLbs, reps) {
  if (reps <= 0) return 0;
  if (reps === 1) return weightLbs;
  if (reps >= 37) return weightLbs; // formula breaks at 37 reps
  return weightLbs * (36 / (37 - reps));
}

// Epley (1985): better for >10 reps
function estimate1RM_Epley(weightLbs, reps) {
  if (reps <= 0) return 0;
  if (reps === 1) return weightLbs;
  return weightLbs * (1 + reps / 30);
}

// Auto-select: Brzycki for <=10, Epley for >10
function estimate1RM(weightLbs, reps) {
  if (reps <= 10) return estimate1RM_Brzycki(weightLbs, reps);
  return estimate1RM_Epley(weightLbs, reps);
}

// ============================================================
// PERCENTILE ESTIMATION
// Given a BW multiplier and a standard key, interpolate percentile
// ============================================================
function estimatePercentile(standardKey, bwMultiplier) {
  const std = STRENGTH_STANDARDS[standardKey];
  if (!std || !std.multipliers) return null;
  const m = std.multipliers; // [10th, 25th, 50th, 75th, 90th]
  const pctiles = [10, 25, 50, 75, 90];

  if (bwMultiplier <= m[0]) return Math.round((bwMultiplier / m[0]) * 10);
  if (bwMultiplier >= m[4]) return Math.min(99, 90 + Math.round(((bwMultiplier - m[4]) / (m[4] * 0.2)) * 9));

  for (let i = 0; i < m.length - 1; i++) {
    if (bwMultiplier >= m[i] && bwMultiplier <= m[i + 1]) {
      const frac = (bwMultiplier - m[i]) / (m[i + 1] - m[i]);
      return Math.round(pctiles[i] + frac * (pctiles[i + 1] - pctiles[i]));
    }
  }
  return 50;
}

// ============================================================
// TIME ESTIMATION (Feature 2)
// ============================================================
const TIME_CONSTANTS = {
  compoundSetSec: 45,    // seconds per working set for compound exercises
  isolationSetSec: 35,   // seconds per working set for isolation exercises
  restBetweenSets: 120,  // 2 minutes rest between sets
  transitionSec: 90,     // walk to station, load plates, adjust
  sessionCapMin: 60,     // maximum session length in minutes
};

function calculateExerciseTime(exerciseName, sets) {
  const db = EXERCISE_DB[exerciseName];
  const isCompound = db && db.type === 'compound';
  const setTime = isCompound ? TIME_CONSTANTS.compoundSetSec : TIME_CONSTANTS.isolationSetSec;
  const totalSec = (sets * setTime) + ((sets - 1) * TIME_CONSTANTS.restBetweenSets) + TIME_CONSTANTS.transitionSec;
  return totalSec;
}

// ============================================================
// EXERCISE -> MUSCLE GROUP MAPPING
// ============================================================
const EXERCISE_MUSCLE_MAP = [
  // Chest
  { pattern: /bench press/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /chest press/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /chest fly/i, primary: 'chest', secondary: [] },
  { pattern: /chest dip/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /cable fly/i, primary: 'chest', secondary: [] },
  { pattern: /push.?up/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /pec.?deck/i, primary: 'chest', secondary: [] },
  { pattern: /dip/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },

  // Back
  { pattern: /deadlift/i, primary: 'back', secondary: ['hamstrings', 'glutes'] },
  { pattern: /pull.?up/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /chin.?up/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /lat.?pull/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /row/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /rack pull/i, primary: 'back', secondary: ['hamstrings'] },
  { pattern: /back extension/i, primary: 'back', secondary: ['glutes'] },
  { pattern: /good morning/i, primary: 'back', secondary: ['hamstrings', 'glutes'] },
  { pattern: /shrug/i, primary: 'back', secondary: [] },
  { pattern: /face pull/i, primary: 'back', secondary: ['shoulders'] },

  // Shoulders
  { pattern: /overhead press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /shoulder press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /military press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /arnold press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /lateral raise/i, primary: 'shoulders', secondary: [] },
  { pattern: /front raise/i, primary: 'shoulders', secondary: [] },
  { pattern: /rear delt/i, primary: 'shoulders', secondary: [] },
  { pattern: /upright row/i, primary: 'shoulders', secondary: ['back'] },
  { pattern: /pike push/i, primary: 'shoulders', secondary: ['triceps'] },

  // Biceps
  { pattern: /bicep curl/i, primary: 'biceps', secondary: [] },
  { pattern: /hammer curl/i, primary: 'biceps', secondary: [] },
  { pattern: /concentration curl/i, primary: 'biceps', secondary: [] },
  { pattern: /preacher curl/i, primary: 'biceps', secondary: [] },
  { pattern: /barbell curl/i, primary: 'biceps', secondary: [] },
  { pattern: /kettlebell curl/i, primary: 'biceps', secondary: [] },

  // Triceps
  { pattern: /tricep/i, primary: 'triceps', secondary: [] },
  { pattern: /skull.?crush/i, primary: 'triceps', secondary: [] },
  { pattern: /close.?grip.*bench/i, primary: 'triceps', secondary: ['chest'] },

  // Quads
  { pattern: /squat/i, primary: 'quads', secondary: ['glutes', 'hamstrings'] },
  { pattern: /leg press/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /leg extension/i, primary: 'quads', secondary: [] },
  { pattern: /lunge/i, primary: 'quads', secondary: ['glutes', 'hamstrings'] },
  { pattern: /goblet squat/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /front squat/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /step.?up/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /hack squat/i, primary: 'quads', secondary: ['glutes'] },

  // Hamstrings
  { pattern: /romanian deadlift/i, primary: 'hamstrings', secondary: ['glutes', 'back'] },
  { pattern: /leg curl/i, primary: 'hamstrings', secondary: [] },
  { pattern: /nordic curl/i, primary: 'hamstrings', secondary: [] },
  { pattern: /stiff.?leg/i, primary: 'hamstrings', secondary: ['glutes', 'back'] },

  // Glutes
  { pattern: /hip thrust/i, primary: 'glutes', secondary: ['hamstrings'] },
  { pattern: /glute/i, primary: 'glutes', secondary: [] },
  { pattern: /hip abduction/i, primary: 'glutes', secondary: [] },
  { pattern: /hip adduction/i, primary: 'glutes', secondary: [] },

  // Calves
  { pattern: /calf/i, primary: 'calves', secondary: [] },

  // Core
  { pattern: /crunch/i, primary: 'core', secondary: [] },
  { pattern: /sit.?up/i, primary: 'core', secondary: [] },
  { pattern: /plank/i, primary: 'core', secondary: [] },
  { pattern: /leg raise/i, primary: 'core', secondary: [] },
  { pattern: /knee raise/i, primary: 'core', secondary: [] },
  { pattern: /hanging/i, primary: 'core', secondary: [] },
  { pattern: /ab\b/i, primary: 'core', secondary: [] },
  { pattern: /russian twist/i, primary: 'core', secondary: [] },
  { pattern: /woodchop/i, primary: 'core', secondary: [] },
];

const CARDIO_PATTERNS = [
  /treadmill/i, /elliptical/i, /bike/i, /cycling/i, /rowing machine/i,
  /jump rope/i, /jumping jack/i, /burpee/i, /stair/i, /running/i, /walking/i,
];

function classifyExercise(name) {
  for (const c of CARDIO_PATTERNS) {
    if (c.test(name)) return { primary: 'cardio', secondary: [] };
  }
  for (const m of EXERCISE_MUSCLE_MAP) {
    if (m.pattern.test(name)) return { primary: m.primary, secondary: m.secondary };
  }
  return { primary: 'other', secondary: [] };
}

// ============================================================
// MUSCLE GROUP METADATA
// Based on Schoenfeld et al. volume-hypertrophy dose-response
// and intermediate programming guidelines (Pillar 1)
// ============================================================
const MUSCLE_GROUPS = {
  chest:      { name: 'Chest',      idealFreqDays: 4, color: '#f87171', idealSetsPerWeek: 14 },
  back:       { name: 'Back',       idealFreqDays: 4, color: '#60a5fa', idealSetsPerWeek: 16 },
  shoulders:  { name: 'Shoulders',  idealFreqDays: 4, color: '#c084fc', idealSetsPerWeek: 14 },
  biceps:     { name: 'Biceps',     idealFreqDays: 5, color: '#34d399', idealSetsPerWeek: 10 },
  triceps:    { name: 'Triceps',    idealFreqDays: 5, color: '#fbbf24', idealSetsPerWeek: 10 },
  quads:      { name: 'Quads',      idealFreqDays: 4, color: '#fb923c', idealSetsPerWeek: 14 },
  hamstrings: { name: 'Hamstrings', idealFreqDays: 5, color: '#f472b6', idealSetsPerWeek: 12 },
  glutes:     { name: 'Glutes',     idealFreqDays: 5, color: '#a78bfa', idealSetsPerWeek: 12 },
  calves:     { name: 'Calves',     idealFreqDays: 5, color: '#2dd4bf', idealSetsPerWeek: 10 },
  core:       { name: 'Core',       idealFreqDays: 3, color: '#e879f9', idealSetsPerWeek: 10 },
};

// ============================================================
// STRENGTH STANDARDS & EXERCISE DATABASE
// Benchmarks for ~166lb male, age 36, intermediate level
// Based on Symmetric Strength / ExRx / Strength Level data
// All weights in lbs. "intermediate" = ~1-2 years training
// Progressive overload: +5% if <85% benchmark, +2.5% if at/above (Pillar 4, NSCA guideline)
// ============================================================
const EXERCISE_DB = {
  // --- CHEST ---
  'Bench Press (Barbell)': {
    muscle: 'chest', type: 'compound',
    benchmarkLbs: 185, sets: 4, reps: '6-8',
  },
  'Incline Bench Press (Dumbbell)': {
    muscle: 'chest', type: 'compound',
    benchmarkLbs: 60, sets: 3, reps: '8-10', note: 'per hand',
  },
  'Incline Bench Press (Barbell)': {
    muscle: 'chest', type: 'compound',
    benchmarkLbs: 155, sets: 4, reps: '6-8',
  },
  'Chest Fly (Machine)': {
    muscle: 'chest', type: 'isolation',
    benchmarkLbs: 140, sets: 3, reps: '10-12',
  },
  'Chest Fly (Dumbbell)': {
    muscle: 'chest', type: 'isolation',
    benchmarkLbs: 40, sets: 3, reps: '10-12', note: 'per hand',
  },
  'Chest Dip': {
    muscle: 'chest', type: 'compound',
    benchmarkLbs: 0, sets: 3, reps: '8-12', note: 'bodyweight',
  },
  'Cable Fly Crossovers': {
    muscle: 'chest', type: 'isolation',
    benchmarkLbs: 30, sets: 3, reps: '12-15', note: 'per side',
  },
  'Chest Press (Machine)': {
    muscle: 'chest', type: 'compound',
    benchmarkLbs: 160, sets: 3, reps: '8-10',
  },
  'Decline Bench Press (Barbell)': {
    muscle: 'chest', type: 'compound',
    benchmarkLbs: 195, sets: 3, reps: '6-8',
  },

  // --- BACK ---
  'Bent Over Row (Barbell)': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 165, sets: 4, reps: '6-8',
  },
  'Pull Up': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 0, sets: 4, reps: '6-10', note: 'bodyweight',
  },
  'Chin Up': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 0, sets: 3, reps: '6-10', note: 'bodyweight',
  },
  'Lat Pulldown (Cable)': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 140, sets: 3, reps: '8-10',
  },
  'Lat Pulldown (Machine)': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 140, sets: 3, reps: '8-10',
  },
  'Seated Row (Machine)': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 140, sets: 3, reps: '8-10',
  },
  'Dumbbell Row': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 65, sets: 3, reps: '8-10', note: 'per hand',
  },
  'Deadlift (Barbell)': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 275, sets: 3, reps: '5-6',
  },
  'Pendlay Row (Barbell)': {
    muscle: 'back', type: 'compound',
    benchmarkLbs: 155, sets: 4, reps: '5-8',
  },

  // --- SHOULDERS ---
  'Overhead Press (Barbell)': {
    muscle: 'shoulders', type: 'compound',
    benchmarkLbs: 115, sets: 4, reps: '6-8',
  },
  'Overhead Press (Dumbbell)': {
    muscle: 'shoulders', type: 'compound',
    benchmarkLbs: 45, sets: 3, reps: '8-10', note: 'per hand',
  },
  'Lateral Raise (Dumbbell)': {
    muscle: 'shoulders', type: 'isolation',
    benchmarkLbs: 20, sets: 4, reps: '12-15', note: 'per hand',
  },
  'Lateral Raise (Machine)': {
    muscle: 'shoulders', type: 'isolation',
    benchmarkLbs: 80, sets: 3, reps: '12-15',
  },
  'Arnold Press (Dumbbell)': {
    muscle: 'shoulders', type: 'compound',
    benchmarkLbs: 40, sets: 3, reps: '8-10', note: 'per hand',
  },
  'Seated Shoulder Press (Machine)': {
    muscle: 'shoulders', type: 'compound',
    benchmarkLbs: 120, sets: 3, reps: '8-10',
  },
  'Shoulder Press (Dumbbell)': {
    muscle: 'shoulders', type: 'compound',
    benchmarkLbs: 45, sets: 3, reps: '8-10', note: 'per hand',
  },
  'Standing Military Press (Barbell)': {
    muscle: 'shoulders', type: 'compound',
    benchmarkLbs: 115, sets: 4, reps: '6-8',
  },

  // --- BICEPS ---
  'Bicep Curl (Barbell)': {
    muscle: 'biceps', type: 'isolation',
    benchmarkLbs: 75, sets: 3, reps: '8-10',
  },
  'Bicep Curl (Dumbbell)': {
    muscle: 'biceps', type: 'isolation',
    benchmarkLbs: 30, sets: 3, reps: '10-12', note: 'per hand',
  },
  'Hammer Curl (Dumbbell)': {
    muscle: 'biceps', type: 'isolation',
    benchmarkLbs: 35, sets: 3, reps: '10-12', note: 'per hand',
  },
  'Hammer Curl (Cable)': {
    muscle: 'biceps', type: 'isolation',
    benchmarkLbs: 35, sets: 3, reps: '10-12', note: 'per side',
  },
  'Concentration Curl': {
    muscle: 'biceps', type: 'isolation',
    benchmarkLbs: 25, sets: 3, reps: '10-12', note: 'per hand',
  },

  // --- TRICEPS ---
  'Triceps Pushdown': {
    muscle: 'triceps', type: 'isolation',
    benchmarkLbs: 60, sets: 3, reps: '10-12',
  },
  'Triceps Rope Pushdown': {
    muscle: 'triceps', type: 'isolation',
    benchmarkLbs: 55, sets: 3, reps: '10-12',
  },
  'Triceps Extension (Cable)': {
    muscle: 'triceps', type: 'isolation',
    benchmarkLbs: 50, sets: 3, reps: '10-12',
  },
  'Triceps Extension (Dumbbell)': {
    muscle: 'triceps', type: 'isolation',
    benchmarkLbs: 30, sets: 3, reps: '10-12',
  },
  'Skullcrusher (Dumbbell)': {
    muscle: 'triceps', type: 'isolation',
    benchmarkLbs: 25, sets: 3, reps: '10-12', note: 'per hand',
  },
  'Triceps Dip': {
    muscle: 'triceps', type: 'compound',
    benchmarkLbs: 0, sets: 3, reps: '8-12', note: 'bodyweight',
  },

  // --- QUADS ---
  'Squat (Barbell)': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 225, sets: 4, reps: '5-8',
  },
  'Squat (Bodyweight)': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight',
  },
  'Leg Press (Machine)': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 360, sets: 4, reps: '8-10',
  },
  'Front Squat': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 175, sets: 3, reps: '6-8',
  },
  'Goblet Squat': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 60, sets: 3, reps: '10-12',
  },
  'Lunge (Dumbbell)': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 40, sets: 3, reps: '10-12', note: 'per hand',
  },
  'Lunge': {
    muscle: 'quads', type: 'compound',
    benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight',
  },

  // --- HAMSTRINGS ---
  'Romanian Deadlift (Barbell)': {
    muscle: 'hamstrings', type: 'compound',
    benchmarkLbs: 205, sets: 4, reps: '8-10',
  },
  'Romanian Deadlift (Dumbbell)': {
    muscle: 'hamstrings', type: 'compound',
    benchmarkLbs: 55, sets: 3, reps: '8-10', note: 'per hand',
  },
  'Seated Leg Curl (Machine)': {
    muscle: 'hamstrings', type: 'isolation',
    benchmarkLbs: 110, sets: 3, reps: '10-12',
  },

  // --- GLUTES ---
  'Hip Thrust (Barbell)': {
    muscle: 'glutes', type: 'compound',
    benchmarkLbs: 225, sets: 4, reps: '8-10',
  },
  'Hip Thrust (Machine)': {
    muscle: 'glutes', type: 'compound',
    benchmarkLbs: 225, sets: 3, reps: '8-10',
  },
  'Hip Thrust': {
    muscle: 'glutes', type: 'compound',
    benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight',
  },
  'Glute Kickback (Machine)': {
    muscle: 'glutes', type: 'isolation',
    benchmarkLbs: 80, sets: 3, reps: '12-15',
  },
  'Hip Abduction (Machine)': {
    muscle: 'glutes', type: 'isolation',
    benchmarkLbs: 120, sets: 3, reps: '12-15',
  },
  'Hip Adduction (Machine)': {
    muscle: 'glutes', type: 'isolation',
    benchmarkLbs: 120, sets: 3, reps: '12-15',
  },

  // --- CALVES ---
  'Standing Calf Raise': {
    muscle: 'calves', type: 'isolation',
    benchmarkLbs: 180, sets: 4, reps: '12-15',
  },
  'Seated Calf Raise': {
    muscle: 'calves', type: 'isolation',
    benchmarkLbs: 90, sets: 3, reps: '12-15',
  },
  'Calf Extension (Machine)': {
    muscle: 'calves', type: 'isolation',
    benchmarkLbs: 140, sets: 3, reps: '12-15',
  },

  // --- CORE ---
  'Hanging Leg Raise': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '10-15', note: 'bodyweight',
  },
  'Hanging Knee Raise': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight',
  },
  'Crunch': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight',
  },
  'Crunch (Machine)': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 80, sets: 3, reps: '12-15',
  },
  'Decline Crunch': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight',
  },
  'Plank': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '45-60s', note: 'hold',
  },
  'Sit Up': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight',
  },
  'Leg Raise Parallel Bars': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '10-15', note: 'bodyweight',
  },
  'Knee Raise Parallel Bars': {
    muscle: 'core', type: 'isolation',
    benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight',
  },
};

// Top exercise picks per muscle group (ordered by priority)
const MUSCLE_EXERCISE_PICKS = {
  chest:      ['Bench Press (Barbell)', 'Incline Bench Press (Dumbbell)', 'Chest Fly (Machine)', 'Cable Fly Crossovers'],
  back:       ['Bent Over Row (Barbell)', 'Pull Up', 'Lat Pulldown (Cable)', 'Seated Row (Machine)'],
  shoulders:  ['Overhead Press (Barbell)', 'Lateral Raise (Dumbbell)', 'Arnold Press (Dumbbell)', 'Lateral Raise (Machine)'],
  biceps:     ['Bicep Curl (Barbell)', 'Hammer Curl (Dumbbell)', 'Concentration Curl'],
  triceps:    ['Triceps Pushdown', 'Triceps Extension (Cable)', 'Skullcrusher (Dumbbell)'],
  quads:      ['Squat (Barbell)', 'Leg Press (Machine)', 'Front Squat', 'Lunge (Dumbbell)'],
  hamstrings: ['Romanian Deadlift (Barbell)', 'Seated Leg Curl (Machine)'],
  glutes:     ['Hip Thrust (Barbell)', 'Glute Kickback (Machine)', 'Hip Abduction (Machine)'],
  calves:     ['Standing Calf Raise', 'Seated Calf Raise'],
  core:       ['Hanging Leg Raise', 'Crunch (Machine)', 'Plank'],
};

// ============================================================
// BODY WEIGHT DATA — Baseline from Strong CSV export
// New entries added via localStorage (Feature 1)
// ============================================================
const WEIGHT_DATA_BASELINE = [
  { date: '2026-01-18', value: 166.0 },
  { date: '2026-01-17', value: 164.4 },
  { date: '2025-11-30', value: 168.0 },
  { date: '2025-11-04', value: 167.1 },
  { date: '2025-11-01', value: 168.2 },
  { date: '2025-10-01', value: 169.0 },
  { date: '2025-09-12', value: 169.0 },
  { date: '2025-09-07', value: 168.0 },
  { date: '2025-07-15', value: 172.0 },
  { date: '2025-05-23', value: 174.2 },
  { date: '2025-05-15', value: 172.0 },
  { date: '2025-04-30', value: 173.0 },
];

// ============================================================
// WEIGHT localStorage FUNCTIONS (Feature 1)
// ============================================================
function getStoredWeightEntries() {
  try {
    const raw = localStorage.getItem('weightHistory');
    if (!raw) return [];
    return JSON.parse(raw);
  } catch (e) {
    return [];
  }
}

function saveWeightEntry(date, value) {
  const entries = getStoredWeightEntries();
  entries.push({ date, value });
  localStorage.setItem('weightHistory', JSON.stringify(entries));
}

function getMergedWeightData() {
  const stored = getStoredWeightEntries();
  const all = [...WEIGHT_DATA_BASELINE, ...stored];
  // Deduplicate by date (keep latest value for each date)
  const byDate = {};
  for (const entry of all) {
    byDate[entry.date] = entry.value;
  }
  return Object.entries(byDate)
    .map(([date, value]) => ({ date, value }))
    .sort((a, b) => b.date.localeCompare(a.date)); // descending
}

// ============================================================
// STATE
// ============================================================
const apiKey = 'e38cf123-61c4-4b8c-ae25-7442d6d9c874';
let workoutCache = null;
let muscleAnalysis = null;
let exerciseHistory = {};
let muscle1RMs = {};        // { muscleKey: { best1RM, bwMult, percentile } }
let strengthIndexData = []; // [{ date, index, lifts: {...} }]
let WEIGHT_DATA = [];       // merged weight data

// ============================================================
// API
// ============================================================
const API_BASE = 'https://api.hevyapp.com/v1';

async function fetchWorkouts(pageSize = 10, maxPages = 10) {
  const allWorkouts = [];
  let page = 1;
  let totalPages = 1;

  while (page <= totalPages && page <= maxPages) {
    updateLoading(`Loading workouts (${allWorkouts.length})...`);
    const resp = await fetch(`${API_BASE}/workouts?page=${page}&pageSize=${pageSize}`, {
      headers: { 'api-key': apiKey }
    });
    if (!resp.ok) throw new Error(`API error ${resp.status}: ${resp.statusText}`);
    const data = await resp.json();
    totalPages = data.page_count || 1;
    if (data.workouts) allWorkouts.push(...data.workouts);
    page++;
  }
  return allWorkouts;
}

// ============================================================
// EXTRACT EXERCISE HISTORY
// ============================================================
function buildExerciseHistory(workouts) {
  const history = {};

  // Process oldest -> newest so latest values overwrite
  const sorted = [...workouts].sort((a, b) =>
    new Date(a.start_time || a.created_at) - new Date(b.start_time || b.created_at)
  );

  for (const w of sorted) {
    const wDate = new Date(w.start_time || w.created_at);
    for (const ex of (w.exercises || [])) {
      const name = ex.title || '';
      if (!name) continue;

      const workingSets = (ex.sets || []).filter(s =>
        s.set_type === 'normal' || !s.set_type
      );
      if (workingSets.length === 0) continue;

      // Find heaviest set
      let bestWeight = 0;
      let bestReps = 0;
      for (const s of workingSets) {
        const wKg = s.weight_kg || 0;
        const wLbs = Math.round(wKg * 2.20462);
        if (wLbs > bestWeight) {
          bestWeight = wLbs;
          bestReps = s.reps || 0;
        }
      }

      if (!history[name]) {
        history[name] = { weights: [], dates: [] };
      }
      history[name].lastWeightLbs = bestWeight;
      history[name].lastReps = bestReps;
      history[name].lastDate = wDate;
      history[name].lastSets = workingSets.length;
      history[name].weights.push(bestWeight);
      history[name].dates.push(wDate);
    }
  }

  return history;
}

// ============================================================
// COMPUTE MUSCLE GROUP 1RM & PERCENTILES (Feature 4)
// For each muscle group, find best estimated 1RM from Hevy data
// in last 30 days on the key lift, compute BW multiplier and percentile
// ============================================================
function computeMuscle1RMs(workouts, bodyweightLbs) {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  const results = {};

  for (const [muscleKey, keyLift] of Object.entries(MUSCLE_KEY_LIFTS)) {
    let best1RM = 0;
    let bestExName = '';

    for (const w of workouts) {
      const wDate = new Date(w.start_time || w.created_at);
      if (wDate < thirtyDaysAgo) continue;

      for (const ex of (w.exercises || [])) {
        const name = ex.title || '';
        const matched = keyLift.patterns.some(p => p.test(name));
        if (!matched) continue;

        for (const s of (ex.sets || [])) {
          const wKg = s.weight_kg || 0;
          const wLbs = wKg * 2.20462;
          const reps = s.reps || 0;
          if (wLbs <= 0 || reps <= 0) continue;

          const est = estimate1RM(wLbs, reps);
          if (est > best1RM) {
            best1RM = est;
            bestExName = name;
          }
        }
      }
    }

    const bwMult = bodyweightLbs > 0 ? best1RM / bodyweightLbs : 0;
    const percentile = estimatePercentile(keyLift.standard, bwMult);

    results[muscleKey] = {
      best1RM: Math.round(best1RM),
      bwMult: Math.round(bwMult * 100) / 100,
      percentile,
      exercise: bestExName,
    };
  }

  return results;
}

// ============================================================
// STRENGTH INDEX COMPUTATION (Feature 6)
// Composite index tracking estimated 1RM progress over time
// ============================================================
const STRENGTH_INDEX_LIFTS = {
  bench:    { weight: 0.20, patterns: [/bench press.*barbell/i, /^bench press$/i] },
  squat:    { weight: 0.25, patterns: [/squat.*barbell/i, /^squat$/i, /barbell.*squat/i] },
  deadlift: { weight: 0.30, patterns: [/^deadlift/i, /deadlift.*barbell/i] },
  ohp:      { weight: 0.10, patterns: [/overhead press/i, /shoulder press/i, /military press/i] },
  row:      { weight: 0.15, patterns: [/barbell row/i, /bent over row/i, /pendlay row/i] },
};

function computeStrengthIndexTimeline(workouts, weightData) {
  // Sort workouts oldest -> newest
  const sorted = [...workouts].sort((a, b) =>
    new Date(a.start_time || a.created_at) - new Date(b.start_time || b.created_at)
  );

  // Sort weight data oldest -> newest for interpolation
  const weightSorted = [...weightData].sort((a, b) => a.date.localeCompare(b.date));

  function getBodyweightAt(dateStr) {
    // Find the most recent weight entry at or before this date
    let bw = PROFILE.bodyweightLbs;
    for (const w of weightSorted) {
      if (w.date <= dateStr) bw = w.value;
      else break;
    }
    return bw;
  }

  const rolling1RMs = { bench: 0, squat: 0, deadlift: 0, ohp: 0, row: 0 };
  const timeline = [];

  for (const w of sorted) {
    const wDate = new Date(w.start_time || w.created_at);
    const dateStr = wDate.toISOString().split('T')[0];
    let updated = false;

    for (const ex of (w.exercises || [])) {
      const name = ex.title || '';

      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        const matched = liftDef.patterns.some(p => p.test(name));
        if (!matched) continue;

        for (const s of (ex.sets || [])) {
          const wKg = s.weight_kg || 0;
          const wLbs = wKg * 2.20462;
          const reps = s.reps || 0;
          if (wLbs <= 0 || reps <= 0) continue;

          const est = estimate1RM(wLbs, reps);
          if (est > rolling1RMs[liftKey]) {
            rolling1RMs[liftKey] = est;
            updated = true;
          }
        }
      }
    }

    // Only add a data point if at least one lift has data
    const hasData = Object.values(rolling1RMs).some(v => v > 0);
    if (hasData) {
      const bw = getBodyweightAt(dateStr);
      let index = 0;
      const lifts = {};
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        const mult = bw > 0 ? rolling1RMs[liftKey] / bw : 0;
        index += mult * liftDef.weight;
        lifts[liftKey] = { rm: Math.round(rolling1RMs[liftKey]), mult: Math.round(mult * 100) / 100 };
      }
      timeline.push({
        date: dateStr,
        index: Math.round(index * 100) / 100,
        lifts: { ...lifts },
      });
    }
  }

  return timeline;
}

// ============================================================
// SMART WEIGHT PRESCRIPTION
// Blends actual history with benchmark data (Pillar 4)
// ============================================================
function prescribeExercise(name) {
  const db = EXERCISE_DB[name];
  const hist = exerciseHistory[name];

  let sets = db ? db.sets : 3;
  let reps = db ? db.reps : '8-10';
  let weightLbs = db ? db.benchmarkLbs : 0;
  let note = db ? (db.note || '') : '';

  if (hist && hist.lastWeightLbs > 0) {
    const lastW = hist.lastWeightLbs;
    const trend = hist.weights.length >= 3
      ? hist.weights.slice(-3).reduce((a, b) => a + b, 0) / 3
      : lastW;

    // Progressive overload logic (Pillar 4):
    // NSCA: "Increase load 2-10% when target reps are achieved for 2 consecutive sessions"
    if (db && lastW < db.benchmarkLbs * 0.85) {
      // Well below benchmark: +5% above trend, capped at benchmark
      weightLbs = Math.min(Math.round(trend * 1.05 / 5) * 5, db.benchmarkLbs);
    } else {
      // At or near benchmark: +2.5% progressive overload
      weightLbs = Math.round(trend * 1.025 / 5) * 5;
    }

    if (hist.lastSets >= 2 && hist.lastSets <= 6) {
      sets = hist.lastSets;
    }
  } else if (!db) {
    return { sets: 3, reps: '8-10', weightLbs: 0, note: 'no data' };
  }

  if (note === 'bodyweight' || note === 'hold') {
    weightLbs = 0;
  }

  return { sets, reps, weightLbs, note };
}

function formatPrescription(p) {
  let str = `${p.sets}\u00d7${p.reps}`;
  if (p.weightLbs > 0) {
    str += ` @ ${p.weightLbs}lbs`;
  }
  if (p.note === 'per hand' || p.note === 'per side') {
    str += '/ea';
  }
  return str;
}

// ============================================================
// ANALYSIS
// ============================================================
function analyzeWorkouts(workouts) {
  const now = new Date();
  const muscleStats = {};

  for (const [key, meta] of Object.entries(MUSCLE_GROUPS)) {
    muscleStats[key] = {
      key,
      name: meta.name,
      color: meta.color,
      idealFreqDays: meta.idealFreqDays,
      idealSetsPerWeek: meta.idealSetsPerWeek,
      lastTrained: null,
      daysSinceTrained: Infinity,
      totalSets30d: 0,
      totalVolume30d: 0,
      sessionCount30d: 0,
      exercises: new Set(),
    };
  }

  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  for (const w of workouts) {
    const workoutDate = new Date(w.start_time || w.created_at);
    const isRecent = workoutDate >= thirtyDaysAgo;
    const musclesThisWorkout = new Set();

    for (const ex of (w.exercises || [])) {
      const exName = ex.title || ex.exercise_template_id || '';
      const classification = classifyExercise(exName);
      if (classification.primary === 'cardio' || classification.primary === 'other') continue;

      const allMuscles = [classification.primary, ...classification.secondary];

      for (const muscle of allMuscles) {
        if (!muscleStats[muscle]) continue;
        const stat = muscleStats[muscle];
        const isPrimary = muscle === classification.primary;

        if (!stat.lastTrained || workoutDate > stat.lastTrained) {
          stat.lastTrained = workoutDate;
          stat.daysSinceTrained = Math.floor((now - workoutDate) / (1000 * 60 * 60 * 24));
        }

        if (isRecent) {
          const setCount = (ex.sets || []).length;
          const weight = isPrimary ? 1.0 : 0.5;
          stat.totalSets30d += Math.round(setCount * weight);

          for (const s of (ex.sets || [])) {
            const reps = s.reps || 0;
            const wt = s.weight_kg || 0;
            stat.totalVolume30d += reps * wt * weight;
          }

          stat.exercises.add(exName);
          musclesThisWorkout.add(muscle);
        }
      }
    }

    if (isRecent) {
      for (const m of musclesThisWorkout) {
        if (muscleStats[m]) muscleStats[m].sessionCount30d++;
      }
    }
  }

  return muscleStats;
}

// ============================================================
// IMBALANCE DETECTION & RECOMMENDATIONS
// ============================================================
function generateRecommendations(muscleStats) {
  const recs = [];

  const weeklyVolumes = {};
  for (const [key, stat] of Object.entries(muscleStats)) {
    weeklyVolumes[key] = stat.totalSets30d / 4.3;
  }

  const volumeRatios = {};
  let maxRatio = 0;
  for (const [key, stat] of Object.entries(muscleStats)) {
    const ratio = weeklyVolumes[key] / stat.idealSetsPerWeek;
    volumeRatios[key] = ratio;
    if (ratio > maxRatio) maxRatio = ratio;
  }

  for (const [key, stat] of Object.entries(muscleStats)) {
    const daysOverdue = Math.max(0, stat.daysSinceTrained - stat.idealFreqDays);
    const recencyScore = Math.min(stat.daysSinceTrained / stat.idealFreqDays, 3);

    const idealSets30d = stat.idealSetsPerWeek * 4.3;
    const volumeDeficit = Math.max(0, 1 - (stat.totalSets30d / idealSets30d));

    const imbalanceScore = maxRatio > 0 ? Math.max(0, 1 - (volumeRatios[key] / maxRatio)) : 0;

    const score = (recencyScore * 0.4) + (volumeDeficit * 0.3) + (imbalanceScore * 0.3);

    let urgency = 'low';
    if (stat.daysSinceTrained >= stat.idealFreqDays * 2 || (volumeDeficit > 0.6 && imbalanceScore > 0.5)) {
      urgency = 'high';
    } else if (stat.daysSinceTrained >= stat.idealFreqDays || volumeDeficit > 0.3) {
      urgency = 'med';
    }

    const weeklyActual = weeklyVolumes[key].toFixed(1);
    const weeklyIdeal = stat.idealSetsPerWeek;
    let explainer = '';

    if (stat.daysSinceTrained === Infinity) {
      explainer = `No ${stat.name.toLowerCase()} training found in your history. This muscle group needs attention to build a balanced physique.`;
    } else {
      const parts = [];

      if (stat.daysSinceTrained >= stat.idealFreqDays * 2) {
        parts.push(`Last trained <strong>${stat.daysSinceTrained} days ago</strong> \u2014 ideally every ${stat.idealFreqDays} days for optimal growth`);
      } else if (stat.daysSinceTrained >= stat.idealFreqDays) {
        parts.push(`Trained ${stat.daysSinceTrained} days ago, slightly past the ${stat.idealFreqDays}-day window`);
      }

      if (volumeDeficit > 0.3) {
        parts.push(`Volume is <strong>${weeklyActual} sets/week</strong> vs the ${weeklyIdeal} recommended \u2014 ${Math.round(volumeDeficit * 100)}% below target`);
      }

      if (imbalanceScore > 0.4) {
        const topMuscle = Object.entries(volumeRatios).sort((a, b) => b[1] - a[1])[0];
        if (topMuscle[0] !== key) {
          parts.push(`Lagging behind your ${muscleStats[topMuscle[0]].name.toLowerCase()} proportionally \u2014 focus here to balance out`);
        }
      }

      if (parts.length === 0) {
        parts.push(`On track. ${weeklyActual} sets/week is close to the ${weeklyIdeal} target. Last trained ${stat.daysSinceTrained} days ago.`);
      }

      explainer = parts.join('. ') + '.';
    }

    recs.push({
      key,
      name: stat.name,
      score,
      urgency,
      daysSince: stat.daysSinceTrained,
      sets30d: stat.totalSets30d,
      detail: stat.daysSinceTrained === Infinity
        ? 'no data'
        : `${stat.daysSinceTrained}d ago \u00b7 ${stat.totalSets30d} sets/30d`,
      explainer,
      weeklyActual: parseFloat(weeklyActual),
      weeklyIdeal,
    });
  }

  recs.sort((a, b) => b.score - a.score);
  return recs;
}

// ============================================================
// SESSION PLANNING WITH TIME CAP (Feature 2)
// Per-muscle exercise cap keeps volume balanced across groups
// ============================================================
const MUSCLE_EXERCISE_CAP = {
  // Max exercises per muscle group position in priority ranking
  // [1st priority, 2nd priority, 3rd priority]
  caps: [3, 2, 2],
};

function buildTimedSession(recs) {
  // Pick top 3 priority muscle groups
  const topKeys = recs.slice(0, 3).map(r => r.key);
  const recScores = {};
  recs.forEach((r, i) => { recScores[r.key] = r.score; });

  // Per-muscle cap: 1st priority gets 3 exercises max, 2nd and 3rd get 2
  const muscleCaps = {};
  topKeys.forEach((key, idx) => {
    muscleCaps[key] = MUSCLE_EXERCISE_CAP.caps[idx] || 2;
  });

  // Build candidate exercise list with importance scoring
  const candidates = [];
  for (const key of topKeys) {
    const picks = MUSCLE_EXERCISE_PICKS[key] || [];
    const groupPriority = recScores[key] || 0;
    // Only consider up to the cap number of exercises per muscle
    const cappedPicks = picks.slice(0, muscleCaps[key]);

    for (let i = 0; i < cappedPicks.length; i++) {
      const exName = cappedPicks[i];
      const db = EXERCISE_DB[exName];
      const p = prescribeExercise(exName);

      // Importance: muscle priority (0-3) * type bonus * benchmark deficit
      const typeBonus = (db && db.type === 'compound') ? 1.5 : 1.0;
      let deficitBonus = 1.0;
      if (db && db.benchmarkLbs > 0 && p.weightLbs > 0) {
        const ratio = p.weightLbs / db.benchmarkLbs;
        deficitBonus = ratio < 0.85 ? 1.3 : 1.0;
      }
      const orderBonus = 1 - (i * 0.1); // prefer earlier picks

      const importance = groupPriority * typeBonus * deficitBonus * orderBonus;
      const timeSec = calculateExerciseTime(exName, p.sets);

      candidates.push({
        name: exName,
        muscle: key,
        prescription: p,
        importance,
        timeSec,
        isCompound: db && db.type === 'compound',
      });
    }
  }

  // Sort by importance descending
  candidates.sort((a, b) => b.importance - a.importance);

  // Apply 60-minute cap
  const capSec = TIME_CONSTANTS.sessionCapMin * 60;
  const session = [];
  let totalSec = 0;

  for (const c of candidates) {
    if (totalSec + c.timeSec > capSec) continue;
    session.push(c);
    totalSec += c.timeSec;
  }

  return { exercises: session, totalSec };
}

// ============================================================
// HEATMAP DATA BUILD (Feature 5)
// ============================================================
function buildHeatmapData(workouts) {
  const dayMuscleMap = {}; // { 'YYYY-MM-DD': { chest: N, back: N, ... } }
  const dayWorkouts = {};  // { 'YYYY-MM-DD': [{ name, sets }] }

  for (const w of workouts) {
    const wDate = new Date(w.start_time || w.created_at);
    const dateStr = wDate.toISOString().split('T')[0];

    if (!dayMuscleMap[dateStr]) dayMuscleMap[dateStr] = {};
    if (!dayWorkouts[dateStr]) dayWorkouts[dateStr] = [];

    for (const ex of (w.exercises || [])) {
      const name = ex.title || '';
      const classification = classifyExercise(name);
      if (classification.primary === 'cardio' || classification.primary === 'other') continue;

      const setCount = (ex.sets || []).length;
      const allMuscles = [classification.primary, ...classification.secondary];

      for (const muscle of allMuscles) {
        if (!MUSCLE_GROUPS[muscle]) continue;
        const isPrimary = muscle === classification.primary;
        const weight = isPrimary ? 1.0 : 0.5;
        dayMuscleMap[dateStr][muscle] = (dayMuscleMap[dateStr][muscle] || 0) + Math.round(setCount * weight);
      }

      // For detail view, build compact exercise list
      const bestSet = (ex.sets || []).reduce((best, s) => {
        const wLbs = Math.round((s.weight_kg || 0) * 2.20462);
        return wLbs > (best.w || 0) ? { w: wLbs, r: s.reps || 0 } : best;
      }, {});
      dayWorkouts[dateStr].push({
        name,
        sets: setCount,
        bestWeight: bestSet.w || 0,
        bestReps: bestSet.r || 0,
      });
    }
  }

  return { dayMuscleMap, dayWorkouts };
}

// ============================================================
// RENDERING
// ============================================================
function renderRecommendations(recs) {
  const container = document.getElementById('recommendations');
  const top = recs.slice(0, 6);

  container.innerHTML = top.map((r, i) => `
    <div class="rec-item" onclick="toggleExplainer(this)">
      <div class="rec-row">
        <div class="rec-rank">${i + 1}</div>
        <div class="rec-info">
          <div class="rec-name">${r.name}</div>
          <div class="rec-detail">${r.detail}</div>
        </div>
        <div class="rec-urgency urgency-${r.urgency}">${r.urgency}</div>
      </div>
      <div class="rec-expand">
        <div class="rec-explainer">${r.explainer}</div>
      </div>
    </div>
  `).join('');
}

function renderTimedSession(recs) {
  const { exercises, totalSec } = buildTimedSession(recs);
  const totalMin = Math.round(totalSec / 60);

  // Summary
  const summaryEl = document.getElementById('session-summary');
  summaryEl.innerHTML = `
    <div class="session-summary">
      <div class="session-time">~${totalMin} min</div>
      <div class="session-count">${exercises.length} exercises</div>
    </div>
  `;

  // Group exercises by muscle
  const exContainer = document.getElementById('suggested-exercises');
  const grouped = {};
  for (const ex of exercises) {
    if (!grouped[ex.muscle]) grouped[ex.muscle] = [];
    grouped[ex.muscle].push(ex);
  }

  let exHtml = '';
  for (const [key, exes] of Object.entries(grouped)) {
    const meta = MUSCLE_GROUPS[key];
    if (!meta) continue;
    exHtml += `<div class="ex-group">
      <div class="ex-group-title" style="color:${meta.color}">${meta.name}</div>`;

    for (const ex of exes) {
      const rx = formatPrescription(ex.prescription);
      const timeMin = (ex.timeSec / 60).toFixed(0);
      exHtml += `
        <div class="ex-row">
          <div class="ex-name">${ex.name}</div>
          <div class="ex-prescription">${rx}</div>
          <div class="ex-time">${timeMin}m</div>
        </div>`;
    }
    exHtml += `</div>`;
  }

  exContainer.innerHTML = exHtml;
}

function toggleExplainer(el) {
  const expand = el.querySelector('.rec-expand');
  if (expand.classList.contains('open')) {
    expand.style.maxHeight = '0';
    expand.classList.remove('open');
  } else {
    document.querySelectorAll('.rec-expand.open').forEach(other => {
      other.style.maxHeight = '0';
      other.classList.remove('open');
    });
    expand.classList.add('open');
    expand.style.maxHeight = expand.scrollHeight + 'px';
  }
}

// ============================================================
// MUSCLE GRID with Dual-Axis Color (Feature 4)
// Hue = strength percentile, Saturation = recency
// ============================================================
function getMuscleCardColor(muscleKey, daysSinceTrained, idealFreqDays) {
  const rmData = muscle1RMs[muscleKey];
  let percentile = rmData ? rmData.percentile : null;

  // For core or no data, use volume compliance for hue
  if (percentile === null) {
    const stat = muscleAnalysis ? muscleAnalysis[muscleKey] : null;
    if (stat) {
      const volRatio = stat.totalSets30d / (stat.idealSetsPerWeek * 4.3);
      percentile = Math.round(Math.min(volRatio, 1) * 75); // max 75th for volume-only
    } else {
      percentile = 25;
    }
  }

  // Hue: percentile -> color
  // <25 = red (0), 25-50 = orange (30), 50-75 = yellow-green (70), >75 = green (140)
  let hue;
  if (percentile < 25) hue = Math.round((percentile / 25) * 30);
  else if (percentile < 50) hue = 30 + Math.round(((percentile - 25) / 25) * 40);
  else if (percentile < 75) hue = 70 + Math.round(((percentile - 50) / 25) * 40);
  else hue = 110 + Math.round(Math.min((percentile - 75) / 25, 1) * 30);

  // Saturation/Brightness: recency
  // Recently trained = muted, overdue = vivid
  const overdueDays = Math.max(0, daysSinceTrained - idealFreqDays);
  let sat, light;
  if (daysSinceTrained === Infinity) {
    sat = 60; light = 25;
  } else if (overdueDays <= 0) {
    sat = 20; light = 16;
  } else if (overdueDays <= 2) {
    sat = 35; light = 19;
  } else {
    sat = Math.min(55 + overdueDays * 3, 70);
    light = Math.min(22 + overdueDays, 30);
  }

  return {
    bg: `hsla(${hue}, ${sat}%, ${light}%, 0.35)`,
    border: `hsla(${hue}, ${sat}%, ${light + 15}%, 0.4)`,
    textColor: `hsl(${hue}, ${Math.min(sat + 20, 85)}%, ${Math.min(light + 40, 75)}%)`,
  };
}

function renderMuscleGrid(muscleStats) {
  const grid = document.getElementById('muscle-grid');
  const entries = Object.entries(muscleStats).sort((a, b) => b[1].daysSinceTrained - a[1].daysSinceTrained);
  const maxSets = Math.max(...entries.map(([, s]) => s.totalSets30d), 1);

  grid.innerHTML = entries.map(([key, stat]) => {
    const barPct = Math.round((stat.totalSets30d / maxSets) * 100);
    const daysText = stat.daysSinceTrained === Infinity ? 'no data' : `${stat.daysSinceTrained}d ago`;
    const weeklyVol = (stat.totalSets30d / 4.3).toFixed(1);
    const colors = getMuscleCardColor(key, stat.daysSinceTrained, stat.idealFreqDays);
    const rmData = muscle1RMs[key];
    const pctText = rmData && rmData.percentile !== null
      ? (rmData.percentile >= 75 ? `Top ${100 - rmData.percentile}%` : `${rmData.percentile}th %ile`)
      : '';

    return `
      <div class="muscle-cell" style="background:${colors.bg};border-color:${colors.border}">
        <div class="muscle-name" style="color:${colors.textColor}">${stat.name}</div>
        <div class="muscle-stat">${daysText} \u00b7 ${weeklyVol}/${stat.idealSetsPerWeek}/wk</div>
        ${pctText ? `<div class="muscle-percentile" style="color:${colors.textColor}">${pctText}</div>` : ''}
        <div class="muscle-bar">
          <div class="muscle-bar-fill" style="width:${barPct}%;background:${colors.textColor}"></div>
        </div>
      </div>`;
  }).join('');
}

// ============================================================
// CALENDAR HEATMAP (Feature 5)
// ============================================================
let heatmapDayWorkouts = {};
let selectedHeatmapDay = null;

function renderHeatmap(workouts) {
  const { dayMuscleMap, dayWorkouts: dwMap } = buildHeatmapData(workouts);
  heatmapDayWorkouts = dwMap;

  const container = document.getElementById('heatmap-container');
  const muscleKeys = ['chest', 'back', 'shoulders', 'quads', 'hamstrings', 'glutes', 'biceps', 'triceps', 'calves', 'core'];
  const muscleLabels = ['Chest', 'Back', 'Shldr', 'Quads', 'Hams', 'Glts', 'Bis', 'Tris', 'Calves', 'Core'];

  // Generate last 8 weeks of days
  const now = new Date();
  const days = [];
  const numWeeks = 2;
  for (let i = numWeeks * 7 - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(d.getDate() - i);
    days.push(d.toISOString().split('T')[0]);
  }

  // Find max sets for opacity scaling
  let maxSets = 0;
  for (const [, muscles] of Object.entries(dayMuscleMap)) {
    for (const [, sets] of Object.entries(muscles)) {
      if (sets > maxSets) maxSets = sets;
    }
  }
  if (maxSets === 0) maxSets = 1;

  // Grid: columns = label + days, rows = day header + muscles
  const cols = days.length + 1; // +1 for label column
  const labelWidth = 54;
  const cellSize = 18;
  const gap = 3;

  let html = '';

  // Direction indicator row above the grid
  html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;padding:0 0 0 ${labelWidth + 2}px;">`;
  html += `<span style="font-size:12px;font-family:'JetBrains Mono',monospace;color:var(--text-dim);">2 wks ago</span>`;
  html += `<span style="font-size:12px;font-family:'JetBrains Mono',monospace;color:var(--accent);">Today \u2192</span>`;
  html += `</div>`;

  html += `<div class="heatmap-grid" style="grid-template-columns: ${labelWidth}px repeat(${days.length}, ${cellSize}px); grid-template-rows: 22px repeat(${muscleKeys.length}, ${cellSize}px);">`;

  // Day labels row (first cell is empty corner)
  html += `<div></div>`;
  for (let i = 0; i < days.length; i++) {
    const d = new Date(days[i] + 'T12:00:00');
    const isLast = i === days.length - 1;
    const isMonday = d.getDay() === 1;
    const isFirst = d.getDate() === 1;
    let label = '';
    if (isLast) {
      label = 'Now';
    } else if (isFirst) {
      label = d.toLocaleDateString('en-US', { month: 'short' });
    } else if (isMonday) {
      label = `${d.getMonth() + 1}/${d.getDate()}`;
    }
    html += `<div class="heatmap-day-labels" style="font-size:10px;justify-content:center;">${label}</div>`;
  }

  // Muscle rows
  for (let m = 0; m < muscleKeys.length; m++) {
    const mKey = muscleKeys[m];
    html += `<div class="heatmap-label">${muscleLabels[m]}</div>`;
    for (const day of days) {
      const sets = (dayMuscleMap[day] && dayMuscleMap[day][mKey]) || 0;
      const opacity = sets > 0 ? Math.max(0.25, Math.min(sets / maxSets, 1)) : 0;
      const bgColor = sets > 0
        ? `rgba(74, 222, 128, ${opacity})`
        : 'var(--surface2)';
      html += `<div class="heatmap-cell" style="background:${bgColor}" data-day="${day}" onclick="selectHeatmapDay('${day}')" title="${day}: ${sets} sets"></div>`;
    }
  }

  html += '</div>';
  container.innerHTML = html;
}

function selectHeatmapDay(day) {
  const detailEl = document.getElementById('heatmap-day-detail');
  const innerEl = document.getElementById('heatmap-day-detail-inner');

  // Toggle off if same day tapped
  if (selectedHeatmapDay === day && detailEl.classList.contains('open')) {
    detailEl.style.maxHeight = '0';
    detailEl.classList.remove('open');
    selectedHeatmapDay = null;
    return;
  }

  selectedHeatmapDay = day;
  const exercises = heatmapDayWorkouts[day] || [];
  const dateObj = new Date(day + 'T12:00:00');
  const dateStr = dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

  if (exercises.length === 0) {
    innerEl.innerHTML = `<div class="detail-date">${dateStr}</div><div style="color:var(--text-dim);font-size:12px;">Rest day</div>`;
  } else {
    let html = `<div class="detail-date">${dateStr}</div>`;
    for (const ex of exercises) {
      const weightStr = ex.bestWeight > 0 ? ` @ ${ex.bestWeight}lbs` : '';
      html += `<div class="detail-exercise">
        <span class="detail-name">${ex.name}</span>
        <span class="detail-sets">${ex.sets}s${ex.bestReps > 0 ? ` \u00d7 ${ex.bestReps}r` : ''}${weightStr}</span>
      </div>`;
    }
    innerEl.innerHTML = html;
  }

  detailEl.classList.add('open');
  detailEl.style.maxHeight = innerEl.scrollHeight + 24 + 'px';

  // Highlight selected column
  document.querySelectorAll('.heatmap-cell').forEach(cell => {
    cell.style.outline = cell.dataset.day === day ? '1.5px solid var(--accent)' : 'none';
  });
}

// ============================================================
// WEIGHT CHART with Strength Index (Feature 6)
// Dual Y-axis: left = bodyweight (lbs), right = Strength Index
// ============================================================
function renderWeightChart() {
  WEIGHT_DATA = getMergedWeightData();
  if (WEIGHT_DATA.length === 0) return;

  const cutoff = new Date();
  cutoff.setFullYear(cutoff.getFullYear() - 1);
  const recent = WEIGHT_DATA.filter(d => new Date(d.date) >= cutoff).reverse(); // oldest first

  if (recent.length === 0) return;

  const current = WEIGHT_DATA[0].value;
  const prev = WEIGHT_DATA.length > 1 ? WEIGHT_DATA[1].value : current;
  const delta = current - prev;

  document.getElementById('weight-current').textContent = current.toFixed(1);
  const deltaEl = document.getElementById('weight-delta');
  deltaEl.textContent = `${delta >= 0 ? '+' : ''}${delta.toFixed(1)}`;
  deltaEl.style.color = delta <= 0 ? 'var(--accent)' : 'var(--warn)';

  // Update profile bodyweight
  PROFILE.bodyweightLbs = current;

  // Strength Index display
  const siDisplay = document.getElementById('strength-index-display');
  const detailInner = document.getElementById('strength-detail-inner');
  const liftBenchmarks = {
    bench:    { label: 'Bench',    std: 'bench_press' },
    squat:    { label: 'Squat',    std: 'squat' },
    deadlift: { label: 'Deadlift', std: 'deadlift' },
    ohp:      { label: 'OHP',      std: 'overhead_press' },
    row:      { label: 'Row',      std: 'barbell_row' },
  };
  const bw = PROFILE.bodyweightLbs;
  let latestSI = null;

  if (strengthIndexData.length > 0) {
    latestSI = strengthIndexData[strengthIndexData.length - 1];
    siDisplay.textContent = `SI: ${latestSI.index.toFixed(2)}`;
  } else {
    siDisplay.textContent = `SI: --`;
  }

  // Always populate detail panel (benchmarks shown even without user data)
  let detailHtml = '<div style="display:grid;grid-template-columns:1fr;gap:2px;">';
  for (const [key, info] of Object.entries(liftBenchmarks)) {
    const lift = latestSI ? latestSI.lifts[key] : null;
    const std = STRENGTH_STANDARDS[info.std];
    const m = std ? std.multipliers : null;

    detailHtml += '<div style="padding:8px 0;border-bottom:1px solid var(--border);">';
    detailHtml += `<div style="font-weight:600;color:var(--text);font-size:14px;margin-bottom:4px;">${info.label}</div>`;

    if (lift && lift.rm > 0) {
      const pctile = estimatePercentile(info.std, lift.mult);
      const pctColor = pctile >= 75 ? 'var(--accent)' : pctile >= 50 ? 'var(--warn)' : 'var(--danger)';
      detailHtml += `<div style="color:var(--text-mid);font-size:13px;">You: <span style="color:var(--text);font-weight:600;">${lift.rm} lbs</span> (${lift.mult}\u00d7 BW) <span style="color:${pctColor};font-weight:600;">${pctile}th %ile</span></div>`;
    } else {
      detailHtml += `<div style="color:var(--text-dim);font-size:13px;">You: no data yet</div>`;
    }

    if (m) {
      const p50 = Math.round(m[2] * bw);
      const p75 = Math.round(m[3] * bw);
      const p90 = Math.round(m[4] * bw);
      detailHtml += `<div style="color:var(--text-dim);font-size:12px;margin-top:3px;">50th: ${p50}lbs \u00b7 75th: ${p75}lbs \u00b7 90th: ${p90}lbs</div>`;
    }
    detailHtml += '</div>';
  }
  detailHtml += '</div>';
  detailInner.innerHTML = detailHtml;

  // Canvas
  const canvas = document.getElementById('weight-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 150 * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = '150px';
  ctx.scale(dpr, dpr);

  const w = rect.width;
  const h = 150;
  const pad = { top: 12, bottom: 22, left: 0, right: 0 };
  const chartW = w - pad.left - pad.right;
  const chartH = h - pad.top - pad.bottom;

  // Weight line data
  const wValues = recent.map(d => d.value);
  const wMin = Math.min(...wValues) - 2;
  const wMax = Math.max(...wValues) + 2;
  const wXStep = chartW / Math.max(recent.length - 1, 1);

  // Draw weight line
  ctx.beginPath();
  ctx.strokeStyle = '#4ade80';
  ctx.lineWidth = 2.5;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  recent.forEach((d, i) => {
    const x = pad.left + i * wXStep;
    const y = pad.top + (1 - (d.value - wMin) / (wMax - wMin)) * chartH;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Weight gradient fill
  const lastX = pad.left + (recent.length - 1) * wXStep;
  ctx.lineTo(lastX, h - pad.bottom);
  ctx.lineTo(pad.left, h - pad.bottom);
  ctx.closePath();
  const gradient = ctx.createLinearGradient(0, 0, 0, h);
  gradient.addColorStop(0, 'rgba(74, 222, 128, 0.10)');
  gradient.addColorStop(1, 'rgba(74, 222, 128, 0)');
  ctx.fillStyle = gradient;
  ctx.fill();

  // Endpoint dots for weight
  [0, recent.length - 1].forEach(i => {
    const x = pad.left + i * wXStep;
    const y = pad.top + (1 - (recent[i].value - wMin) / (wMax - wMin)) * chartH;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#4ade80';
    ctx.fill();
  });

  // Strength Index line (if data available)
  if (strengthIndexData.length >= 2) {
    // Map SI data to the same X range as weight (by date)
    const wDates = recent.map(d => d.date);
    const firstDate = wDates[0];
    const lastDate = wDates[wDates.length - 1];
    const totalDays = (new Date(lastDate) - new Date(firstDate)) / (1000 * 60 * 60 * 24);

    // Filter SI data to same time range
    const siFiltered = strengthIndexData.filter(d => d.date >= firstDate && d.date <= lastDate);
    if (siFiltered.length >= 2) {
      const siValues = siFiltered.map(d => d.index);
      const siMin = Math.min(...siValues) - 0.1;
      const siMax = Math.max(...siValues) + 0.1;

      ctx.beginPath();
      ctx.strokeStyle = '#818cf8';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);

      siFiltered.forEach((d, i) => {
        const dayOffset = (new Date(d.date) - new Date(firstDate)) / (1000 * 60 * 60 * 24);
        const x = pad.left + (totalDays > 0 ? (dayOffset / totalDays) : 0) * chartW;
        const y = pad.top + (1 - (d.index - siMin) / (siMax - siMin)) * chartH;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.setLineDash([]);

      // Endpoint dots for SI
      [0, siFiltered.length - 1].forEach(i => {
        const d = siFiltered[i];
        const dayOffset = (new Date(d.date) - new Date(firstDate)) / (1000 * 60 * 60 * 24);
        const x = pad.left + (totalDays > 0 ? (dayOffset / totalDays) : 0) * chartW;
        const y = pad.top + (1 - (d.index - siMin) / (siMax - siMin)) * chartH;
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fillStyle = '#818cf8';
        ctx.fill();
      });
    }
  }

  // Date labels
  ctx.fillStyle = '#909098';
  ctx.font = '12px JetBrains Mono, monospace';
  ctx.textAlign = 'left';
  ctx.fillText(recent[0].date.substring(5), pad.left, h - 4);
  ctx.textAlign = 'right';
  ctx.fillText(recent[recent.length - 1].date.substring(5), w - pad.right, h - 4);
}

function toggleStrengthDetail() {
  const detail = document.getElementById('strength-detail');
  if (detail.classList.contains('open')) {
    detail.style.maxHeight = '0';
    detail.classList.remove('open');
  } else {
    detail.classList.add('open');
    detail.style.maxHeight = detail.querySelector('.strength-detail-inner').scrollHeight + 'px';
  }
}

// ============================================================
// WEIGHT INPUT (Feature 1)
// ============================================================
function toggleWeightForm() {
  const form = document.getElementById('weight-input-form');
  form.classList.toggle('open');
  if (form.classList.contains('open')) {
    const input = document.getElementById('weight-input');
    input.value = '';
    input.focus();
  }
}

function saveWeight() {
  const input = document.getElementById('weight-input');
  const val = parseFloat(input.value);
  if (isNaN(val) || val < 50 || val > 500) {
    input.style.borderColor = 'var(--danger)';
    setTimeout(() => { input.style.borderColor = 'var(--border)'; }, 1500);
    return;
  }
  const today = new Date().toISOString().split('T')[0];
  saveWeightEntry(today, val);
  toggleWeightForm();
  renderWeightChart();
}

// ============================================================
// TAB SWITCHING
// ============================================================
function switchTab(tab) {
  document.querySelectorAll('[id^="tab-"]').forEach(el => el.classList.add('hidden'));
  document.getElementById(`tab-${tab}`).classList.remove('hidden');
  document.querySelectorAll('.tab').forEach(el => {
    el.classList.toggle('active', el.dataset.tab === tab);
  });
  if (tab === 'weight') {
    setTimeout(renderWeightChart, 50);
  }
}

// ============================================================
// APP LIFECYCLE
// ============================================================
function showScreen(screen) {
  ['loading-screen', 'dashboard'].forEach(id => {
    document.getElementById(id).classList.toggle('hidden', id !== screen);
  });
}

function updateLoading(text) {
  document.getElementById('loading-text').textContent = text;
}

function showError(msg) {
  const area = document.getElementById('error-area');
  area.innerHTML = `<div class="error-msg">${msg}</div>`;
}

async function refreshData() {
  await loadDashboard();
}

async function loadDashboard() {
  showScreen('loading-screen');

  try {
    updateLoading('Loading workouts...');
    const workouts = await fetchWorkouts(10, 10);
    workoutCache = workouts;

    updateLoading('Analyzing...');

    // Merge weight data
    WEIGHT_DATA = getMergedWeightData();
    if (WEIGHT_DATA.length > 0) {
      PROFILE.bodyweightLbs = WEIGHT_DATA[0].value;
    }

    exerciseHistory = buildExerciseHistory(workouts);
    const stats = analyzeWorkouts(workouts);
    muscleAnalysis = stats;

    // Compute 1RM percentiles for each muscle group (Feature 4)
    muscle1RMs = computeMuscle1RMs(workouts, PROFILE.bodyweightLbs);

    // Compute Strength Index timeline (Feature 6)
    strengthIndexData = computeStrengthIndexTimeline(workouts, WEIGHT_DATA);

    const recs = generateRecommendations(stats);

    showScreen('dashboard');

    const now = new Date();
    document.getElementById('last-updated').textContent =
      `updated ${now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}`;

    renderRecommendations(recs);
    renderTimedSession(recs);
    renderMuscleGrid(stats);
    renderHeatmap(workouts);
    renderWeightChart();

  } catch (err) {
    console.error(err);
    showScreen('dashboard');
    showError(`Failed to load: ${err.message}`);
  }
}

// Boot
loadDashboard();
</script>
</body>
</html>
