<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0a">
<title>Workout Advisor</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0a;
  --surface: #131315;
  --surface2: #1a1a1e;
  --surface3: #222226;
  --border: #2a2a2e;
  --border-light: #333338;
  --text: #f4f4f6;
  --text-mid: #bcbcc4;
  --text-dim: #8e8e98;
  --accent: #4ade80;
  --accent-dim: rgba(74, 222, 128, 0.12);
  --warn: #fb923c;
  --warn-dim: rgba(251, 146, 60, 0.12);
  --danger: #f87171;
  --danger-dim: rgba(248, 113, 113, 0.12);
  --blue: #60a5fa;
  --blue-dim: rgba(96, 165, 250, 0.12);
  --purple: #c084fc;
  --purple-dim: rgba(192, 132, 252, 0.12);
  --strength: #818cf8;
  --strength-dim: rgba(129, 140, 248, 0.12);
  color-scheme: dark;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  background: #0a0a0a;
  background-color: #0a0a0a;
  color-scheme: dark;
}

body {
  font-family: 'Figtree', -apple-system, sans-serif;
  color: var(--text);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  line-height: 1.5;
}

.mono { font-family: 'JetBrains Mono', monospace; }

/* Layout */
.app {
  max-width: 480px;
  margin: 0 auto;
  padding: 20px 18px;
  padding-bottom: 120px;
  background: #0a0a0a;
}

/* Header */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0 16px;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--border);
}
.header h1 {
  font-size: 22px;
  font-weight: 700;
  letter-spacing: -0.5px;
  color: var(--text);
}
.header .subtitle {
  font-size: 12px;
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
  margin-top: 2px;
}
.btn-refresh {
  padding: 7px 14px;
  font-size: 13px;
  font-weight: 500;
  background: var(--surface2);
  color: var(--text-mid);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
  transition: all 0.2s ease;
  -webkit-tap-highlight-color: transparent;
}
.btn-refresh:active {
  background: var(--surface3);
  transform: scale(0.97);
}

/* Cards */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 18px;
  margin-bottom: 14px;
}
.card-title {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
}

/* Tabs */
.tabs {
  display: flex;
  gap: 4px;
  margin-bottom: 18px;
  background: var(--surface);
  border-radius: 12px;
  padding: 4px;
  border: 1px solid var(--border);
}
.tab {
  flex: 1;
  padding: 9px 6px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  border-radius: 9px;
  cursor: pointer;
  color: var(--text-dim);
  transition: all 0.25s ease;
  border: none;
  background: none;
  font-family: 'Figtree', sans-serif;
  -webkit-tap-highlight-color: transparent;
}
.tab.active {
  background: var(--surface3);
  color: var(--text);
}

/* ===================== */
/* RECOMMENDATIONS       */
/* ===================== */
.rec-item {
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: background 0.15s ease;
}
.rec-item:last-child { border-bottom: none; }
.rec-item:active { background: var(--surface2); }

.rec-row {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 14px 2px;
}
.rec-rank {
  font-family: 'JetBrains Mono', monospace;
  font-size: 16px;
  font-weight: 600;
  color: var(--accent);
  width: 24px;
  text-align: center;
  flex-shrink: 0;
}
.rec-info { flex: 1; min-width: 0; }
.rec-name {
  font-size: 17px;
  font-weight: 600;
  line-height: 1.3;
  color: var(--text);
}
.rec-detail {
  font-size: 14px;
  color: var(--text-mid);
  margin-top: 3px;
  font-family: 'JetBrains Mono', monospace;
}
.rec-urgency {
  font-size: 11px;
  font-weight: 600;
  padding: 5px 10px;
  border-radius: 6px;
  font-family: 'JetBrains Mono', monospace;
  flex-shrink: 0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.urgency-high { background: var(--danger-dim); color: var(--danger); }
.urgency-med { background: var(--warn-dim); color: var(--warn); }
.urgency-low { background: var(--accent-dim); color: var(--accent); }

/* Expandable explainer */
.rec-expand {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
}
.rec-expand.open {
  opacity: 1;
}
.rec-explainer {
  padding: 0 2px 14px 40px;
  font-size: 14px;
  color: var(--text-mid);
  line-height: 1.55;
}
.rec-explainer strong {
  color: var(--text);
  font-weight: 600;
}

/* ===================== */
/* EXERCISE PRESCRIPTIONS */
/* ===================== */
.session-summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--border);
}
.session-time {
  font-family: 'JetBrains Mono', monospace;
  font-size: 15px;
  font-weight: 600;
  color: var(--accent);
}
.session-count {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--text-dim);
}

.ex-group {
  margin-bottom: 18px;
}
.ex-group:last-child { margin-bottom: 0; }
.ex-group-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border);
}
.ex-row {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  padding: 8px 0;
}
.ex-name {
  font-size: 15px;
  font-weight: 500;
  flex: 1;
  min-width: 0;
  padding-right: 12px;
  color: var(--text);
}
.ex-prescription {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--accent);
  white-space: nowrap;
  flex-shrink: 0;
}
.ex-time {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--text-dim);
  white-space: nowrap;
  flex-shrink: 0;
  margin-left: 8px;
  min-width: 38px;
  text-align: right;
}

/* ===================== */
/* MUSCLE GRID (v1.1 simplified) */
/* ===================== */
.muscle-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.muscle-cell {
  border-radius: 10px;
  padding: 12px;
  transition: all 0.3s ease;
  border: 1px solid var(--border);
}
.muscle-name {
  font-size: 14px;
  font-weight: 600;
}
.muscle-stat {
  font-size: 12px;
  color: var(--text-mid);
  font-family: 'JetBrains Mono', monospace;
  margin-top: 5px;
}

/* ===================== */
/* WEIGHT TAB            */
/* ===================== */
.weight-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-bottom: 18px;
}
.weight-left {
  display: flex;
  align-items: baseline;
  gap: 8px;
}
.weight-chart {
  width: 100%;
  height: 150px;
  position: relative;
}
.weight-chart canvas { width: 100%; height: 100%; }
.weight-current {
  font-family: 'JetBrains Mono', monospace;
  font-size: 32px;
  font-weight: 700;
  letter-spacing: -1px;
  color: var(--text);
}
.weight-delta {
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
}
.weight-unit {
  font-size: 14px;
  color: var(--text-dim);
}
/* v1.1: SI label - subtle, non-interactive */
.strength-index-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 600;
  color: var(--strength);
  opacity: 0.85;
}

/* Constraints chips */
.constraints-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 14px;
}
.constraint-chip {
  padding: 5px 10px;
  font-size: 12px;
  font-weight: 500;
  font-family: 'JetBrains Mono', monospace;
  background: var(--surface2);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: 6px;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.15s ease;
  user-select: none;
}
.constraint-chip:active {
  transform: scale(0.96);
}
.constraint-chip.active {
  color: var(--accent);
  border-color: rgba(74, 222, 128, 0.3);
  background: var(--accent-dim);
}
/* v1.1: SI detail always visible */
.strength-detail-panel {
  margin-top: 16px;
  margin-bottom: 16px;
}
.strength-detail-inner {
  font-size: 13px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
  line-height: 1.7;
}
.chart-legend {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
}
.legend-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 5px;
  vertical-align: middle;
}

/* Weight input form */
.btn-log-weight {
  padding: 5px 12px;
  font-size: 13px;
  font-weight: 600;
  background: var(--accent-dim);
  color: var(--accent);
  border: 1px solid rgba(74, 222, 128, 0.25);
  border-radius: 7px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.2s ease;
}
.btn-log-weight:active {
  transform: scale(0.96);
}
.weight-input-form {
  display: none;
  align-items: center;
  gap: 8px;
  margin-bottom: 14px;
  padding: 12px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
}
.weight-input-form.open {
  display: flex;
}
.weight-input-form input {
  width: 90px;
  padding: 7px 10px;
  font-size: 15px;
  font-family: 'JetBrains Mono', monospace;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 7px;
  outline: none;
  -webkit-appearance: none;
}
.weight-input-form input:focus {
  border-color: var(--accent);
}
.weight-input-form .btn-save {
  padding: 7px 14px;
  font-size: 13px;
  font-weight: 600;
  background: var(--accent);
  color: #0a0a0a;
  border: none;
  border-radius: 7px;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
}
.weight-input-form .btn-cancel {
  padding: 7px 10px;
  font-size: 13px;
  background: none;
  color: var(--text-dim);
  border: none;
  cursor: pointer;
  font-family: 'Figtree', sans-serif;
}

/* ===================== */
/* HISTORY - HEATMAP (v1.1: no scroll) */
/* ===================== */
.heatmap-container {
  margin: 0 -4px;
  padding: 0 4px;
}
.heatmap-grid {
  display: grid;
  gap: 3px;
}
.heatmap-label {
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
  display: flex;
  align-items: center;
  padding-right: 6px;
  white-space: nowrap;
  position: sticky;
  left: 0;
  background: var(--surface);
  z-index: 2;
}
.heatmap-cell {
  width: 18px;
  height: 18px;
  border-radius: 3px;
  background: var(--surface2);
  cursor: pointer;
  transition: opacity 0.15s ease;
}
.heatmap-cell:active {
  opacity: 0.7;
}
.heatmap-day-labels {
  font-size: 10px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-dim);
  display: flex;
  align-items: flex-end;
  padding-bottom: 4px;
  text-align: center;
  justify-content: center;
}
.heatmap-day-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.25s ease;
  opacity: 0;
  margin-top: 0;
}
.heatmap-day-detail.open {
  opacity: 1;
  margin-top: 12px;
}
.heatmap-day-detail-inner {
  padding: 14px;
  background: var(--surface2);
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 14px;
  line-height: 1.6;
}
.heatmap-day-detail-inner .detail-date {
  font-weight: 600;
  margin-bottom: 8px;
  font-size: 13px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--text-mid);
}
.heatmap-day-detail-inner .detail-exercise {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  padding: 4px 0;
}
.heatmap-day-detail-inner .detail-name {
  font-weight: 500;
  font-size: 14px;
  color: var(--text);
}
.heatmap-day-detail-inner .detail-sets {
  font-size: 12px;
  font-family: 'JetBrains Mono', monospace;
  color: var(--accent);
  flex-shrink: 0;
}

/* ===================== */
/* HISTORY (legacy)      */
/* ===================== */
.workout-item {
  padding: 10px 0;
  border-bottom: 1px solid var(--border);
}
.workout-item:last-child { border-bottom: none; }
.workout-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
}
.workout-meta {
  font-size: 13px;
  color: var(--text-mid);
  font-family: 'JetBrains Mono', monospace;
  margin-top: 3px;
  line-height: 1.4;
}

/* ===================== */
/* LOADING & ERROR       */
/* ===================== */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  gap: 18px;
}
.spinner {
  width: 28px; height: 28px;
  border: 2.5px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.75s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-text {
  font-size: 14px;
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
}
.error-msg {
  background: var(--danger-dim);
  border: 1px solid rgba(248,113,113,0.2);
  border-radius: 10px;
  padding: 14px;
  font-size: 14px;
  color: var(--danger);
  margin-bottom: 14px;
  line-height: 1.4;
}

.hidden { display: none; }
</style>
</head>
<body>
<div class="app" id="app">

  <!-- Loading Screen -->
  <div id="loading-screen" class="loading">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">Connecting to Hevy...</div>
  </div>

  <!-- Main Dashboard -->
  <div id="dashboard" class="hidden">
    <div class="header">
      <div>
        <h1>Workout Advisor</h1>
        <div class="subtitle" id="last-updated">v1.1</div>
      </div>
      <button class="btn-refresh" onclick="refreshData()">Refresh</button>
    </div>

    <div id="error-area"></div>

    <div class="tabs">
      <button class="tab active" data-tab="today" onclick="switchTab('today')">Today</button>
      <button class="tab" data-tab="muscles" onclick="switchTab('muscles')">Muscles</button>
      <button class="tab" data-tab="history" onclick="switchTab('history')">History</button>
      <button class="tab" data-tab="weight" onclick="switchTab('weight')">Weight</button>
    </div>

    <!-- Today Tab -->
    <div id="tab-today">
      <div class="card">
        <div class="card-title">Recommended Training</div>
        <div id="recommendations"></div>
      </div>
      <div class="card">
        <div class="card-title">Today's Session</div>
        <div id="constraints-row" class="constraints-row"></div>
        <div id="session-summary"></div>
        <div id="suggested-exercises"></div>
      </div>
    </div>

    <!-- Muscles Tab -->
    <div id="tab-muscles" class="hidden">
      <div class="card">
        <div class="card-title">Muscle Group Status</div>
        <div id="muscle-grid" class="muscle-grid"></div>
      </div>
    </div>

    <!-- History Tab -->
    <div id="tab-history" class="hidden">
      <div class="card">
        <div class="card-title">Training Heatmap</div>
        <div class="heatmap-container" id="heatmap-container"></div>
        <div class="heatmap-day-detail" id="heatmap-day-detail">
          <div class="heatmap-day-detail-inner" id="heatmap-day-detail-inner"></div>
        </div>
      </div>
    </div>

    <!-- Weight Tab -->
    <div id="tab-weight" class="hidden">
      <div class="card">
        <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;">
          <span>Body Weight & Strength</span>
          <button class="btn-log-weight" onclick="toggleWeightForm()">+ Log</button>
        </div>
        <div class="weight-input-form" id="weight-input-form">
          <input type="number" id="weight-input" placeholder="lbs" step="0.1" inputmode="decimal">
          <button class="btn-save" onclick="saveWeight()">Save</button>
          <button class="btn-cancel" onclick="toggleWeightForm()">Cancel</button>
        </div>
        <div class="weight-header">
          <div class="weight-left">
            <span class="weight-current" id="weight-current">--</span>
            <span class="weight-delta" id="weight-delta"></span>
            <span class="weight-unit">lbs</span>
          </div>
          <div class="strength-index-label" id="strength-index-label">--</div>
        </div>
        <!-- v1.1: SI detail always visible, no tap toggle -->
        <div class="strength-detail-panel" id="strength-detail-panel">
          <div class="strength-detail-inner" id="strength-detail-inner"></div>
        </div>
        <div class="weight-chart">
          <canvas id="weight-canvas"></canvas>
        </div>
        <div class="chart-legend">
          <span><span class="legend-dot" style="background:var(--accent)"></span>Weight</span>
          <span><span class="legend-dot" style="background:var(--strength)"></span>Strength Score</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// WORKOUT ADVISOR v1.1
// ============================================================
// SCIENTIFIC FOUNDATION
// PILLAR 1: Volume-Hypertrophy Targets
// Source: Schoenfeld et al. (2017) "Dose-response relationship between weekly resistance
// training volume and increases in muscle mass"
// PILLAR 2: Strength Standards / Percentile Benchmarks
// Big Three: van den Hoek et al. (2024) "Normative data for the squat, bench press and
// deadlift" - 809,986 drug-tested competition entries from OpenPowerlifting
// PILLAR 3: 1RM Estimation - Brzycki (1993), Epley (1985)
// PILLAR 4: Progressive Overload - NSCA guideline: +2-10% when target reps achieved

// ============================================================
// USER PROFILE (silent - never displayed)
// ============================================================
const PROFILE = {
  dob: new Date('1989-07-21'),
  sex: 'male',
  ethnicity: 'caucasian',
  bodyweightLbs: 166,
  get age() {
    const today = new Date();
    let age = today.getFullYear() - this.dob.getFullYear();
    const m = today.getMonth() - this.dob.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < this.dob.getDate())) age--;
    return age;
  },
  get bodyweightKg() { return this.bodyweightLbs * 0.453592; }
};

// ============================================================
// STRENGTH STANDARDS (Pillar 2)
// BW multipliers for 1RM - male, ~75kg class, age 26-35
// Percentile: [10th, 25th, 50th, 75th, 90th]
// ============================================================
const STRENGTH_STANDARDS = {
  'bench_press':     { multipliers: [0.70, 0.95, 1.20, 1.50, 1.95], keyMuscle: 'chest' },
  'squat':           { multipliers: [0.85, 1.20, 1.60, 2.10, 2.83], keyMuscle: 'quads' },
  'deadlift':        { multipliers: [1.05, 1.45, 1.85, 2.50, 3.25], keyMuscle: 'back' },
  'overhead_press':  { multipliers: [0.40, 0.55, 0.72, 0.90, 1.15], keyMuscle: 'shoulders' },
  'barbell_row':     { multipliers: [0.50, 0.70, 0.90, 1.15, 1.45], keyMuscle: 'back' },
  'barbell_curl':    { multipliers: [0.25, 0.35, 0.50, 0.65, 0.85], keyMuscle: 'biceps' },
  'skull_crusher':   { multipliers: [0.20, 0.30, 0.40, 0.55, 0.70], keyMuscle: 'triceps' },
  'leg_curl':        { multipliers: [0.25, 0.35, 0.50, 0.65, 0.80], keyMuscle: 'hamstrings' },
  'hip_thrust':      { multipliers: [0.65, 0.95, 1.30, 1.75, 2.25], keyMuscle: 'glutes' },
  'calf_raise':      { multipliers: [0.50, 0.75, 1.00, 1.40, 1.85], keyMuscle: 'calves' },
  'plank_equivalent': { multipliers: null, keyMuscle: 'core' },
};

const MUSCLE_KEY_LIFTS = {
  chest:      { standard: 'bench_press',    patterns: [/bench press/i] },
  back:       { standard: 'deadlift',       patterns: [/deadlift/i, /barbell row/i, /bent over row/i] },
  shoulders:  { standard: 'overhead_press', patterns: [/overhead press/i, /shoulder press/i, /military press/i] },
  quads:      { standard: 'squat',          patterns: [/squat/i] },
  hamstrings: { standard: 'leg_curl',       patterns: [/leg curl/i, /romanian deadlift/i] },
  glutes:     { standard: 'hip_thrust',     patterns: [/hip thrust/i] },
  biceps:     { standard: 'barbell_curl',   patterns: [/barbell curl/i, /bicep curl/i] },
  triceps:    { standard: 'skull_crusher',  patterns: [/skullcrusher/i, /skull crusher/i, /tricep extension/i, /triceps extension/i, /triceps pushdown/i, /tricep pushdown/i] },
  calves:     { standard: 'calf_raise',     patterns: [/calf raise/i, /calf extension/i] },
  core:       { standard: 'plank_equivalent', patterns: [] },
};

// ============================================================
// 1RM ESTIMATION (Pillar 3)
// ============================================================
function estimate1RM_Brzycki(weightLbs, reps) {
  if (reps <= 0) return 0;
  if (reps === 1) return weightLbs;
  if (reps >= 37) return weightLbs;
  return weightLbs * (36 / (37 - reps));
}

function estimate1RM_Epley(weightLbs, reps) {
  if (reps <= 0) return 0;
  if (reps === 1) return weightLbs;
  return weightLbs * (1 + reps / 30);
}

function estimate1RM(weightLbs, reps) {
  if (reps <= 10) return estimate1RM_Brzycki(weightLbs, reps);
  return estimate1RM_Epley(weightLbs, reps);
}

// ============================================================
// PERCENTILE ESTIMATION
// ============================================================
function estimatePercentile(standardKey, bwMultiplier) {
  const std = STRENGTH_STANDARDS[standardKey];
  if (!std || !std.multipliers) return null;
  const m = std.multipliers;
  const pctiles = [10, 25, 50, 75, 90];

  if (bwMultiplier <= m[0]) return Math.round((bwMultiplier / m[0]) * 10);
  if (bwMultiplier >= m[4]) return Math.min(99, 90 + Math.round(((bwMultiplier - m[4]) / (m[4] * 0.2)) * 9));

  for (let i = 0; i < m.length - 1; i++) {
    if (bwMultiplier >= m[i] && bwMultiplier <= m[i + 1]) {
      const frac = (bwMultiplier - m[i]) / (m[i + 1] - m[i]);
      return Math.round(pctiles[i] + frac * (pctiles[i + 1] - pctiles[i]));
    }
  }
  return 50;
}

// ============================================================
// TIME ESTIMATION
// ============================================================
const TIME_CONSTANTS = {
  compoundSetSec: 45,
  isolationSetSec: 35,
  restBetweenSets: 120,
  transitionSec: 90,
  sessionCapMin: 60,
};

function calculateExerciseTime(exerciseName, sets) {
  const db = EXERCISE_DB[exerciseName];
  const isCompound = db && db.type === 'compound';
  const setTime = isCompound ? TIME_CONSTANTS.compoundSetSec : TIME_CONSTANTS.isolationSetSec;
  return (sets * setTime) + ((sets - 1) * TIME_CONSTANTS.restBetweenSets) + TIME_CONSTANTS.transitionSec;
}

// ============================================================
// SHARED HELPERS (v1.1 - Task 4)
// ============================================================

// Consistent working-set extraction used everywhere
function getWorkingSets(exercise) {
  return (exercise.sets || []).filter(s =>
    s.set_type === 'normal' || !s.set_type
  );
}

// Normalize exercise name for caching/matching
function normalizeExerciseName(name) {
  return (name || '').trim().toLowerCase().replace(/\s+/g, ' ').replace(/['']/g, "'");
}

// Format set counts: show decimals only when fractional
function formatSets(n) {
  return Number.isInteger(n) ? String(n) : n.toFixed(1);
}

// Classification cache keyed by template_id or normalized name
const _classifyCache = new Map();

function classifyExerciseCached(exercise) {
  const key = exercise.exercise_template_id || normalizeExerciseName(exercise.title || '');
  if (_classifyCache.has(key)) return _classifyCache.get(key);
  const result = classifyExercise(exercise.title || '');
  _classifyCache.set(key, result);
  return result;
}

// ============================================================
// EXERCISE -> MUSCLE GROUP MAPPING
// v1.1 Task 5: Specific patterns FIRST to beat generic matches
// ============================================================
const EXERCISE_MUSCLE_MAP = [
  // --- SPECIFIC patterns first (Task 5: priority fix) ---
  // These must come before generic patterns like /row/i, /squat/i, /deadlift/i

  // Specific row variants -> shoulders/back (before generic /row/i)
  { pattern: /upright row/i, primary: 'shoulders', secondary: ['back'] },
  { pattern: /face pull/i, primary: 'back', secondary: ['shoulders'] },

  // Specific squat variants (before generic /squat/i)
  { pattern: /goblet squat/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /front squat/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /hack squat/i, primary: 'quads', secondary: ['glutes'] },

  // Specific deadlift variants (before generic /deadlift/i)
  { pattern: /romanian deadlift/i, primary: 'hamstrings', secondary: ['glutes', 'back'] },
  { pattern: /stiff.?leg/i, primary: 'hamstrings', secondary: ['glutes', 'back'] },

  // Specific bench variants (before generic)
  { pattern: /close.?grip.*bench/i, primary: 'triceps', secondary: ['chest'] },

  // Specific dip (chest vs tricep)
  { pattern: /chest dip/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },

  // Chest
  { pattern: /bench press/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /chest press/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /chest fly/i, primary: 'chest', secondary: [] },
  { pattern: /cable fly/i, primary: 'chest', secondary: [] },
  { pattern: /push.?up/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },
  { pattern: /pec.?deck/i, primary: 'chest', secondary: [] },
  { pattern: /dip/i, primary: 'chest', secondary: ['triceps', 'shoulders'] },

  // Back
  { pattern: /deadlift/i, primary: 'back', secondary: ['hamstrings', 'glutes'] },
  { pattern: /pull.?up/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /chin.?up/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /lat.?pull/i, primary: 'back', secondary: ['biceps'] },
  { pattern: /rack pull/i, primary: 'back', secondary: ['hamstrings'] },
  { pattern: /back extension/i, primary: 'back', secondary: ['glutes'] },
  { pattern: /good morning/i, primary: 'back', secondary: ['hamstrings', 'glutes'] },
  { pattern: /shrug/i, primary: 'back', secondary: [] },
  { pattern: /row/i, primary: 'back', secondary: ['biceps'] },

  // Shoulders
  { pattern: /overhead press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /shoulder press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /military press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /arnold press/i, primary: 'shoulders', secondary: ['triceps'] },
  { pattern: /lateral raise/i, primary: 'shoulders', secondary: [] },
  { pattern: /front raise/i, primary: 'shoulders', secondary: [] },
  { pattern: /rear delt/i, primary: 'shoulders', secondary: [] },
  { pattern: /pike push/i, primary: 'shoulders', secondary: ['triceps'] },

  // Biceps
  { pattern: /bicep curl/i, primary: 'biceps', secondary: [] },
  { pattern: /hammer curl/i, primary: 'biceps', secondary: [] },
  { pattern: /concentration curl/i, primary: 'biceps', secondary: [] },
  { pattern: /preacher curl/i, primary: 'biceps', secondary: [] },
  { pattern: /barbell curl/i, primary: 'biceps', secondary: [] },
  { pattern: /kettlebell curl/i, primary: 'biceps', secondary: [] },

  // Triceps
  { pattern: /tricep/i, primary: 'triceps', secondary: [] },
  { pattern: /skull.?crush/i, primary: 'triceps', secondary: [] },

  // Quads
  { pattern: /squat/i, primary: 'quads', secondary: ['glutes', 'hamstrings'] },
  { pattern: /leg press/i, primary: 'quads', secondary: ['glutes'] },
  { pattern: /leg extension/i, primary: 'quads', secondary: [] },
  { pattern: /lunge/i, primary: 'quads', secondary: ['glutes', 'hamstrings'] },
  { pattern: /step.?up/i, primary: 'quads', secondary: ['glutes'] },

  // Hamstrings
  { pattern: /leg curl/i, primary: 'hamstrings', secondary: [] },
  { pattern: /nordic curl/i, primary: 'hamstrings', secondary: [] },

  // Glutes
  { pattern: /hip thrust/i, primary: 'glutes', secondary: ['hamstrings'] },
  { pattern: /glute/i, primary: 'glutes', secondary: [] },
  { pattern: /hip abduction/i, primary: 'glutes', secondary: [] },
  { pattern: /hip adduction/i, primary: 'glutes', secondary: [] },

  // Calves
  { pattern: /calf/i, primary: 'calves', secondary: [] },

  // Core
  { pattern: /crunch/i, primary: 'core', secondary: [] },
  { pattern: /sit.?up/i, primary: 'core', secondary: [] },
  { pattern: /plank/i, primary: 'core', secondary: [] },
  { pattern: /leg raise/i, primary: 'core', secondary: [] },
  { pattern: /knee raise/i, primary: 'core', secondary: [] },
  { pattern: /hanging/i, primary: 'core', secondary: [] },
  { pattern: /\bab\b/i, primary: 'core', secondary: [] },
  { pattern: /russian twist/i, primary: 'core', secondary: [] },
  { pattern: /woodchop/i, primary: 'core', secondary: [] },
];

const CARDIO_PATTERNS = [
  /treadmill/i, /elliptical/i, /\bbike\b/i, /cycling/i, /rowing machine/i,
  /jump rope/i, /jumping jack/i, /burpee/i, /stair/i, /running/i, /walking/i,
];

function classifyExercise(name) {
  for (const c of CARDIO_PATTERNS) {
    if (c.test(name)) return { primary: 'cardio', secondary: [] };
  }
  for (const m of EXERCISE_MUSCLE_MAP) {
    if (m.pattern.test(name)) return { primary: m.primary, secondary: m.secondary };
  }
  return { primary: 'other', secondary: [] };
}

// ============================================================
// MUSCLE GROUP METADATA (Pillar 1)
// ============================================================
const MUSCLE_GROUPS = {
  chest:      { name: 'Chest',      idealFreqDays: 4, color: '#f87171', idealSetsPerWeek: 14 },
  back:       { name: 'Back',       idealFreqDays: 4, color: '#60a5fa', idealSetsPerWeek: 16 },
  shoulders:  { name: 'Shoulders',  idealFreqDays: 4, color: '#c084fc', idealSetsPerWeek: 14 },
  biceps:     { name: 'Biceps',     idealFreqDays: 5, color: '#34d399', idealSetsPerWeek: 10 },
  triceps:    { name: 'Triceps',    idealFreqDays: 5, color: '#fbbf24', idealSetsPerWeek: 10 },
  quads:      { name: 'Quads',      idealFreqDays: 4, color: '#fb923c', idealSetsPerWeek: 14 },
  hamstrings: { name: 'Hamstrings', idealFreqDays: 5, color: '#f472b6', idealSetsPerWeek: 12 },
  glutes:     { name: 'Glutes',     idealFreqDays: 5, color: '#a78bfa', idealSetsPerWeek: 12 },
  calves:     { name: 'Calves',     idealFreqDays: 5, color: '#2dd4bf', idealSetsPerWeek: 10 },
  core:       { name: 'Core',       idealFreqDays: 3, color: '#e879f9', idealSetsPerWeek: 10 },
};

// ============================================================
// EXERCISE DATABASE
// ============================================================
const EXERCISE_DB = {
  'Bench Press (Barbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 185, sets: 4, reps: '6-8' },
  'Incline Bench Press (Dumbbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 60, sets: 3, reps: '8-10', note: 'per hand' },
  'Incline Bench Press (Barbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 155, sets: 4, reps: '6-8' },
  'Chest Fly (Machine)': { muscle: 'chest', type: 'isolation', benchmarkLbs: 140, sets: 3, reps: '10-12' },
  'Chest Fly (Dumbbell)': { muscle: 'chest', type: 'isolation', benchmarkLbs: 40, sets: 3, reps: '10-12', note: 'per hand' },
  'Chest Dip': { muscle: 'chest', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '8-12', note: 'bodyweight' },
  'Cable Fly Crossovers': { muscle: 'chest', type: 'isolation', benchmarkLbs: 30, sets: 3, reps: '12-15', note: 'per side' },
  'Chest Press (Machine)': { muscle: 'chest', type: 'compound', benchmarkLbs: 160, sets: 3, reps: '8-10' },
  'Decline Bench Press (Barbell)': { muscle: 'chest', type: 'compound', benchmarkLbs: 195, sets: 3, reps: '6-8' },

  'Bent Over Row (Barbell)': { muscle: 'back', type: 'compound', benchmarkLbs: 165, sets: 4, reps: '6-8' },
  'Pull Up': { muscle: 'back', type: 'compound', benchmarkLbs: 0, sets: 4, reps: '6-10', note: 'bodyweight' },
  'Chin Up': { muscle: 'back', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '6-10', note: 'bodyweight' },
  'Lat Pulldown (Cable)': { muscle: 'back', type: 'compound', benchmarkLbs: 140, sets: 3, reps: '8-10' },
  'Lat Pulldown (Machine)': { muscle: 'back', type: 'compound', benchmarkLbs: 140, sets: 3, reps: '8-10' },
  'Seated Row (Machine)': { muscle: 'back', type: 'compound', benchmarkLbs: 140, sets: 3, reps: '8-10' },
  'Dumbbell Row': { muscle: 'back', type: 'compound', benchmarkLbs: 65, sets: 3, reps: '8-10', note: 'per hand' },
  'Deadlift (Barbell)': { muscle: 'back', type: 'compound', benchmarkLbs: 275, sets: 3, reps: '5-6' },
  'Pendlay Row (Barbell)': { muscle: 'back', type: 'compound', benchmarkLbs: 155, sets: 4, reps: '5-8' },

  'Overhead Press (Barbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 115, sets: 4, reps: '6-8' },
  'Overhead Press (Dumbbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 45, sets: 3, reps: '8-10', note: 'per hand' },
  'Lateral Raise (Dumbbell)': { muscle: 'shoulders', type: 'isolation', benchmarkLbs: 20, sets: 4, reps: '12-15', note: 'per hand' },
  'Lateral Raise (Machine)': { muscle: 'shoulders', type: 'isolation', benchmarkLbs: 80, sets: 3, reps: '12-15' },
  'Arnold Press (Dumbbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 40, sets: 3, reps: '8-10', note: 'per hand' },
  'Seated Shoulder Press (Machine)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 120, sets: 3, reps: '8-10' },
  'Shoulder Press (Dumbbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 45, sets: 3, reps: '8-10', note: 'per hand' },
  'Standing Military Press (Barbell)': { muscle: 'shoulders', type: 'compound', benchmarkLbs: 115, sets: 4, reps: '6-8' },

  'Bicep Curl (Barbell)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 75, sets: 3, reps: '8-10' },
  'Bicep Curl (Dumbbell)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 30, sets: 3, reps: '10-12', note: 'per hand' },
  'Hammer Curl (Dumbbell)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '10-12', note: 'per hand' },
  'Hammer Curl (Cable)': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 35, sets: 3, reps: '10-12', note: 'per side' },
  'Concentration Curl': { muscle: 'biceps', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '10-12', note: 'per hand' },

  'Triceps Pushdown': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 60, sets: 3, reps: '10-12' },
  'Triceps Rope Pushdown': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 55, sets: 3, reps: '10-12' },
  'Triceps Extension (Cable)': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 50, sets: 3, reps: '10-12' },
  'Triceps Extension (Dumbbell)': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 30, sets: 3, reps: '10-12' },
  'Skullcrusher (Dumbbell)': { muscle: 'triceps', type: 'isolation', benchmarkLbs: 25, sets: 3, reps: '10-12', note: 'per hand' },
  'Triceps Dip': { muscle: 'triceps', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '8-12', note: 'bodyweight' },

  'Squat (Barbell)': { muscle: 'quads', type: 'compound', benchmarkLbs: 225, sets: 4, reps: '5-8' },
  'Squat (Bodyweight)': { muscle: 'quads', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight' },
  'Leg Press (Machine)': { muscle: 'quads', type: 'compound', benchmarkLbs: 360, sets: 4, reps: '8-10' },
  'Front Squat': { muscle: 'quads', type: 'compound', benchmarkLbs: 175, sets: 3, reps: '6-8' },
  'Goblet Squat': { muscle: 'quads', type: 'compound', benchmarkLbs: 60, sets: 3, reps: '10-12' },
  'Lunge (Dumbbell)': { muscle: 'quads', type: 'compound', benchmarkLbs: 40, sets: 3, reps: '10-12', note: 'per hand' },
  'Lunge': { muscle: 'quads', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },

  'Romanian Deadlift (Barbell)': { muscle: 'hamstrings', type: 'compound', benchmarkLbs: 205, sets: 4, reps: '8-10' },
  'Romanian Deadlift (Dumbbell)': { muscle: 'hamstrings', type: 'compound', benchmarkLbs: 55, sets: 3, reps: '8-10', note: 'per hand' },
  'Seated Leg Curl (Machine)': { muscle: 'hamstrings', type: 'isolation', benchmarkLbs: 110, sets: 3, reps: '10-12' },

  'Hip Thrust (Barbell)': { muscle: 'glutes', type: 'compound', benchmarkLbs: 225, sets: 4, reps: '8-10' },
  'Hip Thrust (Machine)': { muscle: 'glutes', type: 'compound', benchmarkLbs: 225, sets: 3, reps: '8-10' },
  'Hip Thrust': { muscle: 'glutes', type: 'compound', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
  'Glute Kickback (Machine)': { muscle: 'glutes', type: 'isolation', benchmarkLbs: 80, sets: 3, reps: '12-15' },
  'Hip Abduction (Machine)': { muscle: 'glutes', type: 'isolation', benchmarkLbs: 120, sets: 3, reps: '12-15' },
  'Hip Adduction (Machine)': { muscle: 'glutes', type: 'isolation', benchmarkLbs: 120, sets: 3, reps: '12-15' },

  'Standing Calf Raise': { muscle: 'calves', type: 'isolation', benchmarkLbs: 180, sets: 4, reps: '12-15' },
  'Seated Calf Raise': { muscle: 'calves', type: 'isolation', benchmarkLbs: 90, sets: 3, reps: '12-15' },
  'Calf Extension (Machine)': { muscle: 'calves', type: 'isolation', benchmarkLbs: 140, sets: 3, reps: '12-15' },

  'Hanging Leg Raise': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '10-15', note: 'bodyweight' },
  'Hanging Knee Raise': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
  'Crunch': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight' },
  'Crunch (Machine)': { muscle: 'core', type: 'isolation', benchmarkLbs: 80, sets: 3, reps: '12-15' },
  'Decline Crunch': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
  'Plank': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '45-60s', note: 'hold' },
  'Sit Up': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '15-20', note: 'bodyweight' },
  'Leg Raise Parallel Bars': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '10-15', note: 'bodyweight' },
  'Knee Raise Parallel Bars': { muscle: 'core', type: 'isolation', benchmarkLbs: 0, sets: 3, reps: '12-15', note: 'bodyweight' },
};

const MUSCLE_EXERCISE_PICKS = {
  chest:      ['Bench Press (Barbell)', 'Incline Bench Press (Dumbbell)', 'Chest Fly (Machine)', 'Cable Fly Crossovers'],
  back:       ['Bent Over Row (Barbell)', 'Pull Up', 'Lat Pulldown (Cable)', 'Seated Row (Machine)'],
  shoulders:  ['Overhead Press (Barbell)', 'Lateral Raise (Dumbbell)', 'Arnold Press (Dumbbell)', 'Lateral Raise (Machine)'],
  biceps:     ['Bicep Curl (Barbell)', 'Hammer Curl (Dumbbell)', 'Concentration Curl'],
  triceps:    ['Triceps Pushdown', 'Triceps Extension (Cable)', 'Skullcrusher (Dumbbell)'],
  quads:      ['Squat (Barbell)', 'Leg Press (Machine)', 'Front Squat', 'Lunge (Dumbbell)'],
  hamstrings: ['Romanian Deadlift (Barbell)', 'Seated Leg Curl (Machine)'],
  glutes:     ['Hip Thrust (Barbell)', 'Glute Kickback (Machine)', 'Hip Abduction (Machine)'],
  calves:     ['Standing Calf Raise', 'Seated Calf Raise'],
  core:       ['Hanging Leg Raise', 'Crunch (Machine)', 'Plank'],
};

// ============================================================
// BODY WEIGHT DATA - Baseline from Strong CSV export
// ============================================================
const WEIGHT_DATA_BASELINE = [
  { date: '2026-01-18', value: 166.0 },
  { date: '2026-01-17', value: 164.4 },
  { date: '2025-11-30', value: 168.0 },
  { date: '2025-11-04', value: 167.1 },
  { date: '2025-11-01', value: 168.2 },
  { date: '2025-10-01', value: 169.0 },
  { date: '2025-09-12', value: 169.0 },
  { date: '2025-09-07', value: 168.0 },
  { date: '2025-07-15', value: 172.0 },
  { date: '2025-05-23', value: 174.2 },
  { date: '2025-05-15', value: 172.0 },
  { date: '2025-04-30', value: 173.0 },
];

// ============================================================
// WEIGHT localStorage FUNCTIONS
// ============================================================
function getStoredWeightEntries() {
  try {
    const raw = localStorage.getItem('weightHistory');
    if (!raw) return [];
    return JSON.parse(raw);
  } catch (e) {
    return [];
  }
}

function saveWeightEntry(date, value) {
  const entries = getStoredWeightEntries();
  entries.push({ date, value });
  localStorage.setItem('weightHistory', JSON.stringify(entries));
}

function getMergedWeightData() {
  const stored = getStoredWeightEntries();
  const all = [...WEIGHT_DATA_BASELINE, ...stored];
  const byDate = {};
  for (const entry of all) {
    byDate[entry.date] = entry.value;
  }
  return Object.entries(byDate)
    .map(([date, value]) => ({ date, value }))
    .sort((a, b) => b.date.localeCompare(a.date));
}

// ============================================================
// STATE
// ============================================================
const apiKey = 'e38cf123-61c4-4b8c-ae25-7442d6d9c874';
let workoutCache = null;
let muscleAnalysis = null;
let exerciseHistory = {};
let muscle1RMs = {};
let strengthIndexData = [];
let WEIGHT_DATA = [];
let LAST_RECS = null;

// ============================================================
// SESSION PREFS (Constraints Knob)
// ============================================================
const PREFS_KEY = 'wa_prefs_v1_1';
const PREFS_DEFAULTS = {
  sessionCapMin: 60,
  equipment: 'gym',
  avoidOHP: false,
  strictness: 'balanced',
};

function loadPrefs() {
  try {
    const raw = localStorage.getItem(PREFS_KEY);
    if (!raw) return { ...PREFS_DEFAULTS };
    return { ...PREFS_DEFAULTS, ...JSON.parse(raw) };
  } catch (e) { return { ...PREFS_DEFAULTS }; }
}

function savePrefs(prefs) {
  localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
}

let sessionPrefs = loadPrefs();

const GYM_ONLY_REGEX = /(Machine|Cable|Smith|Leg Press|Hack Squat|Pec Deck)/i;

// Chip definitions
const CHIP_DEFS = [
  { key: 'sessionCapMin', label: v => `${v}m`, values: [30, 45, 60] },
  { key: 'equipment', label: v => v === 'gym' ? 'Gym' : 'Home', values: ['gym', 'home'] },
  { key: 'avoidOHP', label: v => v ? 'No OHP' : 'OHP OK', values: [false, true] },
  { key: 'strictness', label: v => v.charAt(0).toUpperCase() + v.slice(1), values: ['loose', 'balanced', 'strict'] },
];

function renderConstraintChips() {
  const row = document.getElementById('constraints-row');
  if (!row) return;
  row.innerHTML = CHIP_DEFS.map(def => {
    const current = sessionPrefs[def.key];
    const isNonDefault = current !== PREFS_DEFAULTS[def.key];
    return `<div class="constraint-chip${isNonDefault ? ' active' : ''}" data-key="${def.key}" onclick="cycleChip('${def.key}')">${def.label(current)}</div>`;
  }).join('');
}

function cycleChip(key) {
  const def = CHIP_DEFS.find(d => d.key === key);
  if (!def) return;
  const current = sessionPrefs[key];
  const idx = def.values.indexOf(current);
  const next = def.values[(idx + 1) % def.values.length];
  sessionPrefs[key] = next;
  savePrefs(sessionPrefs);
  renderConstraintChips();
  if (LAST_RECS) renderTimedSession(LAST_RECS);
}

// ============================================================
// API + CACHING (v1.1 Task 7)
// ============================================================
const API_BASE = 'https://api.hevyapp.com/v1';
const CACHE_KEY = 'workoutCache_v1';
const CACHE_STALE_MS = 8 * 60 * 60 * 1000; // 8 hours

function getCachedWorkouts() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed.ts || !parsed.data) return null;
    return parsed;
  } catch (e) { return null; }
}

function setCachedWorkouts(workouts) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), data: workouts }));
  } catch (e) { /* storage full - ignore */ }
}

function isCacheStale(cached) {
  return !cached || (Date.now() - cached.ts) > CACHE_STALE_MS;
}

async function fetchWorkouts(pageSize = 10, maxPages = 10) {
  const allWorkouts = [];
  let page = 1;
  let totalPages = 1;

  while (page <= totalPages && page <= maxPages) {
    updateLoading(`Loading workouts (${allWorkouts.length})...`);
    const resp = await fetch(`${API_BASE}/workouts?page=${page}&pageSize=${pageSize}`, {
      headers: { 'api-key': apiKey }
    });
    if (!resp.ok) throw new Error(`API error ${resp.status}: ${resp.statusText}`);
    const data = await resp.json();
    totalPages = data.page_count || 1;
    if (data.workouts) allWorkouts.push(...data.workouts);
    page++;
  }
  return allWorkouts;
}

// ============================================================
// UNIFIED PREPROCESS PIPELINE (v1.1 Task 6)
// Single pass over workouts producing all downstream data
// ============================================================
function preprocessWorkouts(workouts, bodyweightLbs) {
  const now = new Date();
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  // Sort oldest -> newest for history building
  const sorted = [...workouts].sort((a, b) =>
    new Date(a.start_time || a.created_at) - new Date(b.start_time || b.created_at)
  );

  // ---- Output structures ----
  const exHistory = {};
  const muscleStats = {};
  const muscle1RMInputs = {}; // { muscleKey: { best1RM, exercise } }
  const siRolling1RMs = { bench: 0, squat: 0, deadlift: 0, ohp: 0, row: 0 };
  const siTimeline = [];
  const heatmapDayMuscle = {};
  const heatmapDayWorkouts = {};

  // Init muscle stats
  for (const [key, meta] of Object.entries(MUSCLE_GROUPS)) {
    muscleStats[key] = {
      key, name: meta.name, color: meta.color,
      idealFreqDays: meta.idealFreqDays, idealSetsPerWeek: meta.idealSetsPerWeek,
      lastTrained: null, daysSinceTrained: Infinity,
      totalSets30d: 0, totalVolume30d: 0, sessionCount30d: 0, exercises: new Set(),
    };
    muscle1RMInputs[key] = { best1RM: 0, exercise: '' };
  }

  // Weight data sorted for SI interpolation
  const weightSorted = [...WEIGHT_DATA].sort((a, b) => a.date.localeCompare(b.date));
  function getBodyweightAt(dateStr) {
    let bw = bodyweightLbs;
    for (const w of weightSorted) {
      if (w.date <= dateStr) bw = w.value;
      else break;
    }
    return bw;
  }

  // ---- Single pass ----
  for (const w of sorted) {
    const wDate = new Date(w.start_time || w.created_at);
    const dateStr = wDate.toISOString().split('T')[0];
    const isRecent = wDate >= thirtyDaysAgo;
    const musclesThisWorkout = new Set();
    let siUpdated = false;

    if (!heatmapDayMuscle[dateStr]) heatmapDayMuscle[dateStr] = {};
    if (!heatmapDayWorkouts[dateStr]) heatmapDayWorkouts[dateStr] = [];

    for (const ex of (w.exercises || [])) {
      const name = ex.title || '';
      if (!name) continue;

      const classification = classifyExerciseCached(ex);
      const workingSets = getWorkingSets(ex);

      // --- Exercise history ---
      if (workingSets.length > 0) {
        let bestWeight = 0, bestReps = 0;
        for (const s of workingSets) {
          const wLbs = Math.round((s.weight_kg || 0) * 2.20462);
          if (wLbs > bestWeight) { bestWeight = wLbs; bestReps = s.reps || 0; }
        }
        if (!exHistory[name]) exHistory[name] = { weights: [], dates: [] };
        exHistory[name].lastWeightLbs = bestWeight;
        exHistory[name].lastReps = bestReps;
        exHistory[name].lastDate = wDate;
        exHistory[name].lastSets = workingSets.length;
        exHistory[name].weights.push(bestWeight);
        exHistory[name].dates.push(wDate);
      }

      if (classification.primary === 'cardio' || classification.primary === 'other') continue;

      const setCount = workingSets.length;
      const allMuscles = [classification.primary, ...classification.secondary];

      // --- Muscle stats (30d) ---
      for (const muscle of allMuscles) {
        if (!muscleStats[muscle]) continue;
        const stat = muscleStats[muscle];
        const isPrimary = muscle === classification.primary;

        if (!stat.lastTrained || wDate > stat.lastTrained) {
          stat.lastTrained = wDate;
          stat.daysSinceTrained = Math.floor((now - wDate) / (1000 * 60 * 60 * 24));
        }

        if (isRecent) {
          const weight = isPrimary ? 1.0 : 0.5;
          stat.totalSets30d += setCount * weight;
          for (const s of workingSets) {
            stat.totalVolume30d += (s.reps || 0) * (s.weight_kg || 0) * weight;
          }
          stat.exercises.add(name);
          musclesThisWorkout.add(muscle);
        }
      }

      // --- Heatmap data ---
      for (const muscle of allMuscles) {
        if (!MUSCLE_GROUPS[muscle]) continue;
        const isPrimary = muscle === classification.primary;
        const weight = isPrimary ? 1.0 : 0.5;
        heatmapDayMuscle[dateStr][muscle] = (heatmapDayMuscle[dateStr][muscle] || 0) + setCount * weight;
      }

      // Heatmap detail
      const bestSet = workingSets.reduce((best, s) => {
        const wLbs = Math.round((s.weight_kg || 0) * 2.20462);
        return wLbs > (best.w || 0) ? { w: wLbs, r: s.reps || 0 } : best;
      }, {});
      heatmapDayWorkouts[dateStr].push({
        name, sets: setCount,
        bestWeight: bestSet.w || 0, bestReps: bestSet.r || 0,
      });

      // --- Muscle 1RM (last 30d) ---
      if (isRecent) {
        for (const [muscleKey, keyLift] of Object.entries(MUSCLE_KEY_LIFTS)) {
          const matched = keyLift.patterns.some(p => p.test(name));
          if (!matched) continue;
          for (const s of workingSets) {
            const wLbs = (s.weight_kg || 0) * 2.20462;
            const reps = s.reps || 0;
            if (wLbs <= 0 || reps <= 0) continue;
            const est = estimate1RM(wLbs, reps);
            if (est > muscle1RMInputs[muscleKey].best1RM) {
              muscle1RMInputs[muscleKey].best1RM = est;
              muscle1RMInputs[muscleKey].exercise = name;
            }
          }
        }
      }

      // --- Strength index timeline ---
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        const matched = liftDef.patterns.some(p => p.test(name));
        if (!matched) continue;
        for (const s of workingSets) {
          const wLbs = (s.weight_kg || 0) * 2.20462;
          const reps = s.reps || 0;
          if (wLbs <= 0 || reps <= 0) continue;
          const est = estimate1RM(wLbs, reps);
          if (est > siRolling1RMs[liftKey]) {
            siRolling1RMs[liftKey] = est;
            siUpdated = true;
          }
        }
      }
    }

    // Session count
    if (isRecent) {
      for (const m of musclesThisWorkout) {
        if (muscleStats[m]) muscleStats[m].sessionCount30d++;
      }
    }

    // Strength Score data point (normalized: 1.0 = 50th percentile for 36yo male)
    const hasData = Object.values(siRolling1RMs).some(v => v > 0);
    if (hasData) {
      const bw = getBodyweightAt(dateStr);
      const lifts = {};
      let totalWeight = 0;

      // First pass: identify which lifts have data and sum their weights
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        if (siRolling1RMs[liftKey] > 0) totalWeight += liftDef.weight;
      }

      // Second pass: compute normalized score with re-weighted lifts
      let index = 0;
      for (const [liftKey, liftDef] of Object.entries(STRENGTH_INDEX_LIFTS)) {
        const mult = bw > 0 ? siRolling1RMs[liftKey] / bw : 0;
        const normalized = liftDef.p50 > 0 ? mult / liftDef.p50 : 0;
        const adjustedWeight = totalWeight > 0 ? liftDef.weight / totalWeight : 0;
        if (siRolling1RMs[liftKey] > 0) {
          index += normalized * adjustedWeight;
        }
        lifts[liftKey] = { rm: Math.round(siRolling1RMs[liftKey]), mult: Math.round(mult * 100) / 100 };
      }
      siTimeline.push({ date: dateStr, index: Math.round(index * 100) / 100, lifts: { ...lifts } });
    }
  }

  // Finalize muscle 1RMs with percentiles
  const muscle1RMResults = {};
  for (const [key, data] of Object.entries(muscle1RMInputs)) {
    const keyLift = MUSCLE_KEY_LIFTS[key];
    const bwMult = bodyweightLbs > 0 ? data.best1RM / bodyweightLbs : 0;
    const percentile = estimatePercentile(keyLift.standard, bwMult);
    muscle1RMResults[key] = {
      best1RM: Math.round(data.best1RM),
      bwMult: Math.round(bwMult * 100) / 100,
      percentile, exercise: data.exercise,
    };
  }

  return {
    exerciseHistory: exHistory,
    muscleStats,
    muscle1RMs: muscle1RMResults,
    strengthIndexTimeline: siTimeline,
    heatmapDayMuscle,
    heatmapDayWorkouts,
  };
}

// ============================================================
// STRENGTH INDEX LIFT DEFINITIONS
// ============================================================
// p50 = 50th percentile BW multiplier, age-adjusted for 36yo male (~75kg class)
// Base values from van den Hoek et al. 2024 (26-35 bracket), reduced ~4% for 36-39 bracket
// Row p50 derived from approximate StrengthLevel data (same age adjustment applied)
const STRENGTH_INDEX_LIFTS = {
  bench:    { weight: 0.20, p50: 1.15, patterns: [/bench press.*barbell/i, /^bench press$/i] },
  squat:    { weight: 0.25, p50: 1.54, patterns: [/squat.*barbell/i, /^squat$/i, /barbell.*squat/i] },
  deadlift: { weight: 0.30, p50: 1.78, patterns: [/^deadlift/i, /deadlift.*barbell/i] },
  ohp:      { weight: 0.10, p50: 0.69, patterns: [/overhead press/i, /shoulder press/i, /military press/i] },
  row:      { weight: 0.15, p50: 0.86, patterns: [/barbell row/i, /bent over row/i, /pendlay row/i, /seated row/i, /cable row/i, /dumbbell row/i] },
};

// ============================================================
// SMART WEIGHT PRESCRIPTION (Pillar 4)
// ============================================================
function prescribeExercise(name) {
  const db = EXERCISE_DB[name];
  const hist = exerciseHistory[name];

  let sets = db ? db.sets : 3;
  let reps = db ? db.reps : '8-10';
  let weightLbs = db ? db.benchmarkLbs : 0;
  let note = db ? (db.note || '') : '';

  if (hist && hist.lastWeightLbs > 0) {
    const lastW = hist.lastWeightLbs;
    const trend = hist.weights.length >= 3
      ? hist.weights.slice(-3).reduce((a, b) => a + b, 0) / 3
      : lastW;

    if (db && lastW < db.benchmarkLbs * 0.85) {
      weightLbs = Math.min(Math.round(trend * 1.05 / 5) * 5, db.benchmarkLbs);
    } else {
      weightLbs = Math.round(trend * 1.025 / 5) * 5;
    }
    if (hist.lastSets >= 2 && hist.lastSets <= 6) sets = hist.lastSets;
  } else if (!db) {
    return { sets: 3, reps: '8-10', weightLbs: 0, note: 'no data' };
  }

  if (note === 'bodyweight' || note === 'hold') weightLbs = 0;
  return { sets, reps, weightLbs, note };
}

function formatPrescription(p) {
  let str = `${p.sets}\u00d7${p.reps}`;
  if (p.weightLbs > 0) str += ` @ ${p.weightLbs}lbs`;
  if (p.note === 'per hand' || p.note === 'per side') str += '/ea';
  return str;
}

// ============================================================
// IMBALANCE DETECTION & RECOMMENDATIONS
// ============================================================
function generateRecommendations(muscleStats) {
  const recs = [];
  const weeklyVolumes = {};
  for (const [key, stat] of Object.entries(muscleStats)) {
    weeklyVolumes[key] = stat.totalSets30d / 4.3;
  }

  const volumeRatios = {};
  let maxRatio = 0;
  for (const [key, stat] of Object.entries(muscleStats)) {
    const ratio = weeklyVolumes[key] / stat.idealSetsPerWeek;
    volumeRatios[key] = ratio;
    if (ratio > maxRatio) maxRatio = ratio;
  }

  for (const [key, stat] of Object.entries(muscleStats)) {
    const recencyScore = Math.min(stat.daysSinceTrained / stat.idealFreqDays, 3);
    const idealSets30d = stat.idealSetsPerWeek * 4.3;
    const volumeDeficit = Math.max(0, 1 - (stat.totalSets30d / idealSets30d));
    const imbalanceScore = maxRatio > 0 ? Math.max(0, 1 - (volumeRatios[key] / maxRatio)) : 0;
    const score = (recencyScore * 0.4) + (volumeDeficit * 0.3) + (imbalanceScore * 0.3);

    let urgency = 'low';
    if (stat.daysSinceTrained >= stat.idealFreqDays * 2 || (volumeDeficit > 0.6 && imbalanceScore > 0.5)) {
      urgency = 'high';
    } else if (stat.daysSinceTrained >= stat.idealFreqDays || volumeDeficit > 0.3) {
      urgency = 'med';
    }

    const weeklyActual = weeklyVolumes[key].toFixed(1);
    const weeklyIdeal = stat.idealSetsPerWeek;
    let explainer = '';

    if (stat.daysSinceTrained === Infinity) {
      explainer = `No ${stat.name.toLowerCase()} training found in your history. This muscle group needs attention to build a balanced physique.`;
    } else {
      const parts = [];
      if (stat.daysSinceTrained >= stat.idealFreqDays * 2) {
        parts.push(`Last trained <strong>${stat.daysSinceTrained} days ago</strong> \u2014 ideally every ${stat.idealFreqDays} days for optimal growth`);
      } else if (stat.daysSinceTrained >= stat.idealFreqDays) {
        parts.push(`Trained ${stat.daysSinceTrained} days ago, slightly past the ${stat.idealFreqDays}-day window`);
      }
      if (volumeDeficit > 0.3) {
        parts.push(`Volume is <strong>${weeklyActual} sets/week</strong> vs the ${weeklyIdeal} recommended \u2014 ${Math.round(volumeDeficit * 100)}% below target`);
      }
      if (imbalanceScore > 0.4) {
        const topMuscle = Object.entries(volumeRatios).sort((a, b) => b[1] - a[1])[0];
        if (topMuscle[0] !== key) {
          parts.push(`Lagging behind your ${muscleStats[topMuscle[0]].name.toLowerCase()} proportionally \u2014 focus here to balance out`);
        }
      }
      if (parts.length === 0) {
        parts.push(`On track. ${weeklyActual} sets/week is close to the ${weeklyIdeal} target. Last trained ${stat.daysSinceTrained} days ago.`);
      }
      explainer = parts.join('. ') + '.';
    }

    recs.push({
      key, name: stat.name, score, urgency,
      daysSince: stat.daysSinceTrained,
      sets30d: stat.totalSets30d,
      detail: stat.daysSinceTrained === Infinity
        ? 'no data'
        : `${stat.daysSinceTrained}d ago \u00b7 ${formatSets(stat.totalSets30d)} sets/30d`,
      explainer,
      weeklyActual: parseFloat(weeklyActual),
      weeklyIdeal,
    });
  }

  recs.sort((a, b) => b.score - a.score);
  return recs;
}

// ============================================================
// SESSION PLANNING (v1.1 Task 8 - upgraded)
// Improved: fatigue-aware, ensures isolation for #1 priority,
// avoids stacking heavy compounds for same movement pattern
// ============================================================
const MUSCLE_EXERCISE_CAP = {
  caps: [3, 2, 2],
};

// Movement pattern groups to avoid stacking
const MOVEMENT_PATTERNS = {
  'horizontal_push': ['Bench Press (Barbell)', 'Incline Bench Press (Dumbbell)', 'Incline Bench Press (Barbell)', 'Chest Press (Machine)', 'Decline Bench Press (Barbell)'],
  'vertical_push': ['Overhead Press (Barbell)', 'Overhead Press (Dumbbell)', 'Arnold Press (Dumbbell)', 'Seated Shoulder Press (Machine)', 'Shoulder Press (Dumbbell)', 'Standing Military Press (Barbell)'],
  'horizontal_pull': ['Bent Over Row (Barbell)', 'Seated Row (Machine)', 'Dumbbell Row', 'Pendlay Row (Barbell)'],
  'vertical_pull': ['Pull Up', 'Chin Up', 'Lat Pulldown (Cable)', 'Lat Pulldown (Machine)'],
  'knee_dominant': ['Squat (Barbell)', 'Leg Press (Machine)', 'Front Squat', 'Goblet Squat'],
  'hip_dominant': ['Deadlift (Barbell)', 'Romanian Deadlift (Barbell)', 'Hip Thrust (Barbell)', 'Hip Thrust (Machine)'],
};

function getMovementPattern(exName) {
  for (const [pattern, exercises] of Object.entries(MOVEMENT_PATTERNS)) {
    if (exercises.includes(exName)) return pattern;
  }
  return null;
}

function buildTimedSession(recs, prefs) {
  prefs = prefs || sessionPrefs;
  const topKeys = recs.slice(0, 3).map(r => r.key);
  const recScores = {};
  recs.forEach(r => { recScores[r.key] = r.score; });

  const muscleCaps = {};
  topKeys.forEach((key, idx) => { muscleCaps[key] = MUSCLE_EXERCISE_CAP.caps[idx] || 2; });

  // Build candidates
  const candidates = [];
  for (const key of topKeys) {
    const picks = MUSCLE_EXERCISE_PICKS[key] || [];
    const cappedPicks = picks.slice(0, muscleCaps[key]);
    const groupPriority = recScores[key] || 0;

    for (let i = 0; i < cappedPicks.length; i++) {
      const exName = cappedPicks[i];

      // Equipment filter: exclude gym-only exercises in home mode
      if (prefs.equipment === 'home' && GYM_ONLY_REGEX.test(exName)) continue;

      const db = EXERCISE_DB[exName];
      const p = prescribeExercise(exName);
      const mp = getMovementPattern(exName);

      // No OHP filter: exclude compound vertical push
      if (prefs.avoidOHP && mp === 'vertical_push' && db && db.type === 'compound') continue;

      const typeBonus = (db && db.type === 'compound') ? 1.5 : 1.0;
      let deficitBonus = 1.0;
      if (db && db.benchmarkLbs > 0 && p.weightLbs > 0) {
        deficitBonus = (p.weightLbs / db.benchmarkLbs) < 0.85 ? 1.3 : 1.0;
      }
      const orderBonus = 1 - (i * 0.1);
      const importance = groupPriority * typeBonus * deficitBonus * orderBonus;
      const timeSec = calculateExerciseTime(exName, p.sets);

      candidates.push({
        name: exName, muscle: key, prescription: p,
        importance, timeSec,
        isCompound: db && db.type === 'compound',
        isIsolation: db && db.type === 'isolation',
        movementPattern: mp,
      });
    }
  }

  candidates.sort((a, b) => b.importance - a.importance);

  // Time cap from prefs
  const capSec = (prefs.sessionCapMin || TIME_CONSTANTS.sessionCapMin) * 60;
  const session = [];
  let totalSec = 0;
  const usedPatterns = new Set();
  const muscleCompoundCount = {};

  const topMuscle = topKeys[0];
  let topMuscleHasIsolation = false;

  // Strictness rules
  const enforcePatternRule = prefs.strictness !== 'loose';
  const strictCompoundRule = prefs.strictness === 'strict';

  for (const c of candidates) {
    if (totalSec + c.timeSec > capSec) continue;

    // Movement pattern uniqueness (strict + balanced)
    if (enforcePatternRule && c.isCompound && c.movementPattern) {
      if (usedPatterns.has(c.movementPattern)) continue;
    }

    // Max 1 compound per muscle
    if (c.isCompound) {
      if (strictCompoundRule && (muscleCompoundCount[c.muscle] || 0) >= 1) continue;
      // Balanced: relax if session is under-filled (<70% cap)
      if (prefs.strictness === 'balanced' && (muscleCompoundCount[c.muscle] || 0) >= 1) {
        if (totalSec >= capSec * 0.7) continue;
      }
    }

    session.push(c);
    totalSec += c.timeSec;
    if (c.isCompound && c.movementPattern) usedPatterns.add(c.movementPattern);
    if (c.isCompound) muscleCompoundCount[c.muscle] = (muscleCompoundCount[c.muscle] || 0) + 1;
    if (c.muscle === topMuscle && c.isIsolation) topMuscleHasIsolation = true;
  }

  // Ensure #1 priority has at least one isolation if possible
  if (!topMuscleHasIsolation && session.length > 0) {
    const isoCandidate = candidates.find(c =>
      c.muscle === topMuscle && c.isIsolation && !session.includes(c) &&
      totalSec + c.timeSec <= capSec
    );
    if (isoCandidate) {
      session.push(isoCandidate);
      totalSec += isoCandidate.timeSec;
    }
  }

  return { exercises: session, totalSec };
}

// ============================================================
// RENDERING
// ============================================================
function renderRecommendations(recs) {
  const container = document.getElementById('recommendations');
  const top = recs.slice(0, 6);

  container.innerHTML = top.map((r, i) => `
    <div class="rec-item" onclick="toggleExplainer(this)">
      <div class="rec-row">
        <div class="rec-rank">${i + 1}</div>
        <div class="rec-info">
          <div class="rec-name">${r.name}</div>
          <div class="rec-detail">${r.detail}</div>
        </div>
        <div class="rec-urgency urgency-${r.urgency}">${r.urgency}</div>
      </div>
      <div class="rec-expand">
        <div class="rec-explainer">${r.explainer}</div>
      </div>
    </div>
  `).join('');
}

function renderTimedSession(recs) {
  const { exercises, totalSec } = buildTimedSession(recs);
  const totalMin = Math.round(totalSec / 60);

  document.getElementById('session-summary').innerHTML = `
    <div class="session-summary">
      <div class="session-time">~${totalMin} min</div>
      <div class="session-count">${exercises.length} exercises</div>
    </div>
  `;

  const exContainer = document.getElementById('suggested-exercises');
  const grouped = {};
  for (const ex of exercises) {
    if (!grouped[ex.muscle]) grouped[ex.muscle] = [];
    grouped[ex.muscle].push(ex);
  }

  let exHtml = '';
  for (const [key, exes] of Object.entries(grouped)) {
    const meta = MUSCLE_GROUPS[key];
    if (!meta) continue;
    exHtml += `<div class="ex-group">
      <div class="ex-group-title" style="color:${meta.color}">${meta.name}</div>`;
    for (const ex of exes) {
      const rx = formatPrescription(ex.prescription);
      const timeMin = (ex.timeSec / 60).toFixed(0);
      exHtml += `
        <div class="ex-row">
          <div class="ex-name">${ex.name}</div>
          <div class="ex-prescription">${rx}</div>
          <div class="ex-time">${timeMin}m</div>
        </div>`;
    }
    exHtml += `</div>`;
  }
  exContainer.innerHTML = exHtml;
}

function toggleExplainer(el) {
  const expand = el.querySelector('.rec-expand');
  if (expand.classList.contains('open')) {
    expand.style.maxHeight = '0';
    expand.classList.remove('open');
  } else {
    document.querySelectorAll('.rec-expand.open').forEach(other => {
      other.style.maxHeight = '0';
      other.classList.remove('open');
    });
    expand.classList.add('open');
    expand.style.maxHeight = expand.scrollHeight + 'px';
  }
}

// ============================================================
// MUSCLE GRID (v1.1 Task 3: simplified - no percentile text, no bar)
// ============================================================
function getMuscleCardColor(muscleKey, daysSinceTrained, idealFreqDays) {
  const rmData = muscle1RMs[muscleKey];
  let percentile = rmData ? rmData.percentile : null;

  if (percentile === null) {
    const stat = muscleAnalysis ? muscleAnalysis[muscleKey] : null;
    if (stat) {
      const volRatio = stat.totalSets30d / (stat.idealSetsPerWeek * 4.3);
      percentile = Math.round(Math.min(volRatio, 1) * 75);
    } else {
      percentile = 25;
    }
  }

  let hue;
  if (percentile < 25) hue = Math.round((percentile / 25) * 30);
  else if (percentile < 50) hue = 30 + Math.round(((percentile - 25) / 25) * 40);
  else if (percentile < 75) hue = 70 + Math.round(((percentile - 50) / 25) * 40);
  else hue = 110 + Math.round(Math.min((percentile - 75) / 25, 1) * 30);

  const overdueDays = Math.max(0, daysSinceTrained - idealFreqDays);
  let sat, light;
  if (daysSinceTrained === Infinity) { sat = 60; light = 25; }
  else if (overdueDays <= 0) { sat = 20; light = 16; }
  else if (overdueDays <= 2) { sat = 35; light = 19; }
  else { sat = Math.min(55 + overdueDays * 3, 70); light = Math.min(22 + overdueDays, 30); }

  return {
    bg: `hsla(${hue}, ${sat}%, ${light}%, 0.35)`,
    border: `hsla(${hue}, ${sat}%, ${light + 15}%, 0.4)`,
    textColor: `hsl(${hue}, ${Math.min(sat + 20, 85)}%, ${Math.min(light + 40, 75)}%)`,
  };
}

function renderMuscleGrid(muscleStats) {
  const grid = document.getElementById('muscle-grid');
  const entries = Object.entries(muscleStats).sort((a, b) => b[1].daysSinceTrained - a[1].daysSinceTrained);

  grid.innerHTML = entries.map(([key, stat]) => {
    const daysText = stat.daysSinceTrained === Infinity ? 'no data' : `${stat.daysSinceTrained}d ago`;
    const weeklyVol = (stat.totalSets30d / 4.3).toFixed(1);
    const colors = getMuscleCardColor(key, stat.daysSinceTrained, stat.idealFreqDays);

    return `
      <div class="muscle-cell" style="background:${colors.bg};border-color:${colors.border}">
        <div class="muscle-name" style="color:${colors.textColor}">${stat.name}</div>
        <div class="muscle-stat">${daysText} \u00b7 ${weeklyVol}/${stat.idealSetsPerWeek}/wk</div>
      </div>`;
  }).join('');
}

// ============================================================
// HEATMAP (v1.1 Task 1: 10 days, no scroll, no direction row)
// ============================================================
let heatmapDayWorkouts = {};
let selectedHeatmapDay = null;

function renderHeatmap(dayMuscleMap, dayWorkoutsMap) {
  heatmapDayWorkouts = dayWorkoutsMap;
  const container = document.getElementById('heatmap-container');
  const muscleKeys = ['chest', 'back', 'shoulders', 'quads', 'hamstrings', 'glutes', 'biceps', 'triceps', 'calves', 'core'];
  const muscleLabels = ['Chest', 'Back', 'Shldr', 'Quads', 'Hams', 'Glts', 'Bis', 'Tris', 'Calves', 'Core'];

  // v1.1: 10 days lookback, no scroll
  const now = new Date();
  const days = [];
  const numDays = 10;
  for (let i = numDays - 1; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(d.getDate() - i);
    days.push(d.toISOString().split('T')[0]);
  }

  let maxSets = 0;
  for (const [, muscles] of Object.entries(dayMuscleMap)) {
    for (const [, sets] of Object.entries(muscles)) {
      if (sets > maxSets) maxSets = sets;
    }
  }
  if (maxSets === 0) maxSets = 1;

  const labelWidth = 54;
  const cellSize = 18;
  let html = '';

  // Fixed cell sizing for stable layout on all widths
  html += `<div class="heatmap-grid" style="grid-template-columns: ${labelWidth}px repeat(${numDays}, ${cellSize}px); grid-template-rows: 22px repeat(${muscleKeys.length}, ${cellSize}px);">`;

  // Day labels row
  html += `<div></div>`;
  for (let i = 0; i < days.length; i++) {
    const d = new Date(days[i] + 'T12:00:00');
    const isFirst = i === 0;
    const isLast = i === days.length - 1;
    let label = '';
    if (isFirst) {
      label = `${d.getMonth() + 1}/${d.getDate()}`;
    } else if (isLast) {
      label = 'Today';
    }
    html += `<div class="heatmap-day-labels">${label}</div>`;
  }

  // Muscle rows
  for (let m = 0; m < muscleKeys.length; m++) {
    const mKey = muscleKeys[m];
    html += `<div class="heatmap-label">${muscleLabels[m]}</div>`;
    for (const day of days) {
      const sets = (dayMuscleMap[day] && dayMuscleMap[day][mKey]) || 0;
      const opacity = sets > 0 ? Math.max(0.25, Math.min(sets / maxSets, 1)) : 0;
      const bgColor = sets > 0 ? `rgba(74, 222, 128, ${opacity})` : 'var(--surface2)';
      html += `<div class="heatmap-cell" style="background:${bgColor}" data-day="${day}" onclick="selectHeatmapDay('${day}')" title="${day}: ${formatSets(sets)} sets"></div>`;
    }
  }

  html += '</div>';
  container.innerHTML = html;
}

function selectHeatmapDay(day) {
  const detailEl = document.getElementById('heatmap-day-detail');
  const innerEl = document.getElementById('heatmap-day-detail-inner');

  if (selectedHeatmapDay === day && detailEl.classList.contains('open')) {
    detailEl.style.maxHeight = '0';
    detailEl.classList.remove('open');
    selectedHeatmapDay = null;
    return;
  }

  selectedHeatmapDay = day;
  const exercises = heatmapDayWorkouts[day] || [];
  const dateObj = new Date(day + 'T12:00:00');
  const dateStr = dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

  if (exercises.length === 0) {
    innerEl.innerHTML = `<div class="detail-date">${dateStr}</div><div style="color:var(--text-dim);font-size:12px;">Rest day</div>`;
  } else {
    let html = `<div class="detail-date">${dateStr}</div>`;
    for (const ex of exercises) {
      const weightStr = ex.bestWeight > 0 ? ` @ ${ex.bestWeight}lbs` : '';
      html += `<div class="detail-exercise">
        <span class="detail-name">${ex.name}</span>
        <span class="detail-sets">${ex.sets}s${ex.bestReps > 0 ? ` \u00d7 ${ex.bestReps}r` : ''}${weightStr}</span>
      </div>`;
    }
    innerEl.innerHTML = html;
  }

  detailEl.classList.add('open');
  detailEl.style.maxHeight = innerEl.scrollHeight + 24 + 'px';

  document.querySelectorAll('.heatmap-cell').forEach(cell => {
    cell.style.outline = cell.dataset.day === day ? '1.5px solid var(--accent)' : 'none';
  });
}

// ============================================================
// WEIGHT CHART + SI (v1.1 Task 2: always-visible SI panel)
// ============================================================
function renderWeightChart() {
  WEIGHT_DATA = getMergedWeightData();

  // Update bodyweight BEFORE populating strength detail so benchmarks use fresh weight
  if (WEIGHT_DATA.length > 0) PROFILE.bodyweightLbs = WEIGHT_DATA[0].value;

  // ALWAYS populate strength detail BEFORE any early returns
  populateStrengthDetail();

  if (WEIGHT_DATA.length === 0) return;

  const cutoff = new Date();
  cutoff.setFullYear(cutoff.getFullYear() - 1);
  const recent = WEIGHT_DATA.filter(d => new Date(d.date) >= cutoff).reverse();
  if (recent.length === 0) return;

  const current = WEIGHT_DATA[0].value;
  const prev = WEIGHT_DATA.length > 1 ? WEIGHT_DATA[1].value : current;
  const delta = current - prev;

  document.getElementById('weight-current').textContent = current.toFixed(1);
  const deltaEl = document.getElementById('weight-delta');
  deltaEl.textContent = `${delta >= 0 ? '+' : ''}${delta.toFixed(1)}`;
  deltaEl.style.color = delta <= 0 ? 'var(--accent)' : 'var(--warn)';

  // Canvas
  const canvas = document.getElementById('weight-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 150 * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = '150px';
  ctx.scale(dpr, dpr);

  const w = rect.width;
  const h = 150;
  const pad = { top: 12, bottom: 22, left: 0, right: 0 };
  const chartW = w - pad.left - pad.right;
  const chartH = h - pad.top - pad.bottom;

  const wValues = recent.map(d => d.value);
  const wMin = Math.min(...wValues) - 2;
  const wMax = Math.max(...wValues) + 2;
  const wXStep = chartW / Math.max(recent.length - 1, 1);

  // Weight line
  ctx.beginPath();
  ctx.strokeStyle = '#4ade80';
  ctx.lineWidth = 2.5;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  recent.forEach((d, i) => {
    const x = pad.left + i * wXStep;
    const y = pad.top + (1 - (d.value - wMin) / (wMax - wMin)) * chartH;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Gradient fill
  const lastX = pad.left + (recent.length - 1) * wXStep;
  ctx.lineTo(lastX, h - pad.bottom);
  ctx.lineTo(pad.left, h - pad.bottom);
  ctx.closePath();
  const gradient = ctx.createLinearGradient(0, 0, 0, h);
  gradient.addColorStop(0, 'rgba(74, 222, 128, 0.10)');
  gradient.addColorStop(1, 'rgba(74, 222, 128, 0)');
  ctx.fillStyle = gradient;
  ctx.fill();

  // Endpoint dots
  [0, recent.length - 1].forEach(i => {
    const x = pad.left + i * wXStep;
    const y = pad.top + (1 - (recent[i].value - wMin) / (wMax - wMin)) * chartH;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#4ade80';
    ctx.fill();
  });

  // Strength Index line
  if (strengthIndexData.length >= 2) {
    const wDates = recent.map(d => d.date);
    const firstDate = wDates[0];
    const lastDate = wDates[wDates.length - 1];
    const totalDays = (new Date(lastDate) - new Date(firstDate)) / (1000 * 60 * 60 * 24);

    const siFiltered = strengthIndexData.filter(d => d.date >= firstDate && d.date <= lastDate);
    if (siFiltered.length >= 2) {
      const siValues = siFiltered.map(d => d.index);
      const siMin = Math.min(...siValues) - 0.1;
      const siMax = Math.max(...siValues) + 0.1;

      ctx.beginPath();
      ctx.strokeStyle = '#818cf8';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);

      siFiltered.forEach((d, i) => {
        const dayOffset = (new Date(d.date) - new Date(firstDate)) / (1000 * 60 * 60 * 24);
        const x = pad.left + (totalDays > 0 ? (dayOffset / totalDays) : 0) * chartW;
        const y = pad.top + (1 - (d.index - siMin) / (siMax - siMin)) * chartH;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.setLineDash([]);

      [0, siFiltered.length - 1].forEach(i => {
        const d = siFiltered[i];
        const dayOffset = (new Date(d.date) - new Date(firstDate)) / (1000 * 60 * 60 * 24);
        const x = pad.left + (totalDays > 0 ? (dayOffset / totalDays) : 0) * chartW;
        const y = pad.top + (1 - (d.index - siMin) / (siMax - siMin)) * chartH;
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fillStyle = '#818cf8';
        ctx.fill();
      });
    }
  }

  // Date labels
  ctx.fillStyle = '#909098';
  ctx.font = '12px JetBrains Mono, monospace';
  ctx.textAlign = 'left';
  ctx.fillText(recent[0].date.substring(5), pad.left, h - 4);
  ctx.textAlign = 'right';
  ctx.fillText(recent[recent.length - 1].date.substring(5), w - pad.right, h - 4);
}

// v1.1: Populate SI detail content (always called, even if weight data is empty)
function populateStrengthDetail() {
  const siLabel = document.getElementById('strength-index-label');
  const detailInner = document.getElementById('strength-detail-inner');

  const liftBenchmarks = {
    bench:    { label: 'Bench',    std: 'bench_press' },
    squat:    { label: 'Squat',    std: 'squat' },
    deadlift: { label: 'Deadlift', std: 'deadlift' },
    ohp:      { label: 'OHP',      std: 'overhead_press' },
    row:      { label: 'Row',      std: 'barbell_row' },
  };

  const bw = PROFILE.bodyweightLbs;
  let latestSI = null;

  if (strengthIndexData.length > 0) {
    latestSI = strengthIndexData[strengthIndexData.length - 1];
    siLabel.textContent = `SS: ${latestSI.index.toFixed(2)}`;
  } else {
    siLabel.textContent = `SS: --`;
  }

  let detailHtml = '<div style="display:grid;grid-template-columns:1fr;gap:2px;">';
  for (const [key, info] of Object.entries(liftBenchmarks)) {
    const lift = latestSI ? latestSI.lifts[key] : null;
    const std = STRENGTH_STANDARDS[info.std];
    const m = std ? std.multipliers : null;

    detailHtml += '<div style="padding:8px 0;border-bottom:1px solid var(--border);">';
    detailHtml += `<div style="font-weight:600;color:var(--text);font-size:14px;margin-bottom:4px;">${info.label}</div>`;

    if (lift && lift.rm > 0) {
      const pctile = estimatePercentile(info.std, lift.mult);
      const pctColor = pctile >= 75 ? 'var(--accent)' : pctile >= 50 ? 'var(--warn)' : 'var(--danger)';
      detailHtml += `<div style="color:var(--text-mid);font-size:13px;">You: <span style="color:var(--text);font-weight:600;">${lift.rm} lbs</span> (${lift.mult}\u00d7 BW) <span style="color:${pctColor};font-weight:600;">${pctile}th %ile</span></div>`;
    } else {
      detailHtml += `<div style="color:var(--text-dim);font-size:13px;">You: no data yet</div>`;
    }

    if (m) {
      const p50 = Math.round(m[2] * bw);
      const p75 = Math.round(m[3] * bw);
      const p90 = Math.round(m[4] * bw);
      detailHtml += `<div style="color:var(--text-dim);font-size:12px;margin-top:3px;">50th: ${p50}lbs \u00b7 75th: ${p75}lbs \u00b7 90th: ${p90}lbs</div>`;
    }
    detailHtml += '</div>';
  }
  detailHtml += '</div>';
  detailInner.innerHTML = detailHtml;
}

// ============================================================
// WEIGHT INPUT
// ============================================================
function toggleWeightForm() {
  const form = document.getElementById('weight-input-form');
  form.classList.toggle('open');
  if (form.classList.contains('open')) {
    const input = document.getElementById('weight-input');
    input.value = '';
    input.focus();
  }
}

function saveWeight() {
  const input = document.getElementById('weight-input');
  const val = parseFloat(input.value);
  if (isNaN(val) || val < 50 || val > 500) {
    input.style.borderColor = 'var(--danger)';
    setTimeout(() => { input.style.borderColor = 'var(--border)'; }, 1500);
    return;
  }
  const today = new Date().toISOString().split('T')[0];
  saveWeightEntry(today, val);
  toggleWeightForm();
  renderWeightChart();
}

// ============================================================
// TAB SWITCHING
// ============================================================
function switchTab(tab) {
  document.querySelectorAll('[id^="tab-"]').forEach(el => el.classList.add('hidden'));
  document.getElementById(`tab-${tab}`).classList.remove('hidden');
  document.querySelectorAll('.tab').forEach(el => {
    el.classList.toggle('active', el.dataset.tab === tab);
  });
  if (tab === 'weight') {
    setTimeout(renderWeightChart, 50);
  }
}

// ============================================================
// APP LIFECYCLE
// ============================================================
function showScreen(screen) {
  ['loading-screen', 'dashboard'].forEach(id => {
    document.getElementById(id).classList.toggle('hidden', id !== screen);
  });
}

function updateLoading(text) {
  document.getElementById('loading-text').textContent = text;
}

function showError(msg) {
  document.getElementById('error-area').innerHTML = `<div class="error-msg">${msg}</div>`;
}

// Render dashboard from workouts data (shared by cache + fresh load)
function renderDashboard(workouts) {
  WEIGHT_DATA = getMergedWeightData();
  if (WEIGHT_DATA.length > 0) PROFILE.bodyweightLbs = WEIGHT_DATA[0].value;

  // v1.1 Task 6: unified preprocess pipeline
  const pp = preprocessWorkouts(workouts, PROFILE.bodyweightLbs);

  exerciseHistory = pp.exerciseHistory;
  muscleAnalysis = pp.muscleStats;
  muscle1RMs = pp.muscle1RMs;
  strengthIndexData = pp.strengthIndexTimeline;

  const recs = generateRecommendations(pp.muscleStats);
  LAST_RECS = recs;

  showScreen('dashboard');

  const now = new Date();
  document.getElementById('last-updated').textContent =
    `v1.1 \u00b7 ${now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}`;

  renderRecommendations(recs);
  renderConstraintChips();
  renderTimedSession(recs);
  renderMuscleGrid(pp.muscleStats);
  renderHeatmap(pp.heatmapDayMuscle, pp.heatmapDayWorkouts);
  renderWeightChart();
}

async function refreshData() {
  showScreen('loading-screen');
  try {
    updateLoading('Refreshing...');
    const workouts = await fetchWorkouts(10, 10);
    workoutCache = workouts;
    setCachedWorkouts(workouts);
    renderDashboard(workouts);
  } catch (err) {
    console.error(err);
    showScreen('dashboard');
    showError(`Refresh failed: ${err.message}`);
  }
}

async function loadDashboard() {
  showScreen('loading-screen');

  try {
    // v1.1 Task 7: Try cache first for instant load
    const cached = getCachedWorkouts();
    if (cached && cached.data && cached.data.length > 0) {
      updateLoading('Loading from cache...');
      workoutCache = cached.data;
      renderDashboard(cached.data);

      // If stale, refresh in background
      if (isCacheStale(cached)) {
        fetchWorkouts(10, 10).then(fresh => {
          workoutCache = fresh;
          setCachedWorkouts(fresh);
          renderDashboard(fresh);
        }).catch(err => {
          console.warn('Background refresh failed:', err.message);
        });
      }
      return;
    }

    // No cache - fresh load
    updateLoading('Loading workouts...');
    const workouts = await fetchWorkouts(10, 10);
    workoutCache = workouts;
    setCachedWorkouts(workouts);
    renderDashboard(workouts);
  } catch (err) {
    console.error(err);
    showScreen('dashboard');
    showError(`Failed to load: ${err.message}`);
  }
}

// Boot
loadDashboard();
</script>
</body>
</html>
